---
title: "On-Device ML Alternative"
description: "Build BetAway's core sentiment analysis using Apple's NaturalLanguage framework — a zero-cost, privacy-first engine that runs entirely on-device without an API key or network connection."
courseSlug: "ship-native"
module: 4
moduleTitle: "AI Integration"
lesson: 2
duration: "18 min read"
difficulty: "intermediate"
topics: ["NaturalLanguage", "NLTagger", "Sentiment Analysis", "On-Device ML", "Offline", "Privacy", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

In the previous lesson we walked through a production-quality OpenAI API integration — the cloud approach to sentiment analysis. BetAway deliberately rejects that path. Recovery journal entries are too sensitive to send to any cloud service. Users are writing about gambling debts, family damage, moments of crisis. That data stays on the device. Period.

Apple ships a framework called **NaturalLanguage** on every iPhone, iPad, and Mac. It includes a pre-trained sentiment analysis model that runs entirely on device. No API key. No network. No cost. No data leaving the phone. It is less nuanced than GPT, but it is always available, and for the core use case — analyzing a recovery journal entry to detect sentiment and track behavioral patterns — it is surprisingly good.

This lesson builds BetAway's primary sentiment analysis engine using on-device ML. This is not a fallback. This is the production path.

## What You'll Learn

- How Apple's **NaturalLanguage** framework and **NLTagger** work for sentiment analysis
- Building a `SentimentAnalyzer` that maps NL scores to BetAway's recovery score levels
- Creating a `RecoveryService` that provides journal analysis as part of BetAway's Service Layer
- The privacy and cost advantages of on-device processing for a recovery app
- When on-device ML is the right primary choice, not just a fallback

## Why This Matters

Most apps built with AI assistants hard-wire themselves to a single cloud provider. The developer prompts for "OpenAI integration," gets working code, and ships it. Then users on the subway, users on airplane mode, users who never set up an API key — they all get an error screen.

This is an anti-pattern you will see constantly in vibe-coded apps. The developer builds the happy path with the AI and forgets that the real world has spotty cell service.

For BetAway, this anti-pattern is not just inconvenient — it is dangerous. A user experiencing a gambling urge at 2 AM needs the app to work immediately. No network required. No API key required. No loading spinner while a server processes their crisis journal entry. On-device ML makes this possible.

The secondary benefit is privacy. Recovery journal entries are deeply personal. Users are documenting financial losses, relationship breakdowns, and emotional vulnerabilities. On-device processing means BetAway can make a genuine privacy promise — not a marketing claim backed by a Terms of Service, but a technical guarantee that the text physically cannot leave the device.

## Plan Phase

Before writing any code, we need to think through the design. Here is the prompt to start the planning conversation:

```
I'm building BetAway, a gambling recovery app (Swift 6, SwiftUI,
iOS 17+). BetAway uses MVVM + Service Layer architecture with
SwiftData. I need to build the primary sentiment analysis engine
using Apple's NaturalLanguage framework — all analysis runs
on-device for privacy.

Plan the implementation. I need:

1. A SentimentAnalyzer struct that takes a String and returns a
   recovery score (1–5) and a confidence score, using NLTagger
   with .sentimentScore
2. A RecoveryService that provides journal analysis as part of
   BetAway's Service Layer, conforming to a JournalAnalysisService
   protocol
3. Keep it testable — the service behind a protocol
4. This is the primary analysis path, not a fallback

Do NOT write code yet. Just outline the types, the flow, and flag
any edge cases.
```

A good AI response will outline something like this:

- `JournalAnalysisService` protocol with `func analyzeEntry(from text: String) async throws -> JournalAnalysisResult`
- `JournalAnalysisResult` struct holding `recoveryScore: Int` (1-5), `insight: String`, `source: AnalysisSource` (.onDevice)
- `SentimentAnalyzer` — pure logic, no protocol, takes text and returns a score
- `RecoveryService` conforms to `JournalAnalysisService`, uses `SentimentAnalyzer` internally

The edge cases to watch for:

- **Empty text** — NLTagger returns 0.0 for empty strings. That maps to neutral (level 3), which is a reasonable default.
- **Mixed sentiment** — A long entry with both hopeful and distressed passages. NLTagger returns a single aggregate score. It will not be as nuanced as GPT, and that is fine.
- **Language support** — NLTagger's sentiment model works best with English. For other languages, accuracy drops.

### The anti-pattern to avoid

```
// Bad: Requiring network for basic features in a recovery app.
func analyzeEntry(from text: String) async throws -> AnalysisResult {
    return try await openAIService.analyze(text)
    // If this throws, the user sees an error during a crisis moment.
}
```

This is the "always require network for basic features" anti-pattern. It turns a flaky dependency (the network) into a hard requirement for core functionality. If sentiment analysis is central to your app — and in BetAway, it is — it must work offline.

## Execute Phase

Now we build it. Start with the foundation.

### Prompt 1 — SentimentAnalyzer

```
Create a SentimentAnalyzer struct in Services/ML/SentimentAnalyzer.swift.

Requirements:
- Import NaturalLanguage
- Method: func analyze(_ text: String) -> SentimentResult
- Use NLTagger with .sentimentScore tag scheme
- NLTagger returns a Double from -1.0 (negative) to 1.0 (positive)
- Map that score to a recovery score 1–5:
  - -1.0 to -0.6 → level 1 (very negative)
  - -0.6 to -0.2 → level 2 (somewhat negative)
  - -0.2 to  0.2 → level 3 (neutral)
  -  0.2 to  0.6 → level 4 (somewhat positive)
  -  0.6 to  1.0 → level 5 (very positive)
- SentimentResult struct: recoveryScore (Int), confidence (Double 0–1),
  rawScore (Double)
- The confidence is the absolute value of the raw score (stronger
  sentiment = higher confidence)
- Handle the empty string case (return level 3, confidence 0)
- No async needed — NLTagger is synchronous
- Add os.Logger
- Target Swift 6, iOS 17+
```

Here is the code you should get, reviewed and annotated:

```swift
import NaturalLanguage
import os

struct SentimentResult {
    let recoveryScore: Int   // 1–5
    let confidence: Double   // 0.0–1.0
    let rawScore: Double     // -1.0–1.0
}

struct SentimentAnalyzer {
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "SentimentAnalyzer")

    func analyze(_ text: String) -> SentimentResult {
        guard !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            logger.debug("Empty text — returning neutral")
            return SentimentResult(recoveryScore: 3, confidence: 0, rawScore: 0)
        }

        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text

        let (sentimentTag, _) = tagger.tag(
            at: text.startIndex,
            unit: .paragraph,
            scheme: .sentimentScore
        )

        let rawScore = Double(sentimentTag?.rawValue ?? "0") ?? 0.0
        let recoveryScore = mapScoreToRecoveryLevel(rawScore)
        let confidence = min(abs(rawScore), 1.0)

        logger.debug("Sentiment: \(rawScore, format: .fixed(precision: 3)) → recovery score \(recoveryScore) (confidence \(confidence, format: .fixed(precision: 2)))")

        return SentimentResult(
            recoveryScore: recoveryScore,
            confidence: confidence,
            rawScore: rawScore
        )
    }

    private func mapScoreToRecoveryLevel(_ score: Double) -> Int {
        switch score {
        case ...(-0.6):       return 1
        case -0.6..<(-0.2):   return 2
        case -0.2..<0.2:      return 3
        case 0.2..<0.6:       return 4
        default:              return 5
        }
    }
}
```

Let us review this:

- **NLTagger setup** — You create a tagger with the `.sentimentScore` scheme, assign the text, then call `tag(at:unit:scheme:)`. The `unit: .paragraph` tells NLTagger to score the entire text as one block rather than word by word. This is what you want for a journal entry.
- **The raw value trick** — `NLTagger` returns its sentiment score as an `NLTag`, which is a wrapper around a `String`. You have to parse it to a `Double`. This is an API quirk that AI sometimes misses — it tries to cast the tag directly to a number.
- **Score mapping** — The ranges are evenly distributed across the -1 to 1 spectrum. You could adjust these thresholds later if you find the model skews positive or negative for your users' writing style.
- **Confidence** — We use the absolute value of the raw score. A score of 0.9 (very positive) or -0.9 (very negative) both have high confidence. A score near 0 means the model is unsure — which is neutral, level 3.

### Prompt 2 — RecoveryService

```
Create a RecoveryService in Services/ML/RecoveryService.swift.

Requirements:
- Conforms to JournalAnalysisService protocol:
  protocol JournalAnalysisService {
      func analyzeEntry(from text: String) async throws -> JournalAnalysisResult
  }
- JournalAnalysisResult has: recoveryScore (Int), insight (String),
  source (AnalysisSource enum: .onDevice)
- Uses SentimentAnalyzer internally
- Generates a recovery-focused insight string based on the
  recovery score (e.g., "Your entry shows signs of progress
  in your recovery journey." for level 4–5)
- The method is async to match the protocol, but the actual work
  is synchronous (NLTagger is sync)
- Never throws — on-device analysis always succeeds
- Add os.Logger
- Swift 6, Sendable where needed
```

```swift
import Foundation
import os

enum AnalysisSource: String, Sendable {
    case onDevice
}

struct JournalAnalysisResult: Sendable {
    let recoveryScore: Int
    let insight: String
    let source: AnalysisSource
}

protocol JournalAnalysisService: Sendable {
    func analyzeEntry(from text: String) async throws -> JournalAnalysisResult
}

struct RecoveryService: JournalAnalysisService {
    private let analyzer = SentimentAnalyzer()
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "RecoveryService")

    func analyzeEntry(from text: String) async throws -> JournalAnalysisResult {
        let sentiment = analyzer.analyze(text)

        let insight = generateInsight(for: sentiment)

        logger.info("On-device analysis complete: recovery score \(sentiment.recoveryScore), confidence \(sentiment.confidence, format: .fixed(precision: 2))")

        return JournalAnalysisResult(
            recoveryScore: sentiment.recoveryScore,
            insight: insight,
            source: .onDevice
        )
    }

    private func generateInsight(for sentiment: SentimentResult) -> String {
        switch sentiment.recoveryScore {
        case 1:
            return "Your entry suggests you're going through a difficult moment. Remember — reaching for this app instead of gambling is already a win."
        case 2:
            return "Your writing carries some heaviness. Consider using the breathing exercise or reaching out to your support network."
        case 3:
            if sentiment.confidence < 0.1 {
                return "Your entry is fairly neutral. Steady days are part of recovery — they matter more than you think."
            }
            return "Your recovery seems balanced today. A mix of thoughts and feelings is perfectly normal in this journey."
        case 4:
            return "Your entry shows signs of progress in your recovery journey. Hold onto what is working."
        case 5:
            return "Your writing reflects real strength and resilience. This is recovery in action — keep building on it."
        default:
            return "Check-in analyzed."
        }
    }
}
```

Let us review this:

- **Protocol conformance** — `RecoveryService` conforms to `JournalAnalysisService`. This means the ViewModel does not care which implementation it is talking to. If you ever needed to swap in a different analysis backend, the protocol boundary makes that trivial.
- **Never throws** — Notice that even though the protocol method is `throws`, `RecoveryService` never actually throws. On-device analysis cannot fail in any meaningful way. If the text is empty, you get neutral. If the text is gibberish, you get neutral. The model always returns something. This is the reliability advantage of on-device.
- **Sendable conformance** — Swift 6 strict concurrency requires `Sendable` for types passed across actor boundaries. `struct` types with `Sendable` properties are automatically `Sendable`. We mark the protocol as `Sendable` so implementations can be used from any context.
- **Recovery-focused insights** — These are static strings tailored to gambling recovery, not generic wellness advice. They acknowledge the user's struggle and reinforce that using the app is itself a positive step. A future improvement could be a larger set of randomized messages per level.

Now let us look at what to watch for in the AI output. Here is the review checklist:

- **NLTagger tag parsing** — Did the AI parse the `NLTag.rawValue` to `Double`? If it tried `sentimentTag as? Double` or similar, that is wrong.
- **Thread safety** — `NLTagger` is not documented as thread-safe. Our struct creates a new instance per call, which avoids shared state. If the AI made `tagger` a stored property, flag that.
- **The protocol is defined once** — Make sure the AI did not define `JournalAnalysisService` in multiple files. It should live in one place (either its own file or alongside `JournalAnalysisResult`). The service imports it.
- **Sendable** — If the AI ignored `Sendable`, the code will produce warnings under Swift 6 strict concurrency. Push back.

## Iteration

Now we connect the service to the ViewModel. Since BetAway uses on-device ML as the primary (and only) analysis path, this is simpler than a cloud-with-fallback approach.

```
Update our CheckInViewModel to use the RecoveryService for
journal analysis.

Requirements:
- Use RecoveryService for all sentiment analysis
- No cloud fallback needed — on-device is the primary path
- The JournalAnalysisResult includes .source so the UI can show
  "Analyzed on-device" if desired
- Log the analysis path
- Use the JournalAnalysisService protocol — the ViewModel should
  not import NaturalLanguage or know about the ML implementation
  directly
```

The key piece of logic the AI should produce looks like this:

```swift
@Observable
final class CheckInViewModel {
    var analysisResult: JournalAnalysisResult?
    var isAnalyzing = false

    private let analysisService: any JournalAnalysisService
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "CheckInViewModel")

    init(
        analysisService: any JournalAnalysisService = RecoveryService()
    ) {
        self.analysisService = analysisService
    }

    func analyzeEntry(from text: String) async {
        isAnalyzing = true
        defer { isAnalyzing = false }

        do {
            analysisResult = try await analysisService.analyzeEntry(from: text)
            logger.info("Analysis succeeded via \(self.analysisResult?.source.rawValue ?? "unknown")")
        } catch {
            // This should never happen with RecoveryService, but handle it defensively
            logger.error("Analysis failed unexpectedly: \(error.localizedDescription)")
            analysisResult = JournalAnalysisResult(
                recoveryScore: 3,
                insight: "Unable to analyze your entry at this time.",
                source: .onDevice
            )
        }
    }
}
```

This is the pattern. The ViewModel holds an analysis service injected via protocol. Because `RecoveryService` never throws, the error path is purely defensive. The `defer { isAnalyzing = false }` guarantees the loading state is cleared no matter what happens.

### On-Device: The Advantages for Recovery Apps

Here is the honest assessment of on-device ML with NLTagger:

| Factor | On-Device (NLTagger) |
|---|---|
| **Accuracy** | Moderate — aggregate sentiment only |
| **Insight quality** | Template-based, recovery-focused |
| **Latency** | Under 10ms |
| **Cost** | Free, forever |
| **Privacy** | Text never leaves device — guaranteed |
| **Offline** | Always works — critical for crisis moments |
| **Languages** | Best for English, limited otherwise |
| **Availability** | Always available on iOS 11+ |

For BetAway, every factor that matters most — privacy, offline availability, zero cost, speed — favors on-device. The tradeoff in accuracy and insight personalization is real, but acceptable. A user in crisis needs an immediate, reliable response. They do not need a cloud-generated paragraph that takes two seconds to arrive over a shaky connection.

## Verify Phase

Let us make sure everything works. Here is a simple test to verify the sentiment analyzer produces sane results:

```
Write unit tests for SentimentAnalyzer. Test:

1. A clearly positive string returns recovery score 4 or 5
2. A clearly negative string returns recovery score 1 or 2
3. A neutral string returns recovery score 3
4. An empty string returns recovery score 3 with confidence 0
5. The raw score is always between -1.0 and 1.0
6. The confidence is always between 0.0 and 1.0

Use Swift Testing framework (@Test, #expect).
Do NOT test exact recovery scores — NLTagger is a model, not a
deterministic function. Test ranges.
```

```swift
import Testing
@testable import BetAway

struct SentimentAnalyzerTests {
    let analyzer = SentimentAnalyzer()

    @Test func positiveTextReturnsHighRecoveryScore() {
        let result = analyzer.analyze(
            "I had an amazing day! I resisted every urge and feel proud of my progress."
        )
        #expect(result.recoveryScore >= 4)
        #expect(result.rawScore > 0)
    }

    @Test func negativeTextReturnsLowRecoveryScore() {
        let result = analyzer.analyze(
            "Everything went wrong today. I feel terrible and the urges are overwhelming."
        )
        #expect(result.recoveryScore <= 2)
        #expect(result.rawScore < 0)
    }

    @Test func neutralTextReturnsMidRecoveryScore() {
        let result = analyzer.analyze(
            "I went to the store and bought some groceries. Then I came home."
        )
        #expect(result.recoveryScore == 3)
    }

    @Test func emptyTextReturnsNeutralWithZeroConfidence() {
        let result = analyzer.analyze("")
        #expect(result.recoveryScore == 3)
        #expect(result.confidence == 0)
        #expect(result.rawScore == 0)
    }

    @Test func rawScoreIsInValidRange() {
        let texts = [
            "I love this progress!",
            "I hate how I feel.",
            "It is fine.",
            "The weather is partly cloudy with a chance of rain."
        ]

        for text in texts {
            let result = analyzer.analyze(text)
            #expect(result.rawScore >= -1.0)
            #expect(result.rawScore <= 1.0)
        }
    }

    @Test func confidenceIsInValidRange() {
        let texts = [
            "Best day of my recovery!",
            "Worst experience of my life.",
            "I ate lunch.",
            ""
        ]

        for text in texts {
            let result = analyzer.analyze(text)
            #expect(result.confidence >= 0.0)
            #expect(result.confidence <= 1.0)
        }
    }
}
```

Notice the testing strategy. We do **not** test for exact recovery scores on real text. NLTagger is a machine learning model — its output can vary slightly across iOS versions as Apple updates the model. What we test is that positive text trends positive, negative text trends negative, and edge cases are handled correctly. Deterministic assertions on ML output lead to flaky tests.

For the service layer, you can test the ViewModel with a mock service:

```swift
struct MockAnalysisService: JournalAnalysisService {
    let result: JournalAnalysisResult

    func analyzeEntry(from text: String) async throws -> JournalAnalysisResult {
        result
    }
}

@Test func viewModelUsesInjectedService() async {
    let expected = JournalAnalysisResult(
        recoveryScore: 4,
        insight: "Test insight",
        source: .onDevice
    )

    let viewModel = CheckInViewModel(
        analysisService: MockAnalysisService(result: expected)
    )

    await viewModel.analyzeEntry(from: "I feel great about my recovery today!")

    #expect(viewModel.analysisResult != nil)
    #expect(viewModel.analysisResult?.recoveryScore == 4)
    #expect(viewModel.analysisResult?.source == .onDevice)
}

@Test func viewModelHandlesAnalysisGracefully() async {
    let viewModel = CheckInViewModel(
        analysisService: RecoveryService()
    )

    await viewModel.analyzeEntry(from: "I feel great today!")

    #expect(viewModel.analysisResult != nil)
    #expect(viewModel.analysisResult?.source == .onDevice)
}
```

Because the service is behind a protocol, testing is trivial. You inject a mock and verify the result. No mocking frameworks, no network stubs. Protocol-based design pays for itself in the test suite.

## Final Code

Here is the complete code for the two primary files.

### SentimentAnalyzer.swift

```swift
// Services/ML/SentimentAnalyzer.swift

import NaturalLanguage
import os

struct SentimentResult: Sendable {
    let recoveryScore: Int
    let confidence: Double
    let rawScore: Double
}

struct SentimentAnalyzer: Sendable {
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "SentimentAnalyzer")

    func analyze(_ text: String) -> SentimentResult {
        guard !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            logger.debug("Empty text — returning neutral")
            return SentimentResult(recoveryScore: 3, confidence: 0, rawScore: 0)
        }

        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text

        let (sentimentTag, _) = tagger.tag(
            at: text.startIndex,
            unit: .paragraph,
            scheme: .sentimentScore
        )

        let rawScore = Double(sentimentTag?.rawValue ?? "0") ?? 0.0
        let recoveryScore = mapScoreToRecoveryLevel(rawScore)
        let confidence = min(abs(rawScore), 1.0)

        logger.debug("Sentiment: \(rawScore, format: .fixed(precision: 3)) → recovery score \(recoveryScore) (confidence \(confidence, format: .fixed(precision: 2)))")

        return SentimentResult(
            recoveryScore: recoveryScore,
            confidence: confidence,
            rawScore: rawScore
        )
    }

    private func mapScoreToRecoveryLevel(_ score: Double) -> Int {
        switch score {
        case ...(-0.6):       return 1
        case -0.6..<(-0.2):   return 2
        case -0.2..<0.2:      return 3
        case 0.2..<0.6:       return 4
        default:              return 5
        }
    }
}
```

### RecoveryService.swift

```swift
// Services/ML/RecoveryService.swift

import Foundation
import os

enum AnalysisSource: String, Sendable {
    case onDevice
}

struct JournalAnalysisResult: Sendable {
    let recoveryScore: Int
    let insight: String
    let source: AnalysisSource
}

protocol JournalAnalysisService: Sendable {
    func analyzeEntry(from text: String) async throws -> JournalAnalysisResult
}

struct RecoveryService: JournalAnalysisService {
    private let analyzer = SentimentAnalyzer()
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "RecoveryService")

    func analyzeEntry(from text: String) async throws -> JournalAnalysisResult {
        let sentiment = analyzer.analyze(text)

        let insight = generateInsight(for: sentiment)

        logger.info("On-device analysis complete: recovery score \(sentiment.recoveryScore), confidence \(sentiment.confidence, format: .fixed(precision: 2))")

        return JournalAnalysisResult(
            recoveryScore: sentiment.recoveryScore,
            insight: insight,
            source: .onDevice
        )
    }

    private func generateInsight(for sentiment: SentimentResult) -> String {
        switch sentiment.recoveryScore {
        case 1:
            return "Your entry suggests you're going through a difficult moment. Remember — reaching for this app instead of gambling is already a win."
        case 2:
            return "Your writing carries some heaviness. Consider using the breathing exercise or reaching out to your support network."
        case 3:
            if sentiment.confidence < 0.1 {
                return "Your entry is fairly neutral. Steady days are part of recovery — they matter more than you think."
            }
            return "Your recovery seems balanced today. A mix of thoughts and feelings is perfectly normal in this journey."
        case 4:
            return "Your entry shows signs of progress in your recovery journey. Hold onto what is working."
        case 5:
            return "Your writing reflects real strength and resilience. This is recovery in action — keep building on it."
        default:
            return "Check-in analyzed."
        }
    }
}
```

## Checkpoint

At this point you should have:

- A `SentimentAnalyzer` that takes any string and returns a recovery score 1-5 with a confidence score, powered entirely by Apple's on-device NaturalLanguage model
- A `RecoveryService` conforming to `JournalAnalysisService`, providing analysis as part of BetAway's Service Layer
- A `CheckInViewModel` that uses the service for all journal analysis
- Unit tests that verify sentiment ranges (not exact values) and the service layer
- Zero new dependencies, zero API costs, zero privacy concerns

Run the app in airplane mode. Type a recovery journal entry. Tap analyze. You should see a recovery score and an insight, powered entirely by NLTagger. No spinner waiting for a server. No error alert. It just works.

That is the BetAway promise: the app works when you need it, where you need it, without compromises.

## Challenge

**Add sentence-level analysis for richer recovery insights (30 minutes):**

1. Extend `SentimentAnalyzer` to analyze text **sentence by sentence** instead of as one paragraph. Return the per-sentence scores alongside the aggregate. Display the most positive and most negative sentences in the insight card. Hint: use `NLTagger` with `unit: .sentence` and `enumerateTags(in:unit:scheme:)`.

2. Show a small indicator on the analysis result — something like a shield icon with "Analyzed on device" — when the result is displayed. This reinforces BetAway's privacy commitment to the user.

3. Use the per-sentence analysis to detect mixed signals — a journal entry that contains both hopeful and distressed passages. Flag these to the user: "Your entry shows mixed emotions — that is a natural part of recovery." This is more useful than a single aggregate score for someone working through complex feelings about their gambling behavior.

This challenge tests whether you can extend the on-device path into a genuinely differentiated feature — not just a basic sentiment score, but something that provides real value to someone in recovery.
