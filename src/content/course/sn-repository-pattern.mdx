---
title: "Repository Pattern Implementation"
description: "Implement protocol-based repositories with generic CRUD operations, a concrete SwiftData implementation, and dependency injection that makes your code testable from day one."
courseSlug: "ship-native"
module: 3
moduleTitle: "Data Layer & Persistence"
lesson: 1
duration: "22 min read"
difficulty: "intermediate"
topics: ["Repository Pattern", "Protocol", "Dependency Injection", "SwiftData", "CRUD", "Generics", "Testability", "Moodbit"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

In the previous module we built Moodbit's UI layer — the mood timeline, the entry flow, and the navigation architecture. Every one of those views is currently backed by placeholder data. Time to fix that.

This lesson introduces the pattern that will underpin every data operation in Moodbit: the repository pattern. By the end, your views will read and write real persisted data, but they will never know — or care — whether that data comes from SwiftData, an in-memory store, or a mock you created for tests.

## What You'll Learn

1. **Define a `MoodRepository` protocol** that exposes generic CRUD operations and hides all persistence details from the rest of the app.
2. **Build `SwiftDataMoodRepository`**, a concrete implementation that uses `ModelContext` for reading and writing mood entries.
3. **Create a `RepositoryProvider`** that acts as a lightweight dependency injection container, so ViewModels receive protocols — never concrete types.
4. **Write a `MockMoodRepository`** that powers SwiftUI previews and unit tests without touching a database.

## Why This Matters

In a small personal project, calling `modelContext.insert()` directly from a ViewModel works. In a production app, it is a liability.

The moment you want to write a unit test, you need a real SwiftData container — or you skip the test. The moment you want to swap persistence frameworks (Core Data to SwiftData, for instance), you rewrite every ViewModel. The moment two developers touch the same ViewModel, they trip over persistence logic mixed in with business logic.

The repository pattern solves all three problems with one abstraction. Your ViewModels depend on a protocol. Production injects the SwiftData implementation. Tests inject a mock. The ViewModel code is identical in both cases. This is not academic architecture astronautics — it is the difference between code that ships once and code that ships continuously.

## Plan Phase: Defining What We Build

Open Claude Code in your Moodbit project directory and send this planning prompt:

```
I need to implement the repository pattern for Moodbit's mood entries.

Before writing code, plan the following:

1. A MoodRepository protocol with these operations:
   - fetchAll() — returns all mood entries sorted by date descending
   - fetch(by id: UUID) — returns a single entry or nil
   - save(MoodEntry) — persists a new entry
   - update(MoodEntry) — updates an existing entry
   - delete(MoodEntry) — removes an entry

2. A SwiftDataMoodRepository class that implements the protocol
   using ModelContext.

3. A RepositoryProvider that holds repository instances and can
   be swapped between production and test configurations.

4. A MockMoodRepository for previews and tests.

All code must use Swift 6 strict concurrency. Annotate with
@MainActor where needed. Do NOT use singletons.

Think through the design first — do not generate code yet.
```

### What you should see in the plan

The AI should identify three things:

- **Protocol methods are `async throws`.** SwiftData operations can fail, and wrapping them in async keeps the door open for future remote persistence.
- **`@MainActor` on the concrete repository.** `ModelContext` is not `Sendable`. Accessing it off the main actor is a Swift 6 error. The protocol itself should not require `@MainActor` — only the SwiftData implementation needs it.
- **`RepositoryProvider` is a struct, not a class.** It holds protocol references and gets injected via the SwiftUI environment or passed through init. No singletons, no global state.

### Anti-pattern: What bad looks like

Here is what to reject if the AI proposes it:

```swift
// BAD — ViewModel directly owns ModelContext
@Observable
class MoodTimelineViewModel {
    private let modelContext: ModelContext  // tight coupling

    func addEntry(_ entry: MoodEntry) {
        modelContext.insert(entry)  // no abstraction
        try? modelContext.save()    // swallowed error
    }
}
```

This ViewModel cannot be tested without a real SwiftData container. It cannot be reused with a different persistence layer. And it silently swallows errors. If your AI output looks like this, push back.

## Execute Phase: Implementation

Now send the execution prompt:

```
Implement the plan. Generate:

1. MoodRepository protocol in Repositories/MoodRepository.swift
2. SwiftDataMoodRepository in Repositories/SwiftDataMoodRepository.swift
3. RepositoryProvider in Repositories/RepositoryProvider.swift
4. MockMoodRepository in Repositories/MockMoodRepository.swift

Requirements:
- Swift 6 strict concurrency
- @MainActor on SwiftDataMoodRepository
- Protocol methods are async throws
- Use os.Logger, not print
- Include MARK comments for sections
- MoodEntry is an existing @Model class with: id (UUID),
  mood (MoodLevel enum), note (String), activities ([String]),
  date (Date), createdAt (Date)
```

### Review the output

Here is what Claude Code should generate. Read each file carefully — I will flag the things that matter.

**MoodRepository.swift** — the protocol.

```swift
import Foundation

protocol MoodRepository: Sendable {
    func fetchAll() async throws -> [MoodEntry]
    func fetch(by id: UUID) async throws -> MoodEntry?
    func save(_ entry: MoodEntry) async throws
    func update(_ entry: MoodEntry) async throws
    func delete(_ entry: MoodEntry) async throws
}
```

Review checklist:

- ✅ **`Sendable` conformance.** The protocol itself must be `Sendable` so it can be stored in `@Observable` ViewModels under Swift 6 strict concurrency. Without this, the compiler will reject any ViewModel that holds a `MoodRepository` reference.
- ✅ **`async throws` on every method.** Even though the SwiftData implementation is synchronous under the hood, marking these as `async throws` keeps the contract flexible. A future network-backed repository can conform without protocol changes.
- ✅ **No `@MainActor` on the protocol.** The abstraction should not force a specific actor. Only the concrete implementation decides its isolation.
- ⚠️ **Check the `save` vs `update` distinction.** Some AI outputs merge these into a single upsert. For Moodbit, keeping them separate is clearer — `save` inserts, `update` modifies an existing record. If the AI merged them, ask it to split.

**SwiftDataMoodRepository.swift** — the concrete implementation.

```swift
import Foundation
import SwiftData
import os

@MainActor
final class SwiftDataMoodRepository: MoodRepository {
    private let modelContext: ModelContext
    private let logger = Logger(
        subsystem: "com.nativefirst.moodbit",
        category: "SwiftDataMoodRepository"
    )

    nonisolated init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    // MARK: - Fetch

    func fetchAll() async throws -> [MoodEntry] {
        let descriptor = FetchDescriptor<MoodEntry>(
            sortBy: [SortDescriptor(\.date, order: .reverse)]
        )
        let entries = try modelContext.fetch(descriptor)
        logger.debug("Fetched \(entries.count) mood entries")
        return entries
    }

    func fetch(by id: UUID) async throws -> MoodEntry? {
        let predicate = #Predicate<MoodEntry> { $0.id == id }
        var descriptor = FetchDescriptor<MoodEntry>(predicate: predicate)
        descriptor.fetchLimit = 1
        return try modelContext.fetch(descriptor).first
    }

    // MARK: - Mutate

    func save(_ entry: MoodEntry) async throws {
        modelContext.insert(entry)
        try modelContext.save()
        logger.debug("Saved mood entry: \(entry.id)")
    }

    func update(_ entry: MoodEntry) async throws {
        try modelContext.save()
        logger.debug("Updated mood entry: \(entry.id)")
    }

    func delete(_ entry: MoodEntry) async throws {
        modelContext.delete(entry)
        try modelContext.save()
        logger.debug("Deleted mood entry: \(entry.id)")
    }
}
```

Review checklist:

- ✅ **`@MainActor` on the class.** `ModelContext` must be accessed on the main actor in Swift 6. This annotation makes that guarantee at compile time.
- ✅ **`nonisolated init`.** The initializer does not access actor-isolated state (it only assigns), so marking it `nonisolated` lets you create the repository from any context — including the app's `init()`.
- ✅ **`fetchLimit = 1` on single-fetch.** Small thing, big impact. Without the limit, SwiftData scans every record even though we only need one. For a mood journal this is negligible; for production patterns, it matters.
- ✅ **Explicit `try modelContext.save()` after every mutation.** SwiftData's autosave is convenient but unpredictable in timing. Explicit saves mean we know exactly when data hits disk.
- ⚠️ **Check that `update` does not re-insert.** A common AI mistake is calling `modelContext.insert(entry)` inside `update`. SwiftData tracks changes on `@Model` objects automatically — you only need to call `save()`. If the AI added an insert, remove it.

**RepositoryProvider.swift** — dependency injection.

```swift
import Foundation
import SwiftData

struct RepositoryProvider: Sendable {
    let moodRepository: MoodRepository

    // MARK: - Production

    @MainActor
    static func live(modelContext: ModelContext) -> RepositoryProvider {
        RepositoryProvider(
            moodRepository: SwiftDataMoodRepository(modelContext: modelContext)
        )
    }

    // MARK: - Preview & Test

    static var mock: RepositoryProvider {
        RepositoryProvider(
            moodRepository: MockMoodRepository()
        )
    }
}
```

Review checklist:

- ✅ **Struct, not class.** No shared mutable state. No accidental reference semantics.
- ✅ **`Sendable` conformance.** Required because this will live in the SwiftUI environment and get passed across actor boundaries.
- ✅ **Static factory methods.** `RepositoryProvider.live(modelContext:)` for production, `RepositoryProvider.mock` for previews and tests. Clear, discoverable, impossible to confuse.
- ❌ **Watch for singletons.** If the AI generates a `static let shared = ...`, reject it. The whole point is explicit injection. Singletons hide dependencies and make testing fragile.

**MockMoodRepository.swift** — for previews and tests.

```swift
import Foundation

final class MockMoodRepository: MoodRepository, @unchecked Sendable {
    var entries: [MoodEntry] = []

    // MARK: - Fetch

    func fetchAll() async throws -> [MoodEntry] {
        entries.sorted { $0.date > $1.date }
    }

    func fetch(by id: UUID) async throws -> MoodEntry? {
        entries.first { $0.id == id }
    }

    // MARK: - Mutate

    func save(_ entry: MoodEntry) async throws {
        entries.append(entry)
    }

    func update(_ entry: MoodEntry) async throws {
        guard let index = entries.firstIndex(where: { $0.id == entry.id }) else { return }
        entries[index] = entry
    }

    func delete(_ entry: MoodEntry) async throws {
        entries.removeAll { $0.id == entry.id }
    }
}
```

Review checklist:

- ✅ **In-memory array.** No persistence, no setup, instant. Perfect for previews that need sample data and tests that need deterministic behavior.
- ✅ **`@unchecked Sendable`.** The mock is only used in single-threaded test and preview contexts. Marking it `@unchecked Sendable` satisfies the protocol requirement without adding unnecessary synchronization.
- ⚠️ **Pre-populate for previews.** The mock is empty by default. For SwiftUI previews, you will want a convenience initializer or static factory that pre-fills sample mood entries. If the AI did not include one, we will add it in the iteration phase.

## Iteration

The generated code is solid but the mock needs sample data for previews. Send this follow-up:

```
Add a static property to MockMoodRepository called "withSampleData"
that returns a MockMoodRepository pre-populated with 5 sample
MoodEntry values spanning the last 7 days, covering different
MoodLevel values and activities. This is for SwiftUI previews.

Also show me how a ViewModel should use MoodRepository — create
a small example of MoodTimelineViewModel that depends on the
protocol, not the concrete type.
```

The AI should return something like this for the ViewModel usage:

```swift
import Foundation
import os

@Observable
@MainActor
final class MoodTimelineViewModel {
    private(set) var entries: [MoodEntry] = []
    private(set) var isLoading = false
    var errorMessage: String?

    private let repository: MoodRepository
    private let logger = Logger(
        subsystem: "com.nativefirst.moodbit",
        category: "MoodTimelineViewModel"
    )

    init(repository: MoodRepository) {
        self.repository = repository
    }

    // MARK: - Loading

    func loadEntries() async {
        isLoading = true
        defer { isLoading = false }

        do {
            entries = try await repository.fetchAll()
        } catch {
            logger.error("Failed to load entries: \(error.localizedDescription)")
            errorMessage = "Could not load your mood entries."
        }
    }

    // MARK: - Mutations

    func addEntry(_ entry: MoodEntry) async {
        do {
            try await repository.save(entry)
            entries.insert(entry, at: 0)
        } catch {
            logger.error("Failed to save entry: \(error.localizedDescription)")
            errorMessage = "Could not save your mood entry."
        }
    }

    func deleteEntry(_ entry: MoodEntry) async {
        do {
            try await repository.delete(entry)
            entries.removeAll { $0.id == entry.id }
        } catch {
            logger.error("Failed to delete entry: \(error.localizedDescription)")
            errorMessage = "Could not delete the entry."
        }
    }
}
```

Notice what the ViewModel does NOT know:

- It does not know about `ModelContext`.
- It does not know about SwiftData.
- It does not import any persistence framework.
- It depends on `MoodRepository` — a protocol with five methods.

This means you can test it with `MockMoodRepository`, preview it with sample data, and run it in production with `SwiftDataMoodRepository`. The ViewModel code is identical in all three scenarios.

## Verify Phase

Before moving on, verify these things manually. Do not skip this.

**1. Compile check.** Build the project. Swift 6 strict concurrency will catch any actor isolation mistakes. If the compiler complains about sending a non-Sendable type across actor boundaries, the fix is usually adding `@MainActor` to the call site or marking the type `Sendable`.

**2. Protocol conformance.** Make sure `SwiftDataMoodRepository` and `MockMoodRepository` both conform to `MoodRepository` without any warnings. If you see "non-sendable type ... cannot conform to Sendable protocol," double-check your `@unchecked Sendable` annotation on the mock.

**3. Preview test.** Create a quick preview that uses `MockMoodRepository.withSampleData` and verify the sample data renders in your timeline view. Previews should not require a `ModelContainer`.

**4. No direct `ModelContext` access outside the repository.** Search your project for `modelContext` — it should only appear inside `SwiftDataMoodRepository` and the app entry point. If any ViewModel imports SwiftData, something leaked.

**5. Error paths.** Temporarily throw an error from one of the mock methods. Verify that the ViewModel catches it and sets `errorMessage` instead of crashing.

## Final Code

Here is the complete, final implementation for all four files. This is the version that should be in your project after the plan, execute, and iterate phases.

### Repositories/MoodRepository.swift

```swift
import Foundation

/// Defines all data operations for mood entries.
/// Concrete implementations provide the persistence mechanism.
protocol MoodRepository: Sendable {
    func fetchAll() async throws -> [MoodEntry]
    func fetch(by id: UUID) async throws -> MoodEntry?
    func save(_ entry: MoodEntry) async throws
    func update(_ entry: MoodEntry) async throws
    func delete(_ entry: MoodEntry) async throws
}
```

### Repositories/SwiftDataMoodRepository.swift

```swift
import Foundation
import SwiftData
import os

@MainActor
final class SwiftDataMoodRepository: MoodRepository {
    private let modelContext: ModelContext
    private let logger = Logger(
        subsystem: "com.nativefirst.moodbit",
        category: "SwiftDataMoodRepository"
    )

    nonisolated init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    // MARK: - Fetch

    func fetchAll() async throws -> [MoodEntry] {
        let descriptor = FetchDescriptor<MoodEntry>(
            sortBy: [SortDescriptor(\.date, order: .reverse)]
        )
        let entries = try modelContext.fetch(descriptor)
        logger.debug("Fetched \(entries.count) mood entries")
        return entries
    }

    func fetch(by id: UUID) async throws -> MoodEntry? {
        let predicate = #Predicate<MoodEntry> { $0.id == id }
        var descriptor = FetchDescriptor<MoodEntry>(predicate: predicate)
        descriptor.fetchLimit = 1
        return try modelContext.fetch(descriptor).first
    }

    // MARK: - Mutate

    func save(_ entry: MoodEntry) async throws {
        modelContext.insert(entry)
        try modelContext.save()
        logger.debug("Saved mood entry: \(entry.id)")
    }

    func update(_ entry: MoodEntry) async throws {
        // SwiftData tracks changes on @Model objects automatically.
        // Calling save() persists any in-memory mutations.
        try modelContext.save()
        logger.debug("Updated mood entry: \(entry.id)")
    }

    func delete(_ entry: MoodEntry) async throws {
        modelContext.delete(entry)
        try modelContext.save()
        logger.debug("Deleted mood entry: \(entry.id)")
    }
}
```

### Repositories/RepositoryProvider.swift

```swift
import Foundation
import SwiftData

struct RepositoryProvider: Sendable {
    let moodRepository: MoodRepository

    // MARK: - Production

    @MainActor
    static func live(modelContext: ModelContext) -> RepositoryProvider {
        RepositoryProvider(
            moodRepository: SwiftDataMoodRepository(modelContext: modelContext)
        )
    }

    // MARK: - Preview & Test

    static var mock: RepositoryProvider {
        RepositoryProvider(
            moodRepository: MockMoodRepository.withSampleData
        )
    }
}
```

### Repositories/MockMoodRepository.swift

```swift
import Foundation

final class MockMoodRepository: MoodRepository, @unchecked Sendable {
    var entries: [MoodEntry] = []

    // MARK: - Fetch

    func fetchAll() async throws -> [MoodEntry] {
        entries.sorted { $0.date > $1.date }
    }

    func fetch(by id: UUID) async throws -> MoodEntry? {
        entries.first { $0.id == id }
    }

    // MARK: - Mutate

    func save(_ entry: MoodEntry) async throws {
        entries.append(entry)
    }

    func update(_ entry: MoodEntry) async throws {
        guard let index = entries.firstIndex(where: { $0.id == entry.id }) else {
            return
        }
        entries[index] = entry
    }

    func delete(_ entry: MoodEntry) async throws {
        entries.removeAll { $0.id == entry.id }
    }

    // MARK: - Sample Data

    static var withSampleData: MockMoodRepository {
        let mock = MockMoodRepository()
        let calendar = Calendar.current

        mock.entries = [
            MoodEntry(
                mood: .great,
                note: "Morning run in the park. Felt alive.",
                activities: ["Exercise", "Outdoors"],
                date: calendar.date(byAdding: .day, value: 0, to: .now)!
            ),
            MoodEntry(
                mood: .good,
                note: "Productive day at work.",
                activities: ["Work", "Coding"],
                date: calendar.date(byAdding: .day, value: -1, to: .now)!
            ),
            MoodEntry(
                mood: .okay,
                note: "Quiet afternoon. Read a few chapters.",
                activities: ["Reading"],
                date: calendar.date(byAdding: .day, value: -3, to: .now)!
            ),
            MoodEntry(
                mood: .bad,
                note: "Barely slept. Everything felt off.",
                activities: ["Poor Sleep"],
                date: calendar.date(byAdding: .day, value: -5, to: .now)!
            ),
            MoodEntry(
                mood: .great,
                note: "Dinner with friends. Laughed a lot.",
                activities: ["Social", "Food"],
                date: calendar.date(byAdding: .day, value: -6, to: .now)!
            ),
        ]

        return mock
    }
}
```

## Checkpoint

Before moving to the next lesson, verify every item:

- [ ] `MoodRepository` protocol exists with five `async throws` methods
- [ ] `SwiftDataMoodRepository` is annotated `@MainActor` and compiles under Swift 6 strict concurrency
- [ ] `RepositoryProvider` has `.live(modelContext:)` and `.mock` factory methods — no singletons
- [ ] `MockMoodRepository` has `.withSampleData` and your timeline preview renders without a `ModelContainer`
- [ ] No ViewModel imports `SwiftData` or references `ModelContext` directly
- [ ] The project builds with zero warnings

If any item fails, go back to the relevant section. Do not carry broken foundations into the next lesson.

## Challenge

**Add a filtered fetch method.**

Extend `MoodRepository` with a new method:

```swift
func fetchEntries(from startDate: Date, to endDate: Date) async throws -> [MoodEntry]
```

Implement it in both `SwiftDataMoodRepository` (using a `#Predicate` with date range) and `MockMoodRepository` (using `filter`). Then use it in a ViewModel to load only this week's entries.

**Hint:** In `SwiftDataMoodRepository`, your predicate will look like this:

```swift
let predicate = #Predicate<MoodEntry> {
    $0.date >= startDate && $0.date <= endDate
}
```

Make sure `startDate` and `endDate` are local variables the predicate can capture — `#Predicate` cannot reference `self` properties.
