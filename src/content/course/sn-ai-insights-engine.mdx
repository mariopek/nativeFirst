---
title: "AI Insights Engine"
description: "Build the intelligence layer that analyzes recovery patterns over time, generates personalized journal prompts, and creates weekly insight summaries using on-device ML with Apple's NaturalLanguage framework."
courseSlug: "ship-native"
module: 4
moduleTitle: "AI Integration"
lesson: 3
duration: "24 min read"
difficulty: "advanced"
topics: ["AI Insights", "Pattern Analysis", "Personalization", "On-Device ML", "Weekly Summary", "NaturalLanguage", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Up to this point, BetAway records recovery check-ins and lets users write journal entries. That is useful, but it is not intelligent. The app knows what the user felt — it does not know *why*, and it cannot tell the user anything they do not already know.

This lesson changes that. We are building the AI Insights Engine — the layer that looks at a user's recovery data over days and weeks, detects behavioral patterns, generates personalized journal prompts, and produces weekly summaries that help users understand their recovery trajectory. This is the feature that turns BetAway from a logging tool into something people open every morning.

We will use Apple's NaturalLanguage framework for all sentiment analysis — keeping everything on-device, private, and free. The Insights Engine aggregates recovery scores, identifies triggers, detects day-of-week patterns, and generates actionable insights entirely without a network connection.

## What You'll Learn

- How to build an `InsightsEngine` that aggregates recovery data across configurable time windows (7-day, 30-day)
- Pattern detection: recovery score trends over time, day-of-week patterns, and common trigger identification
- Generating personalized journal prompts based on a user's recent entries using on-device analysis
- Creating `RecoveryInsight` summaries on a weekly and monthly cadence
- Using Apple's NaturalLanguage framework for on-device sentiment scoring across the insights pipeline
- Building an `InsightsView` with cards for trends, suggestions, and weekly summaries
- Managing async insight generation through an `InsightsViewModel` with proper caching

## Why This Matters

Generic wellness apps give everyone the same advice. "Try meditating." "Drink more water." Users see through this in a week and stop opening the app. Personalized insights — "You tend to experience stronger urges on Fridays, especially when you mention financial stress" — are genuinely useful. They make the user feel understood, and they provide actionable self-awareness that generic tips never will.

For a gambling recovery app, this is especially critical. Understanding that urges peak on payday, or that anxiety spikes on specific days, gives the user concrete patterns to prepare for. That awareness is a core component of CBT-based recovery — which is exactly what BetAway delivers.

The technical challenge is real, though. You need to aggregate data over time, detect meaningful patterns, generate useful prompts, cache results so you are not running expensive computations on every screen load, and do all of this entirely on-device. This is the kind of feature where the architecture matters as much as the analysis.

## Plan Phase: Designing the Intelligence Layer

Open Claude Code in Plan mode. We need the AI to think through the data flow before writing anything:

```
I am building an AI Insights Engine for BetAway, our gambling
recovery app. Before writing code, help me plan the architecture.

Context:
- We have CheckIn objects with: recoveryScore (1-5 scale),
  journalText (optional String), triggers ([String]), date (Date)
- We use SwiftData for persistence
- We have an existing RecoveryService that uses Apple's
  NaturalLanguage framework for on-device sentiment analysis
- All analysis runs on-device — no cloud API calls
- We target iOS 17+, Swift 6 strict concurrency

The Insights Engine should:
1. Aggregate recovery data over time windows (7-day, 30-day)
2. Detect patterns: recovery score trends, day-of-week patterns,
   common triggers
3. Generate personalized journal prompts based on recent entries
4. Produce weekly RecoveryInsight summaries (title + body +
   suggestions)
5. Use NaturalLanguage framework for on-device sentiment analysis
   and pattern scoring
6. Cache generated insights to avoid redundant computation
7. All types @Sendable, all UI-facing code @MainActor

Think through:
- What are the core types (InsightsEngine, RecoveryInsight,
  RecoveryPattern, InsightCache)?
- How does the prompt generation work — what patterns inform the
  prompts?
- Where does NaturalLanguage fit in the pipeline?
- How do we avoid regenerating insights that are already cached?
- What is the failure strategy?

Do not generate code yet. Give me the plan.
```

### What the AI Plan Should Contain

A solid plan will include:

1. **Core types** — `InsightsEngine` as the orchestrator, `RecoveryInsight` as the output model, `RecoveryPattern` to hold detected patterns, and an `InsightCache` (or a caching layer inside the engine) that stores generated insights by date range.
2. **On-device analysis pipeline** — NaturalLanguage for instant sentiment scores and basic trend math (average recovery score by day of week, trigger frequency counts). Pattern-based prompt generation that selects relevant prompts based on detected triggers and trends.
3. **Prompt generation** — The engine analyzes recent recovery data to select personalized journal prompts. Instead of a cloud AI generating prompts, BetAway uses a curated prompt library filtered by the user's detected patterns and triggers.
4. **Caching strategy** — Insights keyed by `(timeWindow, generationDate)`. A weekly insight generated on Monday does not need regenerating until the following Monday.
5. **Reliability** — Since everything runs on-device, there is no network failure path. The only failure case is insufficient data (too few check-ins to detect patterns).

### Anti-Pattern: One-Size-Fits-All Insights

Here is the mistake most developers make:

```
Generate a motivational quote for the user based on their recovery score.
```

This produces generic output that has nothing to do with the user's actual data. "Stay strong!" when someone has logged five anxious days in a row is not just unhelpful — it feels dismissive. The fix is analyzing real, aggregated data to surface patterns. The insights engine cannot personalize what it cannot see.

The second anti-pattern is **never caching generated insights**. Every time the user opens the Insights tab, you run the full analysis pipeline. This adds latency on every view appearance and produces slightly different text each time — which feels inconsistent and unreliable. Cache aggressively.

## Execute Phase: Implementation

Switch to Execute mode. Here is the prompt:

```
Build the BetAway Insights Engine. Generate three files with full
Swift 6 strict concurrency compliance:

1. InsightsEngine.swift — the analysis + generation layer
   - Takes a RecoveryService (for sentiment analysis) and a data
     source (to fetch CheckIn data)
   - Method: analyzePeriod(_ window: TimeWindow) async throws
     -> RecoveryInsight
   - Method: generateJournalPrompt(recentEntries: [CheckIn])
     async throws -> String
   - TimeWindow enum: .week, .month
   - Uses NaturalLanguage for sentiment scoring of journal text
   - Generates insights from aggregated pattern data
   - Caches insights in a dictionary keyed by TimeWindow + Date
   - RecoveryInsight model: id, title, body, suggestions [String],
     recoveryTrend (up/down/stable), generatedAt Date
   - RecoveryPattern model: averageScore Double, dayOfWeekScores
     [String: Double], topTriggers [String], trendDirection
   - Mark @Sendable where needed, use os.Logger

2. InsightsViewModel.swift — @MainActor @Observable
   - Properties: weeklyInsight (RecoveryInsight?), monthlyInsight
     (RecoveryInsight?), journalPrompt (String?), isLoading, error
   - Methods: loadInsights() async, refreshInsights() async,
     generatePrompt() async
   - Uses InsightsEngine under the hood
   - Handles loading/error states cleanly

3. InsightsView.swift — SwiftUI view
   - Shows insight cards: weekly summary, monthly summary
   - Each card displays title, body text, trend indicator
     (arrow up/down/stable), and suggestion chips
   - A "Journal Prompt" section with a generated prompt and
     a refresh button
   - Loading and empty states
   - Pull-to-refresh
   - #Preview

Use os.Logger everywhere. Zero print(). No singletons.
No ObservableObject/@Published. @Observable only.
```

### Reviewing the AI Output

When the code comes back, here is your checklist:

**InsightsEngine.swift:**

- ✅ `InsightsEngine` is a `final class` (or `actor`) with an `init` that takes protocol-based dependencies
- ✅ `RecoveryInsight` is a simple value type (struct) conforming to `Identifiable` and `Sendable`
- ✅ `RecoveryPattern` is a struct with `averageScore`, `dayOfWeekScores`, `topTriggers`, `trendDirection`
- ✅ `TimeWindow` enum is `Hashable` and `Sendable`
- ✅ NaturalLanguage is imported and used for `NLTagger` sentiment scoring
- ✅ Journal prompts are generated based on detected patterns, not generic templates
- ✅ The cache dictionary prevents redundant computation for the same time window
- ⚠️ If the cache has no expiration logic — note it for iteration. A cache that never invalidates will serve stale insights forever
- ❌ If it uses `print()` anywhere — reject
- ❌ If it tries to call any cloud API — reject. All analysis must be on-device
- ❌ If `RecoveryInsight` is a class instead of a struct — reject

**InsightsViewModel.swift:**

- ✅ `@MainActor` and `@Observable`
- ✅ Calls `InsightsEngine` methods in async contexts
- ✅ Sets `isLoading` before and after every async operation
- ✅ Catches errors and stores a user-friendly message
- ❌ If it creates its own `InsightsEngine` internally with hardcoded dependencies — reject. Dependencies should be injected via `init`
- ❌ If it uses `Task.detached` without a good reason — reject

**InsightsView.swift:**

- ✅ Uses `@State` with the ViewModel (not `@StateObject`)
- ✅ Cards use `.background(.ultraThinMaterial)` or similar for visual separation
- ✅ Shows a `ProgressView` during loading
- ✅ Shows `ContentUnavailableView` when no insights exist yet
- ✅ Includes `.refreshable { }` for pull-to-refresh
- ❌ If it puts business logic in the View — reject. All logic belongs in the ViewModel or Engine

## Iteration

After reviewing, send this follow-up:

```
Good structure. Make these adjustments:

1. In InsightsEngine, add a cache expiration check — if the cached
   insight's generatedAt is older than the time window (7 days for
   weekly, 30 for monthly), invalidate it and regenerate
2. All analysis must be on-device using NaturalLanguage sentiment
   scores and pattern detection — no cloud API calls
3. Journal prompts should be selected from a curated library
   based on detected patterns and triggers, not randomly generated
4. Add a RecoveryTrend enum (.improving, .declining, .stable) to
   RecoveryInsight instead of a raw string
5. In InsightsView, add a subtle animation when insight cards
   appear (opacity + offset transition)
6. Add doc comments to all public methods

Zero warnings. Swift 6 strict concurrency.
```

This iteration tightens the three things that matter most: privacy (all on-device), resilience (no network dependency), and polish (animations, cache expiry).

## Verify Phase

Before moving on, confirm every item:

**In Xcode:**
1. Build with `Cmd+B` — zero errors, zero warnings
2. Run the app — navigate to the Insights tab without crashing
3. Verify a weekly insight generates and displays from on-device analysis
4. Test in airplane mode — verify everything still works (it should, since there are no network calls)
5. Open Insights again after it has already generated — verify the cached result loads instantly (no loading spinner)

**In the code:**
1. Grep for `print(` — zero matches
2. Grep for `ObservableObject`, `@Published`, `@StateObject` — zero matches
3. Grep for `static let shared` — zero matches
4. Confirm there are no cloud API calls anywhere in the insights pipeline — all analysis is on-device
5. Confirm the cache expiry logic works: a weekly insight older than 7 days triggers regeneration
6. Confirm `RecoveryInsight` and `RecoveryPattern` are structs, not classes
7. Confirm `InsightsViewModel` receives its dependencies via `init`, not by creating them internally

**Edge cases to test:**
1. User with zero check-ins — should show a "Log some check-ins first" empty state, not crash
2. User with check-ins but no journal text — insights should still generate from recovery scores and triggers alone
3. Insufficient data for pattern detection — the engine should handle this gracefully with a "Keep logging to unlock insights" message

## Final Code

Here are the complete, compilable files.

### InsightsEngine.swift

```swift
import Foundation
import NaturalLanguage
import os

// MARK: - Models

/// Represents a time window for insight aggregation.
enum TimeWindow: String, Hashable, Sendable {
    case week
    case month

    var days: Int {
        switch self {
        case .week: 7
        case .month: 30
        }
    }
}

/// The trend direction of a user's recovery over a time period.
enum RecoveryTrend: String, Sendable, Codable {
    case improving
    case declining
    case stable
}

/// A generated insight for a specific time period.
struct RecoveryInsight: Identifiable, Sendable {
    let id: UUID
    let title: String
    let body: String
    let suggestions: [String]
    let recoveryTrend: RecoveryTrend
    let generatedAt: Date

    init(
        id: UUID = UUID(),
        title: String,
        body: String,
        suggestions: [String],
        recoveryTrend: RecoveryTrend,
        generatedAt: Date = .now
    ) {
        self.id = id
        self.title = title
        self.body = body
        self.suggestions = suggestions
        self.recoveryTrend = recoveryTrend
        self.generatedAt = generatedAt
    }
}

/// Detected recovery patterns over a time period.
struct RecoveryPattern: Sendable {
    let averageScore: Double
    let dayOfWeekScores: [String: Double]
    let topTriggers: [String]
    let trendDirection: RecoveryTrend
    let sentimentScores: [Double]
}

// MARK: - Cache Key

private struct InsightCacheKey: Hashable {
    let window: TimeWindow
    let anchorDate: String // formatted as yyyy-MM-dd
}

// MARK: - Insights Engine

/// Orchestrates recovery pattern analysis using on-device NaturalLanguage
/// for sentiment scoring and pattern detection. No cloud API calls.
final class InsightsEngine: Sendable {
    private let recoveryService: RecoveryServiceProtocol
    private let repository: CheckInRepositoryProtocol
    private let logger = Logger(
        subsystem: "com.nativefirst.betaway",
        category: "InsightsEngine"
    )

    /// In-memory cache of generated insights, keyed by window + date.
    private let cache = NSCache<NSString, CacheEntry>()

    init(
        recoveryService: RecoveryServiceProtocol,
        repository: CheckInRepositoryProtocol
    ) {
        self.recoveryService = recoveryService
        self.repository = repository
    }

    // MARK: - Public API

    /// Analyzes check-in entries within the given time window and generates
    /// a personalized recovery insight. Returns a cached result if still valid.
    func analyzePeriod(_ window: TimeWindow) async throws -> RecoveryInsight {
        let cacheKey = makeCacheKey(window: window)

        if let cached = cache.object(forKey: cacheKey as NSString),
           !isExpired(cached, window: window) {
            logger.debug("Returning cached insight for \(window.rawValue).")
            return cached.insight
        }

        let entries = try await repository.fetchEntries(
            from: Calendar.current.date(
                byAdding: .day, value: -window.days, to: .now
            ) ?? .now,
            to: .now
        )

        guard !entries.isEmpty else {
            logger.info("No entries for \(window.rawValue) window.")
            throw InsightsError.insufficientData
        }

        let pattern = analyzePattern(entries)
        let insight = generateInsight(pattern: pattern, window: window)
        cacheInsight(insight, key: cacheKey)
        return insight
    }

    /// Generates a personalized journal prompt based on recent check-in
    /// entries. Uses detected patterns and triggers to select relevant prompts.
    func generateJournalPrompt(
        recentEntries: [CheckIn]
    ) async throws -> String {
        guard !recentEntries.isEmpty else {
            throw InsightsError.insufficientData
        }

        let pattern = analyzePattern(recentEntries)
        return selectPrompt(for: pattern)
    }

    // MARK: - Pattern Analysis (On-Device)

    /// Analyzes check-in entries to detect recovery patterns entirely on-device.
    private func analyzePattern(_ entries: [CheckIn]) -> RecoveryPattern {
        let scores = entries.map { Double($0.recoveryScore) }
        let average = scores.reduce(0, +) / Double(scores.count)

        // Day-of-week breakdown
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE"
        var dayTotals: [String: (sum: Double, count: Int)] = [:]
        for entry in entries {
            let day = formatter.string(from: entry.date)
            let existing = dayTotals[day] ?? (0, 0)
            dayTotals[day] = (existing.sum + Double(entry.recoveryScore), existing.count + 1)
        }
        let dayScores = dayTotals.mapValues { $0.sum / Double($0.count) }

        // Trigger frequency
        var triggerCounts: [String: Int] = [:]
        for entry in entries {
            for trigger in entry.triggers {
                triggerCounts[trigger, default: 0] += 1
            }
        }
        let topTriggers = triggerCounts
            .sorted { $0.value > $1.value }
            .prefix(5)
            .map(\.key)

        // Trend direction: compare first half average to second half
        let midpoint = scores.count / 2
        let firstHalf = Array(scores.prefix(midpoint))
        let secondHalf = Array(scores.suffix(from: midpoint))
        let firstAvg = firstHalf.isEmpty ? average
            : firstHalf.reduce(0, +) / Double(firstHalf.count)
        let secondAvg = secondHalf.isEmpty ? average
            : secondHalf.reduce(0, +) / Double(secondHalf.count)

        let trend: RecoveryTrend
        let delta = secondAvg - firstAvg
        if delta > 0.3 {
            trend = .improving
        } else if delta < -0.3 {
            trend = .declining
        } else {
            trend = .stable
        }

        // Sentiment scores from journal text
        let sentiments = entries.map { scoreSentiment($0.journalText ?? "") }

        return RecoveryPattern(
            averageScore: average,
            dayOfWeekScores: dayScores,
            topTriggers: topTriggers,
            trendDirection: trend,
            sentimentScores: sentiments
        )
    }

    // MARK: - Insight Generation (On-Device)

    /// Generates a recovery insight entirely on-device using pattern data.
    /// No cloud API calls — all analysis is local.
    private func generateInsight(
        pattern: RecoveryPattern,
        window: TimeWindow
    ) -> RecoveryInsight {
        let trendText: String
        switch pattern.trendDirection {
        case .improving:
            trendText = "Your recovery has been trending upward"
        case .declining:
            trendText = "Your recovery scores have been trending downward"
        case .stable:
            trendText = "Your recovery has been relatively stable"
        }

        let triggerText = pattern.topTriggers.isEmpty
            ? ""
            : " Your most common triggers were \(pattern.topTriggers.prefix(3).joined(separator: ", "))."

        let bestDay = pattern.dayOfWeekScores
            .max(by: { $0.value < $1.value })?.key ?? "unknown"
        let worstDay = pattern.dayOfWeekScores
            .min(by: { $0.value < $1.value })?.key ?? "unknown"

        let body = "\(trendText) over the past \(window.days) days, "
            + "with an average recovery score of \(String(format: "%.1f", pattern.averageScore))/5. "
            + "You tend to feel strongest on \(bestDay)s and face the most difficulty on \(worstDay)s."
            + triggerText

        let suggestions: [String]
        switch pattern.trendDirection {
        case .improving:
            suggestions = [
                "Keep doing what is working — consistency matters in recovery",
                "Note what changed recently that might be helping",
                "Consider journaling about your wins this week"
            ]
        case .declining:
            suggestions = [
                "Try the guided breathing exercise before high-risk moments",
                "Reach out to someone you trust this week",
                "Review your \(worstDay) routine for patterns to change"
            ]
        case .stable:
            suggestions = [
                "Stability is a strength — acknowledge it",
                "Experiment with one new coping strategy this week",
                "Reflect on what keeps your recovery on track"
            ]
        }

        // Generate a concise title from the trend
        let title: String
        switch pattern.trendDirection {
        case .improving:
            title = "Recovery Momentum Building"
        case .declining:
            title = "Time to Regroup and Refocus"
        case .stable:
            title = "Holding Steady on Your Path"
        }

        logger.info("Generated on-device insight for \(window.rawValue).")

        return RecoveryInsight(
            title: title,
            body: body,
            suggestions: suggestions,
            recoveryTrend: pattern.trendDirection
        )
    }

    // MARK: - Journal Prompt Selection

    /// Selects a personalized journal prompt based on detected patterns.
    /// Uses a curated library of recovery-focused prompts filtered by
    /// the user's triggers and trend direction.
    private func selectPrompt(for pattern: RecoveryPattern) -> String {
        // Trigger-specific prompts
        if pattern.topTriggers.contains(where: { $0.lowercased().contains("financial") || $0.lowercased().contains("money") }) {
            return "What is one small step you could take this week toward financial recovery? It does not have to be big — even reviewing one statement counts."
        }

        if pattern.topTriggers.contains(where: { $0.lowercased().contains("stress") || $0.lowercased().contains("anxiety") }) {
            return "When you feel stress building, what has worked to redirect your attention? Write about a time you successfully managed an urge."
        }

        if pattern.topTriggers.contains(where: { $0.lowercased().contains("boredom") || $0.lowercased().contains("lonely") }) {
            return "What activities genuinely engage you and fill the time that gambling used to occupy? List three you could try this week."
        }

        // Trend-based prompts
        switch pattern.trendDirection {
        case .improving:
            return "Your recovery scores have been improving. What do you think is driving that progress? Writing it down helps you repeat it."
        case .declining:
            return "Recovery has ups and downs. What is one thing weighing on you right now that you have not said out loud yet?"
        case .stable:
            return "Steady days matter. What is one thing about your current routine that supports your recovery?"
        }
    }

    // MARK: - NaturalLanguage Sentiment

    /// Scores the sentiment of a text string using Apple's NLTagger.
    /// Returns a value between -1.0 (very negative) and 1.0 (very positive).
    private func scoreSentiment(_ text: String) -> Double {
        guard !text.isEmpty else { return 0.0 }

        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text

        let (tag, _) = tagger.tag(
            at: text.startIndex,
            unit: .paragraph,
            scheme: .sentimentScore
        )

        return Double(tag?.rawValue ?? "0") ?? 0.0
    }

    // MARK: - Helpers

    private func averageSentiment(_ scores: [Double]) -> Double {
        guard !scores.isEmpty else { return 0.0 }
        return scores.reduce(0, +) / Double(scores.count)
    }

    private func formatted(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter.string(from: date)
    }

    private func makeCacheKey(window: TimeWindow) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return "\(window.rawValue)_\(formatter.string(from: .now))"
    }

    private func isExpired(_ entry: CacheEntry, window: TimeWindow) -> Bool {
        let age = Date.now.timeIntervalSince(entry.insight.generatedAt)
        let maxAge = TimeInterval(window.days * 24 * 60 * 60)
        return age > maxAge
    }

    private func cacheInsight(_ insight: RecoveryInsight, key: String) {
        cache.setObject(CacheEntry(insight: insight), forKey: key as NSString)
    }
}

// MARK: - Cache Entry Wrapper

private final class CacheEntry: NSObject {
    let insight: RecoveryInsight

    init(insight: RecoveryInsight) {
        self.insight = insight
    }
}

// MARK: - Errors

enum InsightsError: LocalizedError {
    case insufficientData
    case generationFailed(String)

    var errorDescription: String? {
        switch self {
        case .insufficientData:
            return "Not enough check-ins to generate insights. Keep logging your recovery."
        case .generationFailed(let reason):
            return "Insight generation failed: \(reason)"
        }
    }
}
```

### InsightsViewModel.swift

```swift
import Foundation
import os

/// Manages insight state for the InsightsView, coordinating between
/// the InsightsEngine and the UI layer.
@MainActor
@Observable
final class InsightsViewModel {
    var weeklyInsight: RecoveryInsight?
    var monthlyInsight: RecoveryInsight?
    var journalPrompt: String?
    var isLoading = false
    var errorMessage: String?
    var showError = false

    private let engine: InsightsEngine
    private let repository: CheckInRepositoryProtocol
    private let logger = Logger(
        subsystem: "com.nativefirst.betaway",
        category: "InsightsViewModel"
    )

    init(engine: InsightsEngine, repository: CheckInRepositoryProtocol) {
        self.engine = engine
        self.repository = repository
    }

    /// Loads both weekly and monthly insights. Uses cached results
    /// when available, fetches fresh ones when expired.
    func loadInsights() async {
        isLoading = true
        errorMessage = nil

        await withTaskGroup(of: Void.self) { group in
            group.addTask { await self.loadWeeklyInsight() }
            group.addTask { await self.loadMonthlyInsight() }
        }

        isLoading = false
    }

    /// Forces a full refresh, bypassing the cache.
    func refreshInsights() async {
        isLoading = true
        errorMessage = nil
        weeklyInsight = nil
        monthlyInsight = nil
        journalPrompt = nil

        await loadInsights()
        await generatePrompt()
    }

    /// Generates a personalized journal prompt from the user's
    /// five most recent check-in entries.
    func generatePrompt() async {
        do {
            let recent = try await repository.fetchEntries(
                from: Calendar.current.date(
                    byAdding: .day, value: -7, to: .now
                ) ?? .now,
                to: .now
            )

            guard !recent.isEmpty else {
                journalPrompt = "Start by logging today's recovery check-in — your first insight begins with your first entry."
                return
            }

            journalPrompt = try await engine.generateJournalPrompt(
                recentEntries: Array(recent.prefix(5))
            )
            logger.debug("Journal prompt generated successfully.")
        } catch {
            logger.warning("Prompt generation failed: \(error.localizedDescription)")
            journalPrompt = "What is one thing that affected your recovery today?"
        }
    }

    // MARK: - Private

    private func loadWeeklyInsight() async {
        do {
            weeklyInsight = try await engine.analyzePeriod(.week)
        } catch let error as InsightsError where error == .insufficientData {
            logger.info("Not enough data for weekly insight.")
        } catch {
            logger.error("Weekly insight error: \(error.localizedDescription)")
            errorMessage = error.localizedDescription
            showError = true
        }
    }

    private func loadMonthlyInsight() async {
        do {
            monthlyInsight = try await engine.analyzePeriod(.month)
        } catch let error as InsightsError where error == .insufficientData {
            logger.info("Not enough data for monthly insight.")
        } catch {
            logger.error("Monthly insight error: \(error.localizedDescription)")
            if errorMessage == nil {
                errorMessage = error.localizedDescription
                showError = true
            }
        }
    }
}

// MARK: - InsightsError Equatable (for pattern matching)

extension InsightsError: Equatable {
    static func == (lhs: InsightsError, rhs: InsightsError) -> Bool {
        switch (lhs, rhs) {
        case (.insufficientData, .insufficientData):
            return true
        case (.generationFailed(let a), .generationFailed(let b)):
            return a == b
        default:
            return false
        }
    }
}
```

### InsightsView.swift

```swift
import SwiftUI

struct InsightsView: View {
    @State private var viewModel: InsightsViewModel

    init(engine: InsightsEngine, repository: CheckInRepositoryProtocol) {
        self._viewModel = State(
            initialValue: InsightsViewModel(
                engine: engine,
                repository: repository
            )
        )
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                if viewModel.isLoading && viewModel.weeklyInsight == nil {
                    loadingState
                } else if viewModel.weeklyInsight == nil
                            && viewModel.monthlyInsight == nil
                            && viewModel.journalPrompt == nil {
                    emptyState
                } else {
                    insightContent
                }
            }
            .navigationTitle("Recovery Insights")
            .refreshable {
                await viewModel.refreshInsights()
            }
            .task {
                await viewModel.loadInsights()
                await viewModel.generatePrompt()
            }
            .alert("Error", isPresented: $viewModel.showError) {
                Button("OK", role: .cancel) {}
            } message: {
                Text(viewModel.errorMessage ?? "Something went wrong.")
            }
        }
    }

    // MARK: - Content

    private var insightContent: some View {
        LazyVStack(spacing: 16) {
            // Journal Prompt
            if let prompt = viewModel.journalPrompt {
                promptCard(prompt)
                    .transition(.move(edge: .top).combined(with: .opacity))
            }

            // Weekly Insight
            if let weekly = viewModel.weeklyInsight {
                insightCard(weekly, label: "This Week")
                    .transition(.move(edge: .bottom).combined(with: .opacity))
            }

            // Monthly Insight
            if let monthly = viewModel.monthlyInsight {
                insightCard(monthly, label: "This Month")
                    .transition(.move(edge: .bottom).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.easeInOut(duration: 0.3), value: viewModel.weeklyInsight?.id)
        .animation(.easeInOut(duration: 0.3), value: viewModel.monthlyInsight?.id)
    }

    // MARK: - Insight Card

    private func insightCard(_ insight: RecoveryInsight, label: String) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(label)
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundStyle(.secondary)
                    .textCase(.uppercase)

                Spacer()

                trendBadge(insight.recoveryTrend)
            }

            Text(insight.title)
                .font(.title3)
                .fontWeight(.bold)

            Text(insight.body)
                .font(.body)
                .foregroundStyle(.secondary)
                .fixedSize(horizontal: false, vertical: true)

            if !insight.suggestions.isEmpty {
                Divider()

                VStack(alignment: .leading, spacing: 8) {
                    Text("Suggestions")
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundStyle(.secondary)

                    FlowLayout(spacing: 8) {
                        ForEach(insight.suggestions, id: \.self) { suggestion in
                            Text(suggestion)
                                .font(.caption)
                                .padding(.horizontal, 10)
                                .padding(.vertical, 6)
                                .background(.blue.opacity(0.1), in: Capsule())
                                .foregroundStyle(.blue)
                        }
                    }
                }
            }
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
    }

    // MARK: - Journal Prompt Card

    private func promptCard(_ prompt: String) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Label("Journal Prompt", systemImage: "pencil.and.outline")
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundStyle(.secondary)
                    .textCase(.uppercase)

                Spacer()

                Button {
                    Task { await viewModel.generatePrompt() }
                } label: {
                    Image(systemName: "arrow.clockwise")
                        .font(.caption)
                        .foregroundStyle(.blue)
                }
            }

            Text(prompt)
                .font(.body)
                .italic()
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            .orange.opacity(0.08),
            in: RoundedRectangle(cornerRadius: 16)
        )
    }

    // MARK: - Trend Badge

    private func trendBadge(_ trend: RecoveryTrend) -> some View {
        HStack(spacing: 4) {
            Image(systemName: trendIcon(trend))
                .font(.caption2)
            Text(trend.rawValue.capitalized)
                .font(.caption2)
                .fontWeight(.medium)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(trendColor(trend).opacity(0.15), in: Capsule())
        .foregroundStyle(trendColor(trend))
    }

    private func trendIcon(_ trend: RecoveryTrend) -> String {
        switch trend {
        case .improving: "arrow.up.right"
        case .declining: "arrow.down.right"
        case .stable: "arrow.right"
        }
    }

    private func trendColor(_ trend: RecoveryTrend) -> Color {
        switch trend {
        case .improving: .green
        case .declining: .red
        case .stable: .blue
        }
    }

    // MARK: - States

    private var loadingState: some View {
        VStack(spacing: 16) {
            Spacer()
            ProgressView("Analyzing your recovery patterns...")
                .font(.subheadline)
            Spacer()
        }
        .frame(maxWidth: .infinity, minHeight: 300)
    }

    private var emptyState: some View {
        ContentUnavailableView(
            "No Insights Yet",
            systemImage: "chart.line.uptrend.xyaxis",
            description: Text(
                "Log a few days of recovery check-ins and BetAway will start "
                + "spotting patterns and generating personalized insights for you."
            )
        )
    }
}

// MARK: - FlowLayout (iOS 16+ compatible tag layout)

struct FlowLayout: Layout {
    var spacing: CGFloat = 8

    func sizeThatFits(
        proposal: ProposedViewSize,
        subviews: Subviews,
        cache: inout ()
    ) -> CGSize {
        let result = arrange(
            proposal: proposal,
            subviews: subviews
        )
        return result.size
    }

    func placeSubviews(
        in bounds: CGRect,
        proposal: ProposedViewSize,
        subviews: Subviews,
        cache: inout ()
    ) {
        let result = arrange(
            proposal: proposal,
            subviews: subviews
        )
        for (index, position) in result.positions.enumerated() {
            subviews[index].place(
                at: CGPoint(
                    x: bounds.minX + position.x,
                    y: bounds.minY + position.y
                ),
                proposal: .unspecified
            )
        }
    }

    private func arrange(
        proposal: ProposedViewSize,
        subviews: Subviews
    ) -> (positions: [CGPoint], size: CGSize) {
        let maxWidth = proposal.width ?? .infinity
        var positions: [CGPoint] = []
        var x: CGFloat = 0
        var y: CGFloat = 0
        var rowHeight: CGFloat = 0

        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)

            if x + size.width > maxWidth, x > 0 {
                x = 0
                y += rowHeight + spacing
                rowHeight = 0
            }

            positions.append(CGPoint(x: x, y: y))
            rowHeight = max(rowHeight, size.height)
            x += size.width + spacing
        }

        return (
            positions,
            CGSize(width: maxWidth, height: y + rowHeight)
        )
    }
}

#Preview {
    // In a real app, these would be injected from the app root.
    // For preview, you would use mock implementations.
    InsightsView(
        engine: InsightsEngine(
            recoveryService: MockRecoveryService(),
            repository: MockCheckInRepository()
        ),
        repository: MockCheckInRepository()
    )
}
```

### Key Design Decisions

**Why NSCache instead of a plain dictionary?** `NSCache` is thread-safe without explicit locking, automatically evicts entries under memory pressure, and works correctly across `Sendable` boundaries. A plain `[String: RecoveryInsight]` dictionary inside a `Sendable` class would require a lock or an actor — `NSCache` gives us safe caching with less boilerplate.

**Why entirely on-device?** BetAway is a gambling recovery app. The journal entries users write contain deeply sensitive information — financial losses, relationship damage, moments of weakness. Sending any of this to a cloud service, even in aggregated form, violates the trust the app needs to build with its users. On-device analysis with NaturalLanguage means the data physically cannot leave the phone. This is not a privacy policy — it is a technical guarantee.

**Why pattern-based prompts instead of AI-generated ones?** A curated prompt library filtered by detected patterns gives consistent, recovery-appropriate prompts without any network dependency. The prompts are written by someone who understands gambling recovery, not generated by a model that might produce something tone-deaf. Each prompt connects to a specific detected pattern (financial stress triggers, boredom triggers, declining trends), making them feel personalized even though they are template-based.

**Why `withTaskGroup` in the ViewModel?** Weekly and monthly insights are independent. Fetching them concurrently with a task group means the user waits for the slower of the two, not the sum of both. Small optimization, noticeable improvement.

**Why `FlowLayout` for suggestion chips?** Suggestions vary in length. A simple `HStack` would clip or overflow. `FlowLayout` wraps chips onto new lines automatically, and it is a reusable component for anywhere you need tag-style layouts in the app.

## Checkpoint

Before moving to the next lesson, confirm every item:

- [ ] Project builds with zero errors and zero warnings under Swift 6 strict concurrency
- [ ] `InsightsEngine` accepts dependencies via `init` — no singletons, no hardcoded services
- [ ] `RecoveryInsight` and `RecoveryPattern` are structs conforming to `Sendable`
- [ ] `NLTagger` sentiment scoring works for empty strings (returns 0.0, does not crash)
- [ ] All analysis runs on-device — no cloud API calls anywhere in the insights pipeline
- [ ] Cache returns a stored insight on second call without re-running the analysis
- [ ] Cache expires after the time window (7 days for weekly, 30 for monthly)
- [ ] `InsightsView` shows `ContentUnavailableView` when there are zero entries
- [ ] Pull-to-refresh triggers `refreshInsights()` and updates the UI
- [ ] Insight cards animate in with opacity + offset transitions
- [ ] `FlowLayout` wraps suggestion chips correctly on narrow screens
- [ ] No `print()` statements — only `os.Logger`
- [ ] No `ObservableObject`, `@Published`, or `@StateObject` anywhere

## Challenge

**Add day-of-week visualization to the weekly insight card.**

The `RecoveryPattern` already contains `dayOfWeekScores` — a dictionary mapping day names to average recovery scores. Your task:

1. Create a `WeekRecoveryChart` view that displays a simple bar chart of the seven days
2. Each bar's height represents the average recovery score for that day (scaled 1-5)
3. Color the bars: green for 4+, orange for 3-4, red for below 3
4. Show the day abbreviation (Mon, Tue, ...) below each bar
5. Embed the chart inside the weekly insight card, between the body text and the suggestions

Use only SwiftUI — no Charts framework dependency. A simple `VStack` + `RoundedRectangle` with a calculated frame height is all you need.

<details>
<summary>Hint</summary>

You already have the data in `RecoveryPattern.dayOfWeekScores`. Pass it to your chart view, sort the days in calendar order, and compute each bar's height as a fraction of the maximum:

```swift
struct WeekRecoveryChart: View {
    let scores: [String: Double]

    private let dayOrder = [
        "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday", "Sunday"
    ]

    var body: some View {
        HStack(alignment: .bottom, spacing: 8) {
            ForEach(dayOrder, id: \.self) { day in
                let score = scores[day] ?? 0
                VStack(spacing: 4) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(barColor(score))
                        .frame(width: 28, height: CGFloat(score / 5.0) * 80)
                    Text(String(day.prefix(3)))
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                }
            }
        }
        .frame(height: 100)
    }

    private func barColor(_ score: Double) -> Color {
        if score >= 4 { return .green }
        if score >= 3 { return .orange }
        return .red
    }
}
```

To get the data into the view, you will need to expose `RecoveryPattern` from the engine or add a `dayOfWeekScores` property to `RecoveryInsight`. The cleaner approach is adding it to `RecoveryInsight` so the view layer never touches the engine directly.
</details>

---

Next up: **Lesson 4.4 — On-Device ML with Core ML**, where we train a custom recovery prediction model using Create ML and integrate it into BetAway for offline, real-time recovery score suggestions.
