---
title: "OpenAI API Integration"
description: "Learn production-quality cloud API integration patterns â€” secure Keychain storage, async/await networking, typed errors, retry logic â€” and understand why BetAway deliberately rejects cloud AI in favor of privacy-first manual mood tracking."
courseSlug: "ship-native"
module: 4
moduleTitle: "AI Integration"
lesson: 1
duration: "26 min read"
difficulty: "intermediate"
topics: ["OpenAI API", "Networking", "Keychain", "async/await", "Error Handling", "Retry Logic", "API Security", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

BetAway has a data layer, a UI, and a persistence strategy. Users can log recovery check-ins, write journal entries, and track urge patterns on a timeline. It works â€” but every feature so far relies on the user self-reporting their emotional state. There is no automated analysis.

Most AI-powered apps would reach for a cloud API at this point â€” send journal text to GPT, get a sentiment score back, display an insight card. That is a valid approach for many products, but BetAway takes a different path. As a gambling recovery app, privacy is non-negotiable. Users are journaling about deeply personal struggles, financial damage, and emotional triggers. The real BetAway app handles mood tracking through a simple, deliberate design: the user picks their own mood rating from a 1-5 scale when they write a journal entry or complete a check-in. No text ever leaves the device. No text is ever analyzed by an algorithm. The user is the authority on their own emotional state.

That said, understanding how cloud API integration works is a critical skill for any iOS developer. You will encounter projects that require it. So this lesson teaches both: we walk through a production-quality OpenAI integration pattern â€” the networking layer, Keychain storage, retry logic, error handling â€” and then examine why BetAway deliberately chooses a simpler, privacy-first alternative. Learn the cloud pattern. Understand when to reject it.

## What You'll Learn

- Build an `OpenAIService` that calls the Chat Completion endpoint using async/await and URLSession
- Store the API key securely in the iOS Keychain â€” never in UserDefaults, never hardcoded
- Define structured Codable request and response models that match the OpenAI API exactly
- Implement typed error handling with Swift 6 typed throws and automatic retry with exponential backoff
- Understand why BetAway uses manual mood tracking instead, and when each approach is appropriate

## Why This Matters

Every AI-powered feature in a production app depends on one of two foundations: a secure, resilient networking layer for cloud AI, or a local approach (manual or on-device ML). If you hardcode your API key, it gets scraped from your binary within days. If you skip retry logic, users on flaky cellular connections see errors constantly. If your error types are stringly-typed, debugging production issues becomes guesswork.

The networking patterns in this lesson are not OpenAI-specific. They transfer to any authenticated API â€” Anthropic, Google Cloud, your own backend. Learn them once, use them everywhere. And then understand that for sensitive domains like recovery apps, sometimes the right answer is to skip automated analysis entirely and let the user speak for themselves.

## How BetAway Actually Handles Mood Data

Before we build a cloud API reference implementation, let us look at what BetAway actually ships. The app uses a `MoodRating` enum that maps integers 1-5 to human-readable states. This is from the real `Enums.swift`:

```swift
// BetFree/Models/Enums.swift â€” what BetAway actually ships

enum MoodRating: Int, Codable, CaseIterable, Identifiable {
    case veryBad = 1
    case bad = 2
    case neutral = 3
    case good = 4
    case veryGood = 5

    var id: Int { rawValue }

    var emoji: String {
        switch self {
        case .veryBad: return "ðŸ˜£"
        case .bad: return "ðŸ˜”"
        case .neutral: return "ðŸ˜"
        case .good: return "ðŸ™‚"
        case .veryGood: return "ðŸ˜Š"
        }
    }

    var label: String {
        switch self {
        case .veryBad: return LanguageManager.shared.localized("Very Bad")
        case .bad: return LanguageManager.shared.localized("Bad")
        case .neutral: return LanguageManager.shared.localized("Okay")
        case .good: return LanguageManager.shared.localized("Good")
        case .veryGood: return LanguageManager.shared.localized("Great")
        }
    }
}
```

And here is the `JournalEntry` model â€” the SwiftData model where mood is stored as a plain integer, selected by the user:

```swift
// BetFree/Models/JournalEntry.swift â€” what BetAway actually ships

@Model
final class JournalEntry {
    var id: UUID = UUID()
    var createdAt: Date = Date()
    var title: String = ""
    var content: String = ""
    var mood: Int = 3
    var promptUsed: String = ""

    @Relationship(inverse: \UserProfile.journalEntries) var userProfile: UserProfile?

    var moodRating: MoodRating? {
        get { MoodRating(rawValue: mood) }
        set { mood = newValue?.rawValue ?? 3 }
    }

    init(
        title: String = "",
        content: String = "",
        mood: MoodRating = .neutral,
        promptUsed: String = ""
    ) {
        self.id = UUID()
        self.createdAt = Date()
        self.title = title
        self.content = content
        self.mood = mood.rawValue
        self.promptUsed = promptUsed
    }
}
```

Notice what is **not** here: no sentiment score, no confidence value, no AI-generated themes, no API call. The `mood` is an `Int` that the user selects through a mood picker. The `content` is stored locally via SwiftData and never sent anywhere. The `promptUsed` is one of several optional writing prompts (like "What am I grateful for?") â€” not an AI prompt, but a journaling prompt for the user.

Here is how the journal entry view collects mood â€” the user taps an emoji to select their state. This is from the real `JournalEntryView.swift`:

```swift
// BetFree/Views/Journal/JournalEntryView.swift â€” what BetAway actually ships

struct JournalEntryView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.dismiss) private var dismiss
    let profile: UserProfile?
    var editingEntry: JournalEntry?

    @State private var title = ""
    @State private var content = ""
    @State private var selectedMood: MoodRating = .neutral
    @State private var selectedPrompt: JournalPrompt?
    @State private var isVisible = false

    private var isEditing: Bool { editingEntry != nil }

    var body: some View {
        ScrollView {
            VStack(spacing: Spacing.xl) {
                // Mood selector
                VStack(alignment: .leading, spacing: Spacing.sm) {
                    Text("How are you feeling?")
                        .font(Typography.headline())
                        .foregroundStyle(ColorPalette.textPrimary)

                    HStack(spacing: Spacing.md) {
                        ForEach(MoodRating.allCases) { mood in
                            Button {
                                withAnimation(AnimationPresets.snappy) {
                                    selectedMood = mood
                                }
                            } label: {
                                VStack(spacing: Spacing.xxs) {
                                    Text(mood.emoji)
                                        .font(.system(size: selectedMood == mood ? 36 : 28))

                                    Text(mood.label)
                                        .font(Typography.caption(weight: .medium))
                                        .foregroundStyle(
                                            selectedMood == mood
                                                ? ColorPalette.accent
                                                : ColorPalette.textTertiary
                                        )
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, Spacing.xs)
                                .background(
                                    selectedMood == mood
                                        ? ColorPalette.accent.opacity(0.1)
                                        : Color.clear
                                )
                                .clipShape(RoundedRectangle(cornerRadius: Spacing.Radius.small, style: .continuous))
                            }
                            .buttonStyle(.plain)
                        }
                    }
                }
                .staggeredAppear(index: 0, isVisible: isVisible)

                // ... title field, content field, save button
            }
        }
    }

    private func saveEntry() {
        if let entry = editingEntry {
            entry.title = title
            entry.content = content
            entry.moodRating = selectedMood
            entry.promptUsed = selectedPrompt?.rawValue ?? entry.promptUsed
        } else {
            let entry = JournalEntry(
                title: title,
                content: content,
                mood: selectedMood,
                promptUsed: selectedPrompt?.rawValue ?? ""
            )
            entry.userProfile = profile
            modelContext.insert(entry)
        }
        dismiss()
    }
}
```

And here is how BetAway tracks mood over time without any AI â€” the `ProgressViewModel` computes averages directly from the user's self-reported mood integers:

```swift
// BetFree/ViewModels/ProgressViewModel.swift â€” what BetAway actually ships

@Observable
final class ProgressViewModel {
    var selectedTimeRange: TimeRange = .week

    enum TimeRange: String, CaseIterable, Identifiable {
        case week = "7D"
        case month = "30D"
        case threeMonths = "90D"

        var id: String { rawValue }
        var days: Int {
            switch self {
            case .week: return 7
            case .month: return 30
            case .threeMonths: return 90
            }
        }
    }

    // MARK: - Mood Chart Data

    struct MoodDataPoint: Identifiable {
        let id = UUID()
        let date: Date
        let value: Double
        let label: String
    }

    func moodData(from checkins: [DailyCheckin], days: Int) -> [MoodDataPoint] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())

        return (0..<days).compactMap { offset in
            guard let date = calendar.date(byAdding: .day, value: -offset, to: today) else { return nil }

            let dayCheckins = checkins.filter { calendar.isDate($0.date, inSameDayAs: date) }
            guard !dayCheckins.isEmpty else { return nil }

            let avgMood = Double(dayCheckins.map(\.mood).reduce(0, +)) / Double(dayCheckins.count)
            let label = MoodRating(rawValue: Int(avgMood.rounded())) ?? .neutral

            return MoodDataPoint(date: date, value: avgMood, label: label.emoji)
        }
        .reversed()
    }

    // MARK: - Summary Stats

    struct SummaryStats {
        let totalUrges: Int
        let resistedUrges: Int
        let resistRate: Double
        let avgMood: Double
        let journalEntries: Int
        let pledgesMade: Int
    }

    func summaryStats(
        urgeLogs: [UrgeLog],
        checkins: [DailyCheckin],
        journalEntries: [JournalEntry],
        days: Int
    ) -> SummaryStats {
        let calendar = Calendar.current
        let cutoff = calendar.date(byAdding: .day, value: -days, to: Date()) ?? Date()

        let periodUrges = urgeLogs.filter { $0.timestamp >= cutoff }
        let periodCheckins = checkins.filter { $0.date >= cutoff }
        let periodJournals = journalEntries.filter { $0.createdAt >= cutoff }

        let resisted = periodUrges.filter(\.didResist).count
        let resistRate = periodUrges.isEmpty ? 1.0 : Double(resisted) / Double(periodUrges.count)

        let moodCheckins = periodCheckins.filter { $0.mood > 0 }
        let avgMood = moodCheckins.isEmpty ? 3.0 : Double(moodCheckins.map(\.mood).reduce(0, +)) / Double(moodCheckins.count)

        let pledges = periodCheckins.filter { $0.checkinTypeRaw == CheckinType.morningPledge.rawValue }.count

        return SummaryStats(
            totalUrges: periodUrges.count,
            resistedUrges: resisted,
            resistRate: resistRate,
            avgMood: avgMood,
            journalEntries: periodJournals.count,
            pledgesMade: pledges
        )
    }
}
```

No sentiment analysis. No NLP. The mood trend chart plots what the user told the app, not what an algorithm inferred. This is a deliberate design choice: the user is the expert on their own emotional state. An ML model guessing "you seem sad" based on text analysis is both less accurate and less empowering than the user saying "I feel sad today."

## Plan Phase: The Cloud Pattern (Reference Implementation)

Now let us build the cloud API integration that BetAway chose not to use. These patterns transfer to any authenticated API.

Open Claude Code in your BetAway project directory and send this planning prompt:

```
I need to integrate the OpenAI Chat Completion API as a reference
implementation for our BetAway gambling recovery app. Before writing
code, plan the implementation.

Context:
- BetAway is a SwiftUI app using MVVM + Service Layer, Swift 6,
  SwiftData, targeting iOS 17+
- We want to understand how cloud sentiment analysis works, even
  though BetAway uses manual mood tracking (MoodRating enum, 1-5)
  for privacy reasons
- The reference implementation should send a recovery journal entry
  (user text) to GPT and receive structured sentiment analysis back
- The response should include: sentiment (positive/neutral/negative),
  a confidence score (0.0-1.0), up to 3 key themes, and a short
  AI-generated insight (1-2 sentences)

Plan these files:
1. APIError.swift â€” typed error enum for all failure modes
2. KeychainHelper.swift â€” secure storage for the API key
3. ChatMessage.swift â€” Codable request/response models matching
   the OpenAI API
4. OpenAIService.swift â€” async service with retry logic

For each file, list the types and methods. Do not write code yet.
```

Claude Code will produce a structured plan. Review it for a few things.

**Check the model separation.** You want raw API models (matching OpenAI's JSON exactly) and a domain model (the `SentimentResult` your app actually uses). If the plan lumps them together, push back â€” API schemas change, and you do not want that rippling through your views.

**Check the error cases.** You need at minimum: invalid API key, rate limited (429), server error (5xx), network unreachable, decoding failure, and empty response. If the plan is missing rate limiting, add it â€” OpenAI enforces hard limits and you will hit them during development.

**Check the Keychain approach.** If the plan suggests UserDefaults, Environment variables at runtime, or a hardcoded string, reject it immediately. BetAway's real codebase does not store any API keys because it does not call any cloud APIs â€” but if it did, the Keychain is the only acceptable location.

### The Anti-Pattern

Here is what bad OpenAI integration looks like â€” and what AI will generate if you prompt lazily:

```swift
// Reference implementation â€” DO NOT DO THIS
let apiKey = "sk-proj-abc123..." // Hardcoded. Scraped in hours.

let json = try JSONSerialization.jsonObject(with: data) as! [String: Any] // Force cast. Crash.
let content = (json["choices"] as! [[String: Any]])[0]["message"] // Force unwrap. Crash.

// No error handling. No retry. No typed errors.
// This code will cost you money and crash in production.
```

Hardcoded keys get extracted from your app binary with trivial tooling. Force-unwrapping JSON crashes the moment OpenAI changes their response format â€” which they do. No retry logic means every transient network hiccup becomes a user-visible error. We are going to do better.

## Execute Phase: Reference Implementation

Now send the execution prompt:

```
Implement the OpenAI integration as a reference pattern. Follow our
CLAUDE.md conventions (Swift 6, strict concurrency, @Observable,
os.Logger).

Create these files in order:

1. Services/API/APIError.swift
   - Enum with typed throws (Swift 6)
   - Cases: invalidURL, invalidAPIKey, httpError(statusCode: Int),
     rateLimited(retryAfter: TimeInterval?), decodingFailed(Error),
     networkUnavailable, emptyResponse, underlying(Error)
   - Conform to LocalizedError with user-friendly descriptions

2. Helpers/KeychainHelper.swift
   - save(key:data:), read(key:) -> Data?, delete(key:)
   - Use Security framework directly (no third-party wrapper)
   - Convenience methods: saveAPIKey(_:), readAPIKey() -> String?

3. Models/API/ChatMessage.swift
   - ChatCompletionRequest: model, messages array, temperature,
     max_tokens
   - ChatCompletionResponse: id, choices array with message content
   - Message: role (system/user/assistant), content
   - All Codable, matching OpenAI's exact JSON schema

4. Services/API/OpenAIService.swift
   - init with baseURL and KeychainHelper
   - analyzeSentiment(text:) async throws(APIError) -> SentimentResult
   - Private: performRequest, buildRequest, parseResponse
   - Retry logic: 3 attempts, exponential backoff, only on 429/5xx
   - Rate limit awareness: respect Retry-After header

Also create Models/SentimentResult.swift â€” our domain model with
sentiment (enum), confidence (Double), themes ([String]),
insight (String).
```

Review the AI output carefully. Here is what to look for:

- **APIError.swift** â€” Does it conform to `LocalizedError`? Does the `rateLimited` case carry an optional `retryAfter` value? These details matter for retry logic downstream.
- **KeychainHelper.swift** â€” Does it use `SecItemAdd`, `SecItemCopyMatching`, `SecItemDelete` from the Security framework? If it imports any third-party Keychain library, reject it. The Security framework is four functions. You do not need a wrapper.
- **ChatMessage.swift** â€” Does the request model use `CodingKeys` to map `maxTokens` to `max_tokens`? OpenAI's API uses snake_case. Swift uses camelCase. If there are no `CodingKeys`, the request will serialize wrong and the API will reject it.
- **OpenAIService.swift** â€” Does retry logic check the status code before retrying? Retrying a 401 (bad API key) is pointless. Only 429 (rate limit) and 5xx (server error) should retry.

## Iteration

After reviewing the initial output, send this follow-up to tighten the implementation:

```
Good foundation. Refine these things:

1. In OpenAIService, the system prompt for sentiment analysis
   should instruct GPT to respond in a strict JSON format:
   {"sentiment": "positive", "confidence": 0.85,
    "themes": ["gratitude", "progress"], "insight": "..."}
   Parse this from the message content string, not from the
   top-level API response.

2. Add a Sendable conformance to OpenAIService so it can be
   safely used from any actor context.

3. KeychainHelper should use kSecAttrAccessible:
   kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly â€” the API key
   should survive backgrounding but not device backups.

4. Add os.Logger to OpenAIService. Log request start, retry
   attempts, and failures at appropriate levels (debug, info,
   error). Never log the API key.
```

This iteration catches the things AI usually misses: the Keychain accessibility level (critical for security), the Sendable conformance (required for Swift 6 strict concurrency), and the logging discipline (never log secrets).

## Verify Phase

Before moving on, verify these things manually:

1. **Build the project.** Zero warnings, zero errors. Swift 6 strict concurrency should not complain about any of these types.
2. **Check the Keychain accessibility.** Open `KeychainHelper.swift` and confirm it uses `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`, not `kSecAttrAccessibleAlways` or nothing at all.
3. **Check CodingKeys.** Open `ChatMessage.swift` and verify that `maxTokens` maps to `max_tokens`, and any other snake_case fields are handled.
4. **Check retry logic.** Read `OpenAIService.swift` and confirm it only retries on 429 and 5xx. Confirm it reads the `Retry-After` header on 429 responses. Confirm the backoff is exponential (1s, 2s, 4s), not linear.
5. **Check that the API key is never hardcoded.** Search the entire project for `sk-`. There should be zero results.

## Final Code (Reference Implementation)

Here is the complete, production-quality reference implementation. Every file compiles with Swift 6 strict concurrency enabled. **BetAway does not ship any of this code.** The real app uses manual mood tracking with `MoodRating` (shown above). This OpenAI integration serves as a reference pattern for cloud API work you will encounter in other projects.

### APIError.swift

```swift
// Reference implementation â€” not shipped in BetAway

import Foundation

enum APIError: Error, LocalizedError, Sendable {
    case invalidURL
    case invalidAPIKey
    case httpError(statusCode: Int)
    case rateLimited(retryAfter: TimeInterval?)
    case decodingFailed(Error)
    case networkUnavailable
    case emptyResponse
    case underlying(Error)

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            "The request URL could not be constructed."
        case .invalidAPIKey:
            "Your API key is missing or invalid. Add it in Settings."
        case .httpError(let statusCode):
            "The server returned an error (HTTP \(statusCode))."
        case .rateLimited:
            "Too many requests. Please wait a moment and try again."
        case .decodingFailed:
            "The server response could not be read."
        case .networkUnavailable:
            "No internet connection. Check your network and try again."
        case .emptyResponse:
            "The server returned an empty response."
        case .underlying(let error):
            error.localizedDescription
        }
    }

    var isRetryable: Bool {
        switch self {
        case .rateLimited, .networkUnavailable:
            true
        case .httpError(let code):
            code >= 500
        default:
            false
        }
    }
}
```

### KeychainHelper.swift

```swift
// Reference implementation â€” not shipped in BetAway
// BetAway has no API keys because it makes no cloud API calls.

import Foundation
import Security

struct KeychainHelper: Sendable {
    private static let serviceName = "com.nativefirst.betaway.api"

    // MARK: - Generic Operations

    static func save(key: String, data: Data) -> Bool {
        delete(key: key)

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
        ]

        let status = SecItemAdd(query as CFDictionary, nil)
        return status == errSecSuccess
    }

    static func read(key: String) -> Data? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess else { return nil }
        return result as? Data
    }

    @discardableResult
    static func delete(key: String) -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key
        ]

        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess || status == errSecItemNotFound
    }

    // MARK: - API Key Convenience

    private static let apiKeyAccount = "openai-api-key"

    static func saveAPIKey(_ key: String) -> Bool {
        guard let data = key.data(using: .utf8) else { return false }
        return save(key: apiKeyAccount, data: data)
    }

    static func readAPIKey() -> String? {
        guard let data = read(key: apiKeyAccount) else { return nil }
        return String(data: data, encoding: .utf8)
    }

    static func deleteAPIKey() -> Bool {
        delete(key: apiKeyAccount)
    }
}
```

### ChatMessage.swift

```swift
// Reference implementation â€” not shipped in BetAway

import Foundation

// MARK: - Request Models

struct ChatCompletionRequest: Encodable, Sendable {
    let model: String
    let messages: [ChatMessage]
    let temperature: Double
    let maxTokens: Int

    enum CodingKeys: String, CodingKey {
        case model, messages, temperature
        case maxTokens = "max_tokens"
    }
}

struct ChatMessage: Codable, Sendable {
    let role: Role
    let content: String

    enum Role: String, Codable, Sendable {
        case system
        case user
        case assistant
    }
}

// MARK: - Response Models

struct ChatCompletionResponse: Decodable, Sendable {
    let id: String
    let choices: [Choice]
    let usage: Usage

    struct Choice: Decodable, Sendable {
        let index: Int
        let message: ChatMessage
        let finishReason: String?

        enum CodingKeys: String, CodingKey {
            case index, message
            case finishReason = "finish_reason"
        }
    }

    struct Usage: Decodable, Sendable {
        let promptTokens: Int
        let completionTokens: Int
        let totalTokens: Int

        enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
        }
    }
}

// MARK: - Domain Model

struct SentimentResult: Sendable {
    let sentiment: Sentiment
    let confidence: Double
    let themes: [String]
    let insight: String

    enum Sentiment: String, Codable, Sendable {
        case positive
        case neutral
        case negative
    }
}

/// Raw JSON shape we ask GPT to return inside the message content.
private struct SentimentPayload: Decodable {
    let sentiment: SentimentResult.Sentiment
    let confidence: Double
    let themes: [String]
    let insight: String

    func toDomain() -> SentimentResult {
        SentimentResult(
            sentiment: sentiment,
            confidence: min(max(confidence, 0), 1),
            themes: Array(themes.prefix(3)),
            insight: insight
        )
    }
}
```

### OpenAIService.swift

```swift
// Reference implementation â€” not shipped in BetAway

import Foundation
import os

final class OpenAIService: Sendable {
    private let baseURL: String
    private let session: URLSession
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "OpenAIService")

    private let maxRetries = 3
    private let initialBackoff: TimeInterval = 1.0

    init(
        baseURL: String = "https://api.openai.com",
        session: URLSession = .shared
    ) {
        self.baseURL = baseURL
        self.session = session

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder = decoder

        let encoder = JSONEncoder()
        self.encoder = encoder
    }

    // MARK: - Public API

    func analyzeSentiment(text: String) async throws(APIError) -> SentimentResult {
        guard let apiKey = KeychainHelper.readAPIKey(), !apiKey.isEmpty else {
            throw .invalidAPIKey
        }

        let systemPrompt = """
        You are a sentiment analysis engine for a recovery journal app. \
        Analyze the user's journal entry and respond with ONLY a JSON object \
        in this exact format, no markdown, no explanation:
        {"sentiment":"positive","confidence":0.85,"themes":["progress","resilience"],"insight":"A brief 1-2 sentence insight."}

        Rules:
        - sentiment must be exactly one of: positive, neutral, negative
        - confidence is a Float between 0.0 and 1.0
        - themes is an array of 1-3 single-word or short-phrase strings
        - insight is 1-2 sentences, empathetic and encouraging
        """

        let request = ChatCompletionRequest(
            model: "gpt-4o-mini",
            messages: [
                ChatMessage(role: .system, content: systemPrompt),
                ChatMessage(role: .user, content: text)
            ],
            temperature: 0.3,
            maxTokens: 200
        )

        let response: ChatCompletionResponse = try await performRequest(
            path: "/v1/chat/completions",
            body: request,
            apiKey: apiKey
        )

        return try parseResponse(response)
    }

    // MARK: - Networking

    private func performRequest<RequestBody: Encodable, ResponseBody: Decodable>(
        path: String,
        body: RequestBody,
        apiKey: String
    ) async throws(APIError) -> ResponseBody {
        let urlRequest: URLRequest
        do {
            urlRequest = try buildRequest(path: path, body: body, apiKey: apiKey)
        } catch let error as APIError {
            throw error
        } catch {
            throw .underlying(error)
        }

        var lastError: APIError = .emptyResponse

        for attempt in 0..<maxRetries {
            if attempt > 0 {
                logger.info("Retry attempt \(attempt) of \(self.maxRetries - 1)")
            }

            do {
                let (data, response) = try await session.data(for: urlRequest)

                guard let httpResponse = response as? HTTPURLResponse else {
                    throw APIError.emptyResponse
                }

                logger.debug("HTTP \(httpResponse.statusCode) for \(path)")

                switch httpResponse.statusCode {
                case 200...299:
                    do {
                        return try decoder.decode(ResponseBody.self, from: data)
                    } catch {
                        throw APIError.decodingFailed(error)
                    }

                case 401:
                    throw APIError.invalidAPIKey

                case 429:
                    let retryAfter = httpResponse.value(forHTTPHeaderField: "Retry-After")
                        .flatMap { TimeInterval($0) }
                    let error = APIError.rateLimited(retryAfter: retryAfter)

                    if attempt < maxRetries - 1 {
                        let delay = retryAfter ?? (initialBackoff * pow(2.0, Double(attempt)))
                        logger.info("Rate limited. Waiting \(delay)s before retry.")
                        try? await Task.sleep(for: .seconds(delay))
                        lastError = error
                        continue
                    }
                    throw error

                case 500...599:
                    let error = APIError.httpError(statusCode: httpResponse.statusCode)

                    if attempt < maxRetries - 1 {
                        let delay = initialBackoff * pow(2.0, Double(attempt))
                        logger.info("Server error \(httpResponse.statusCode). Waiting \(delay)s before retry.")
                        try? await Task.sleep(for: .seconds(delay))
                        lastError = error
                        continue
                    }
                    throw error

                default:
                    throw APIError.httpError(statusCode: httpResponse.statusCode)
                }

            } catch let error as APIError {
                if !error.isRetryable || attempt >= maxRetries - 1 {
                    throw error
                }
                lastError = error
            } catch let urlError as URLError where urlError.code == .notConnectedToInternet
                || urlError.code == .networkConnectionLost {
                let error = APIError.networkUnavailable
                if attempt >= maxRetries - 1 {
                    throw error
                }
                lastError = error
                let delay = initialBackoff * pow(2.0, Double(attempt))
                try? await Task.sleep(for: .seconds(delay))
            } catch {
                throw APIError.underlying(error)
            }
        }

        throw lastError
    }

    private func buildRequest<Body: Encodable>(
        path: String,
        body: Body,
        apiKey: String
    ) throws -> URLRequest {
        guard let url = URL(string: baseURL + path) else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.timeoutInterval = 30

        do {
            request.httpBody = try encoder.encode(body)
        } catch {
            throw APIError.underlying(error)
        }

        return request
    }

    // MARK: - Response Parsing

    private func parseResponse(_ response: ChatCompletionResponse) throws(APIError) -> SentimentResult {
        guard let content = response.choices.first?.message.content else {
            throw .emptyResponse
        }

        logger.debug("Token usage â€” prompt: \(response.usage.promptTokens), completion: \(response.usage.completionTokens)")

        guard let jsonData = content.data(using: .utf8) else {
            throw .decodingFailed(
                DecodingError.dataCorrupted(
                    .init(codingPath: [], debugDescription: "Content is not valid UTF-8")
                )
            )
        }

        do {
            let payload = try JSONDecoder().decode(SentimentPayload.self, from: jsonData)
            return payload.toDomain()
        } catch {
            logger.error("Failed to parse sentiment JSON from GPT content: \(content)")
            throw .decodingFailed(error)
        }
    }
}
```

A few things worth calling out in this reference implementation.

**The `SentimentPayload` is private.** The rest of the app never sees it. It exists solely to decode GPT's JSON content string into a `SentimentResult`. If OpenAI changes their response format, you update `ChatCompletionResponse`. If you change how you prompt GPT, you update `SentimentPayload`. Neither change touches your views or view models.

**The system prompt asks for raw JSON, no markdown.** GPT models love wrapping JSON in triple-backtick code fences. The explicit instruction "no markdown, no explanation" prevents that. If you skip this, you will get ````json\n{...}\n```` back and your decoder will choke.

**Temperature is 0.3.** For classification tasks, you want low temperature â€” consistent, predictable outputs. Creative writing uses 0.7-1.0. Sentiment analysis is not creative.

**`gpt-4o-mini`** is the model. It is cheap (fractions of a cent per call), fast (under 2 seconds typically), and more than capable enough for sentiment classification. Do not use `gpt-4o` for this â€” it is slower, more expensive, and overkill for structured extraction tasks.

**Retry only fires on 429 and 5xx.** A 401 means your key is wrong â€” retrying will not fix it. A 400 means your request is malformed â€” retrying will not fix it. Only transient errors (rate limits, server hiccups) get retried. This is a decision most tutorials get wrong.

### Why BetAway Uses Manual Mood Tracking Instead

Now that you understand how cloud API integration works, here is why BetAway deliberately avoids it:

1. **Privacy** â€” Recovery journal entries contain deeply sensitive information: gambling amounts, emotional breakdowns, relationship damage, financial details. Sending this to any cloud API â€” even one with good privacy policies â€” is a trust violation. BetAway's `JournalEntry.content` is stored locally in SwiftData and never leaves the device.

2. **User agency** â€” BetAway's `MoodRating` lets the user declare their own emotional state. An algorithm guessing "you seem negative" based on text analysis can be wrong, patronizing, or triggering. The user tapping a mood emoji is always accurate to their experience.

3. **Offline-first** â€” Users in crisis need the app to work immediately, regardless of network conditions. The `EveningCheckinView` mood selector works in airplane mode, underground, anywhere. A cloud dependency means the app fails exactly when the user needs it most.

4. **Zero cost** â€” No API key management, no billing, no usage caps. BetAway is completely free and stays that way. The real `AppConfig.swift` has no API-related configuration at all.

5. **Simplicity** â€” The `ProgressViewModel.moodData(from:days:)` method computes mood trends by averaging integers. No parsing, no error handling, no retry logic. Simple code has fewer bugs.

The real BetAway check-in flow â€” from the actual `DailyCheckin` model â€” stores mood as a raw integer alongside gambling-free status, triggers, and notes:

```swift
// BetFree/Models/DailyCheckin.swift â€” what BetAway actually ships

@Model
final class DailyCheckin {
    var id: UUID = UUID()
    var date: Date = Date()
    var checkinTypeRaw: String = CheckinType.morningPledge.rawValue
    var mood: Int = MoodRating.neutral.rawValue
    var gamblingFree: Bool = true
    var amountGambled: Double?
    var pledgeReason: String = ""
    var notes: String = ""
    var triggersRaw: [String] = []
    var riskLevelRaw: String = RiskLevel.low.rawValue
    var createdAt: Date = Date()

    @Relationship(inverse: \UserProfile.checkins) var userProfile: UserProfile?

    var moodRating: MoodRating {
        get { MoodRating(rawValue: mood) ?? .neutral }
        set { mood = newValue.rawValue }
    }

    var triggers: [PredefinedTrigger] {
        get { triggersRaw.compactMap { PredefinedTrigger(rawValue: $0) } }
        set { triggersRaw = newValue.map(\.rawValue) }
    }

    init(
        checkinType: CheckinType,
        mood: MoodRating = .neutral,
        gamblingFree: Bool = true,
        pledgeReason: String = "",
        notes: String = ""
    ) {
        self.id = UUID()
        self.date = Date()
        self.checkinTypeRaw = checkinType.rawValue
        self.mood = mood.rawValue
        self.gamblingFree = gamblingFree
        self.pledgeReason = pledgeReason
        self.notes = notes
        self.createdAt = Date()
    }
}
```

This model captures everything BetAway needs for mood trend analysis without any AI: a mood integer, a boolean for gambling-free status, an array of predefined triggers, and optional notes. The `PledgeViewModel` saves check-ins directly to SwiftData with no intermediate processing step.

## Checkpoint

Before moving to the next lesson, confirm all of the following:

- [ ] You understand the difference between BetAway's real approach (manual `MoodRating` selection) and cloud sentiment analysis
- [ ] You can identify the `APIError` pattern â€” `LocalizedError` conformance, typed throws, retryable classification
- [ ] You know why `KeychainHelper` uses `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` (survives backgrounding, excluded from backups)
- [ ] `ChatCompletionRequest` has `CodingKeys` mapping `maxTokens` to `max_tokens` for OpenAI's snake_case JSON
- [ ] Retry logic only retries on 429 and 5xx â€” not 401 or 400
- [ ] The `Retry-After` header is respected on 429 responses
- [ ] You understand why BetAway chose manual mood tracking over cloud or on-device sentiment analysis
- [ ] Searching BetAway's real codebase for `sk-`, `OpenAI`, `NLTagger`, or `APIKey` returns zero results â€” the real app has no AI dependencies

## Challenge

**Add a token budget guard.** Before sending a request in the reference `OpenAIService`, estimate the token count of the user's journal entry (rough heuristic: 1 token per 4 characters in English). If the entry would exceed a configurable maximum (say 1000 tokens), return a new `APIError.inputTooLong(estimatedTokens: Int, limit: Int)` case instead of making the network call. This prevents wasting money on entries that will be truncated by the `max_tokens` limit anyway.

*Hint:* Add the estimation as a private method on `OpenAIService`. The check goes at the top of `analyzeSentiment(text:)`, before you even read the API key. Add the new case to `APIError` with a user-friendly description like "Your entry is too long for analysis. Try shortening it."
