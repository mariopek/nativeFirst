---
title: "Design System & Theme"
description: "Build a cohesive design system for BetAway with a color palette, typography scale, spacing tokens, and reusable SwiftUI components that support dark mode from day one."
courseSlug: "ship-native"
module: 2
moduleTitle: "Core UI with SwiftUI"
lesson: 1
duration: "20 min read"
difficulty: "intermediate"
topics: ["SwiftUI", "Design System", "Theme", "Dark Mode", "Colors", "Typography", "Reusable Components", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Every production app has a design system, whether the team knows it or not. The question is whether it is intentional or accidental. Accidental design systems are the ones where button padding is 12 in one view, 16 in another, and 10 in a third. Where colors are defined inline as `Color(.init(red: 0.4, green: 0.2, blue: 0.8))` and duplicated across fifteen files. Where a "minor" rebrand means touching every single view in the project.

In this lesson, we build BetAway's design system from scratch: a color palette tied to recovery status levels, a typography scale with Dynamic Type, spacing tokens, and three reusable components. Everything supports dark mode from day one. And we build it with AI â€” using the Plan-Execute-Iterate workflow.

## What You'll Learn

- Define a semantic color palette with recovery-status colors, brand colors, and automatic dark mode support
- Create a typography scale and spacing token system that enforces consistency across the entire app
- Build three reusable components â€” `StatusButton`, `CheckInCard`, and `GradientBackground` â€” using Swift 6 and modern SwiftUI
- Use the Plan-Execute-Iterate workflow to generate production-quality theme infrastructure with AI

## Why This Matters

Design systems are not a luxury reserved for large teams. They are the single fastest way to make an app feel cohesive, and they reduce the cost of every future UI change from "touch twelve files" to "change one token." BetAway tracks recovery progress across five status levels, and each level needs a distinct visual identity â€” colors, gradients, shapes. Getting this right in a centralized theme means every screen we build in the next lessons automatically looks correct.

## Plan Phase: Defining What We Build

Before we write any Swift, we need a plan. Here is the prompt I send to Claude Code:

```
I am building a free gambling recovery app called BetAway using SwiftUI.
Before writing any code, plan a complete design system with:

1. Color palette:
   - 5 recovery-status colors (status 1 = crisis/struggling through
     status 5 = thriving/strong), each with a main and a lighter variant
   - Brand purple as the primary accent
   - Semantic colors: background, surface, text primary,
     text secondary, divider, error, success
   - All colors must support light and dark mode

2. Typography scale:
   - Use system fonts with proper Dynamic Type support
   - Define sizes: largeTitle, title, heading, body, caption, small
   - Include weight variants

3. Spacing tokens:
   - A consistent spacing scale: xs, sm, md, lg, xl, xxl
   - Corner radius tokens: sm, md, lg, full

4. Three reusable components:
   - StatusButton: pill-shaped, shows a status emoji + label,
     supports selected/unselected states
   - CheckInCard: rounded card with a status color indicator strip,
     text content, and a timestamp
   - GradientBackground: full-screen gradient based on a recovery status

Output only the plan â€” file names, type signatures, and design
decisions. Do not write implementation code yet.
```

The AI responds with a structured plan: three files (`Theme.swift`, `StatusButton.swift`, `CheckInCard.swift`), the exact color values, the spacing scale, and the component APIs. Read through it carefully.

**What to check in the plan:**

- Does the status color progression make visual sense? Status 1 (crisis) should be cool or muted â€” blues or grays. Status 5 (thriving) should be warm and bright â€” greens or yellows.
- Are the spacing values based on a consistent base unit? A 4-point grid (4, 8, 12, 16, 24, 32) is industry standard.
- Do the component APIs use proper SwiftUI conventions â€” value types, view modifiers, bindings where appropriate?

### The Anti-Pattern: What a Bad Prompt Looks Like

Here is how NOT to prompt for a design system:

```
Make me some colors and buttons for my recovery app. Use nice colors
that look good. Also make it work in dark mode.
```

This gives the AI zero constraints. "Nice colors" is subjective. "Look good" is unmeasurable. The AI will pick arbitrary values, and you will end up with scattered inline colors â€” the exact accidental design system we are trying to avoid. Always specify structure: how many colors, what they represent, what file they live in, and what API they expose.

## Execute Phase: Implementation

Now we tell the AI to build it. Here is the implementation prompt:

```
Implement the design system we planned. Create these files:

1. Theme.swift â€” contains all tokens:
   - RecoveryStatus enum with cases status1 through status5, each
     with a main Color and a light Color property. Use Color assets
     defined in code with light/dark variants using UIColor's
     trait-based initializer.
   - Status 1: steel blue (light: #6B8DAE, dark: #7FA3C4)
   - Status 2: soft teal (light: #5BAAAA, dark: #6FC4C4)
   - Status 3: warm amber (light: #E8A950, dark: #F0BC6A)
   - Status 4: soft green (light: #7BC67E, dark: #90D893)
   - Status 5: vibrant coral (light: #E8736C, dark: #F08A84)
   - Brand purple: light #6C5CE7, dark #8577ED
   - AppTypography struct with static properties returning Font
     values using .system with proper TextStyle for Dynamic Type
   - AppSpacing enum with CGFloat constants on a 4pt grid
   - AppRadius enum with CGFloat constants

2. StatusButton.swift â€” pill-shaped button:
   - Takes a recovery status (Int 1-5), label String, isSelected
     Bool, and action closure
   - Shows an emoji (status 1=ðŸ˜°, 2=ðŸ˜Ÿ, 3=ðŸ™‚, 4=ðŸ’ª, 5=ðŸŒŸ)
     plus the label text
   - Selected state: filled with status color, white text
   - Unselected state: status color border, status color text,
     clear background
   - Capsule shape, horizontal padding 16, vertical 10
   - Accessibility label that reads "Recovery status [N], [label]"

3. CheckInCard.swift â€” card component:
   - Takes title String, body text String, recovery status Int,
     and timestamp Date
   - Left edge has a 4pt-wide color strip in the status color
   - White (light) / elevated surface (dark) background
   - 12pt corner radius, subtle shadow in light mode
   - Timestamp formatted as relative ("2h ago", "Yesterday")
   - Include a GradientBackground ViewModifier that applies a
     top-to-bottom gradient using the status's main and light colors

Use Swift 6. All views must have #Preview blocks.
Do not use any third-party dependencies.
```

### Reviewing the AI Output

The AI generates the three files. Here is how I review them, using the traffic-light system:

**Theme.swift review:**

- Does `RecoveryStatus` use the trait-based `UIColor` initializer for dark mode support? If the AI used `Color("AssetName")` referencing an asset catalog, that works too but requires creating the asset catalog entries. The `UIColor { traitCollection in ... }` approach keeps everything in code. Either approach is valid â€” just be consistent.
- Are the `Font` values using `.system(..., design:)` with a `TextStyle` parameter? This is what enables Dynamic Type. If the AI hardcoded `.system(size: 16)` without a `TextStyle`, that is a bug â€” the text will not scale with the user's accessibility settings.
- Are spacing values on the 4pt grid? Check that `sm` is 8, `md` is 12 or 16, `lg` is 24, etc. If the AI used values like 10, 15, 22 â€” those are off-grid and will create visual inconsistency.

**StatusButton.swift review:**

- Does the selected state use `.foregroundStyle(.white)` or `.foregroundColor(.white)`? The modern API is `.foregroundStyle`. Not a dealbreaker, but it tells you if the AI is generating current patterns.
- Is the `action` closure marked with `@escaping`? In a SwiftUI `Button`, the action closure does not need `@escaping` â€” if the AI added it, that is unnecessary noise.
- Does the `#Preview` show both selected and unselected states? A good preview block shows multiple variants.

**CheckInCard.swift review:**

- Is the shadow conditional on color scheme? In dark mode, shadows on dark surfaces look wrong. The AI should either remove the shadow in dark mode or use a very subtle one.
- Is the relative date formatter using `RelativeDateTimeFormatter` or the `.relative` date format style? The modern approach is `.formatted(.relative(presentation: .named))`.
- Does the gradient modifier use `LinearGradient` with the correct start/end points (`.top` to `.bottom`)?

## Iteration

After the first pass, there are usually one or two things to fix. Here is the follow-up prompt I send:

```
Two fixes for the design system:

1. In Theme.swift, the AppTypography fonts are using hardcoded
   sizes without a relativeTo TextStyle. Change them to use
   Font.system(.body, design: .default, weight: .regular) pattern
   so they scale with Dynamic Type. The largeTitle should use
   TextStyle.largeTitle, title should use .title2, heading .headline,
   body .body, caption .caption, small .caption2.

2. In CheckInCard.swift, the shadow is showing in dark mode.
   Add an @Environment(\.colorScheme) property and only apply
   .shadow when colorScheme == .light. In dark mode, use a
   1pt border in Color.white.opacity(0.08) instead.

3. Add a static property to RecoveryStatus that returns the emoji
   for each level, so StatusButton does not have its own
   hardcoded switch statement.
```

This is the refinement step. We are not rewriting the code â€” we are making targeted corrections based on our review. Each fix takes the AI about 10 seconds to apply.

## Verify Phase

Build and run. Here is what to check in the simulator:

**Color accuracy.** Open the app in both light and dark mode (use Environment Overrides in the simulator toolbar). Every recovery status color should be visible and distinguishable in both modes. Brand purple should feel like the accent color without clashing with the status palette.

**Dynamic Type.** Go to Settings > Accessibility > Display & Text Size > Larger Text on the simulator. Crank it to the maximum. Every text element should scale. Nothing should clip or overlap. If your typography tokens use proper `TextStyle` values, this just works.

**Component states.** Tap through `StatusButton` in all five recovery status levels, in both selected and unselected states. That is 10 combinations. All should be visually clear â€” you should instantly see which button is selected.

**Card rendering.** Check `CheckInCard` in light and dark mode. The color strip should be visible on the left edge. The shadow should appear only in light mode. The timestamp should display correctly for dates that are minutes, hours, and days old.

**Gradient.** The `GradientBackground` should produce a smooth top-to-bottom fade for each recovery status level. No banding, no harsh transitions.

## Final Code

Here is the complete, verified implementation of all three files.

### Theme.swift

```swift
import SwiftUI

// MARK: - Recovery Status Colors

enum RecoveryStatus: Int, CaseIterable {
    case status1 = 1, status2, status3, status4, status5

    var main: Color {
        switch self {
        case .status1: Color(UIColor { $0.userInterfaceStyle == .dark
            ? UIColor(red: 0.50, green: 0.64, blue: 0.77, alpha: 1)
            : UIColor(red: 0.42, green: 0.55, blue: 0.68, alpha: 1)
        })
        case .status2: Color(UIColor { $0.userInterfaceStyle == .dark
            ? UIColor(red: 0.44, green: 0.77, blue: 0.77, alpha: 1)
            : UIColor(red: 0.36, green: 0.67, blue: 0.67, alpha: 1)
        })
        case .status3: Color(UIColor { $0.userInterfaceStyle == .dark
            ? UIColor(red: 0.94, green: 0.74, blue: 0.42, alpha: 1)
            : UIColor(red: 0.91, green: 0.66, blue: 0.31, alpha: 1)
        })
        case .status4: Color(UIColor { $0.userInterfaceStyle == .dark
            ? UIColor(red: 0.56, green: 0.85, blue: 0.58, alpha: 1)
            : UIColor(red: 0.48, green: 0.78, blue: 0.49, alpha: 1)
        })
        case .status5: Color(UIColor { $0.userInterfaceStyle == .dark
            ? UIColor(red: 0.94, green: 0.54, blue: 0.52, alpha: 1)
            : UIColor(red: 0.91, green: 0.45, blue: 0.42, alpha: 1)
        })
        }
    }

    var light: Color {
        main.opacity(0.25)
    }

    var emoji: String {
        switch self {
        case .status1: "ðŸ˜°"
        case .status2: "ðŸ˜Ÿ"
        case .status3: "ðŸ™‚"
        case .status4: "ðŸ’ª"
        case .status5: "ðŸŒŸ"
        }
    }

    var label: String {
        switch self {
        case .status1: "Crisis"
        case .status2: "Struggling"
        case .status3: "Stable"
        case .status4: "Strong"
        case .status5: "Thriving"
        }
    }

    init?(level: Int) {
        self.init(rawValue: level)
    }
}

// MARK: - Brand & Semantic Colors

enum AppColor {
    static let brand = Color(UIColor { $0.userInterfaceStyle == .dark
        ? UIColor(red: 0.53, green: 0.47, blue: 0.93, alpha: 1)
        : UIColor(red: 0.42, green: 0.36, blue: 0.91, alpha: 1)
    })

    static let background = Color(UIColor.systemBackground)
    static let surface = Color(UIColor.secondarySystemBackground)
    static let surfaceElevated = Color(UIColor.tertiarySystemBackground)
    static let textPrimary = Color(UIColor.label)
    static let textSecondary = Color(UIColor.secondaryLabel)
    static let divider = Color(UIColor.separator)
    static let error = Color.red
    static let success = Color.green
}

// MARK: - Typography

struct AppTypography {
    static let largeTitle = Font.system(.largeTitle, design: .rounded, weight: .bold)
    static let title = Font.system(.title2, design: .rounded, weight: .semibold)
    static let heading = Font.system(.headline, design: .default, weight: .semibold)
    static let body = Font.system(.body, design: .default, weight: .regular)
    static let caption = Font.system(.caption, design: .default, weight: .regular)
    static let small = Font.system(.caption2, design: .default, weight: .regular)

    static let bodyMedium = Font.system(.body, design: .default, weight: .medium)
    static let captionMedium = Font.system(.caption, design: .default, weight: .medium)
}

// MARK: - Spacing (4pt grid)

enum AppSpacing {
    static let xs: CGFloat = 4
    static let sm: CGFloat = 8
    static let md: CGFloat = 12
    static let lg: CGFloat = 16
    static let xl: CGFloat = 24
    static let xxl: CGFloat = 32
}

// MARK: - Corner Radius

enum AppRadius {
    static let sm: CGFloat = 6
    static let md: CGFloat = 12
    static let lg: CGFloat = 20
    static let full: CGFloat = 999
}
```

### StatusButton.swift

```swift
import SwiftUI

struct StatusButton: View {
    let level: Int
    let label: String
    let isSelected: Bool
    let action: () -> Void

    private var statusColor: RecoveryStatus {
        RecoveryStatus(level: level) ?? .status3
    }

    var body: some View {
        Button(action: action) {
            HStack(spacing: AppSpacing.sm) {
                Text(statusColor.emoji)
                    .font(.system(.body))

                Text(label)
                    .font(AppTypography.bodyMedium)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, 10)
            .background(isSelected ? statusColor.main : Color.clear)
            .foregroundStyle(isSelected ? .white : statusColor.main)
            .clipShape(Capsule())
            .overlay(
                Capsule()
                    .strokeBorder(statusColor.main, lineWidth: isSelected ? 0 : 1.5)
            )
        }
        .buttonStyle(.plain)
        .accessibilityLabel("Recovery status \(level), \(label)")
        .accessibilityAddTraits(isSelected ? .isSelected : [])
    }
}

#Preview("All Status Buttons") {
    VStack(spacing: AppSpacing.md) {
        ForEach(RecoveryStatus.allCases, id: \.rawValue) { status in
            HStack(spacing: AppSpacing.md) {
                StatusButton(
                    level: status.rawValue,
                    label: status.label,
                    isSelected: false,
                    action: {}
                )
                StatusButton(
                    level: status.rawValue,
                    label: status.label,
                    isSelected: true,
                    action: {}
                )
            }
        }
    }
    .padding()
}
```

### CheckInCard.swift

```swift
import SwiftUI

struct CheckInCard: View {
    let title: String
    let bodyText: String
    let statusLevel: Int
    let timestamp: Date

    @Environment(\.colorScheme) private var colorScheme

    private var statusColor: RecoveryStatus {
        RecoveryStatus(level: statusLevel) ?? .status3
    }

    var body: some View {
        HStack(spacing: 0) {
            // Status color indicator strip
            RoundedRectangle(cornerRadius: 2)
                .fill(statusColor.main)
                .frame(width: 4)
                .padding(.vertical, AppSpacing.sm)

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                HStack {
                    Text(statusColor.emoji)
                        .font(.system(.body))

                    Text(title)
                        .font(AppTypography.heading)
                        .foregroundStyle(AppColor.textPrimary)

                    Spacer()

                    Text(timestamp, format: .relative(presentation: .named))
                        .font(AppTypography.caption)
                        .foregroundStyle(AppColor.textSecondary)
                }

                if !bodyText.isEmpty {
                    Text(bodyText)
                        .font(AppTypography.body)
                        .foregroundStyle(AppColor.textSecondary)
                        .lineLimit(3)
                }
            }
            .padding(AppSpacing.md)
        }
        .background(
            RoundedRectangle(cornerRadius: AppRadius.md)
                .fill(colorScheme == .dark ? AppColor.surfaceElevated : AppColor.background)
                .shadow(
                    color: colorScheme == .dark ? .clear : .black.opacity(0.08),
                    radius: 8, x: 0, y: 2
                )
                .overlay(
                    RoundedRectangle(cornerRadius: AppRadius.md)
                        .strokeBorder(
                            colorScheme == .dark
                                ? Color.white.opacity(0.08)
                                : Color.clear,
                            lineWidth: 1
                        )
                )
        )
        .clipShape(RoundedRectangle(cornerRadius: AppRadius.md))
    }
}

// MARK: - Gradient Background

struct GradientBackground: ViewModifier {
    let statusLevel: Int

    private var statusColor: RecoveryStatus {
        RecoveryStatus(level: statusLevel) ?? .status3
    }

    func body(content: Content) -> some View {
        content
            .background(
                LinearGradient(
                    colors: [statusColor.main.opacity(0.3), statusColor.light],
                    startPoint: .top,
                    endPoint: .bottom
                )
                .ignoresSafeArea()
            )
    }
}

extension View {
    func gradientBackground(for statusLevel: Int) -> some View {
        modifier(GradientBackground(statusLevel: statusLevel))
    }
}

#Preview("Check-In Card - Light") {
    VStack(spacing: AppSpacing.lg) {
        CheckInCard(
            title: "Morning check-in",
            bodyText: "Completed my breathing exercises. Feeling grounded and focused today.",
            statusLevel: 4,
            timestamp: Date.now.addingTimeInterval(-7200)
        )

        CheckInCard(
            title: "Afternoon urge",
            bodyText: "Experienced a craving after a stressful call. Used the CBT exercise.",
            statusLevel: 2,
            timestamp: Date.now.addingTimeInterval(-3600)
        )

        CheckInCard(
            title: "Quick check-in",
            bodyText: "",
            statusLevel: 5,
            timestamp: Date.now.addingTimeInterval(-300)
        )
    }
    .padding()
}

#Preview("Gradient Background") {
    Text("Status 4 Gradient")
        .font(AppTypography.title)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .gradientBackground(for: 4)
}
```

## Checkpoint

Before moving to the next lesson, verify every item:

- [ ] `Theme.swift` compiles with no warnings
- [ ] All five recovery status colors are visually distinct in both light and dark mode
- [ ] Brand purple renders correctly as the accent color
- [ ] Typography scales when Dynamic Type size is changed in Settings
- [ ] `StatusButton` shows the correct emoji for each recovery status (1-5)
- [ ] `StatusButton` selected state has a filled background with white text
- [ ] `StatusButton` unselected state has a border outline with colored text
- [ ] `CheckInCard` displays the color strip on the left edge
- [ ] `CheckInCard` shadow appears in light mode only; subtle border appears in dark mode only
- [ ] `CheckInCard` timestamp shows relative time ("2 hours ago", "Yesterday")
- [ ] `GradientBackground` produces a smooth vertical gradient for each recovery status level
- [ ] No hardcoded `Color(.init(red:green:blue:))` calls exist outside of `Theme.swift`
- [ ] No magic-number spacing â€” every padding and spacing value uses `AppSpacing` tokens

## Challenge

Build a `StatusPicker` view that displays all five `StatusButton` instances in a horizontal row. It should take a `@Binding` to an `Int?` representing the currently selected recovery status. Tapping a button selects it (deselecting the previous one). Tapping the already-selected button deselects it (sets the binding to `nil`). Add a subtle scale animation on selection.

<details>
<summary>Hint</summary>

Use a `ForEach` over `RecoveryStatus.allCases`. Compare each case's `rawValue` to the binding to determine `isSelected`. In the action closure, toggle the selection:

```swift
if selectedStatus == status.rawValue {
    selectedStatus = nil
} else {
    selectedStatus = status.rawValue
}
```

Wrap the state change in `withAnimation(.spring(response: 0.3, dampingFraction: 0.7))` for the scale effect, and add `.scaleEffect(isSelected ? 1.05 : 1.0)` to each `StatusButton`.
</details>
