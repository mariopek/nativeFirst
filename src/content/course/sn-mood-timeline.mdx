---
title: "Home Screen — Recovery Dashboard"
description: "Build the main dashboard view that displays recovery check-ins grouped by date, with lazy loading, relative timestamps, empty states, and pull-to-refresh."
courseSlug: "ship-native"
module: 2
moduleTitle: "Core UI with SwiftUI"
lesson: 2
duration: "24 min read"
difficulty: "intermediate"
topics: ["SwiftUI", "LazyVStack", "Dashboard", "ScrollView", "Empty State", "Loading State", "Pull-to-Refresh", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

The data layer exists. Models are defined, the service layer is wired, recovery check-ins persist. Now we build the screen users will open dozens of times a day — the recovery dashboard.

This is the home screen of BetAway. It shows every recovery check-in the user has logged, grouped by date, scrollable, and responsive. It needs to handle zero check-ins gracefully, load efficiently when there are hundreds, and refresh when the user pulls down. Get this screen right and the app feels real. Get it wrong and nothing else matters.

## What You'll Learn

By the end of this lesson you will have:

1. A `DashboardView` with a `ScrollView` and `LazyVStack` that groups recovery check-ins by date — today, yesterday, this week, and older
2. A `CheckInRow` component that displays the status indicator, emoji, note preview, and relative timestamp
3. A `DashboardViewModel` using the `@Observable` macro that fetches check-ins from the service layer and exposes loading, empty, and populated states
4. Pull-to-refresh with `.refreshable` and a proper empty state using `ContentUnavailableView`

## Why This Matters

Every social app, recovery app, and health app has a dashboard. The patterns here — lazy loading for performance, date grouping for context, empty states for first-run experience, pull-to-refresh for freshness — show up in virtually every production iOS app. Master them once and you reuse them everywhere.

The dashboard is also where performance problems surface first. A naive implementation that loads everything into a `VStack` will stutter on scroll after a few dozen check-ins. We are going to build it correctly from the start.

## Plan Phase: Defining What We Build

Open Claude Code in your BetAway project directory. Before writing any implementation code, we ask the AI to plan.

### The Prompt

```
I need to build the home screen for BetAway — a recovery dashboard
that shows all check-ins grouped by date. Before writing code, plan
the implementation.

Requirements:
- ScrollView + LazyVStack for performance (not List)
- Check-ins grouped into sections: Today, Yesterday, This Week, Older
- Each row shows: status color indicator, emoji, note preview
  (truncated to 2 lines), and a relative timestamp
- Empty state when no check-ins exist (ContentUnavailableView)
- Loading state with ProgressView on first load
- Pull-to-refresh with .refreshable
- ViewModel uses @Observable macro, fetches from RecoveryService
- RelativeDateTimeFormatter for timestamps
- Swift 6, iOS 17+

Think through:
1. What files do we need?
2. What is the data flow from service to view?
3. How do we group check-ins by date?
4. What are the edge cases?
```

### What the AI Should Return

The plan should identify three files:

- **DashboardViewModel.swift** — `@Observable` class that holds the state, fetches from `RecoveryService`, groups check-ins by date section
- **DashboardView.swift** — the main screen with `ScrollView`, `LazyVStack`, section headers, and state handling
- **CheckInRow.swift** — a reusable row component for a single recovery check-in

The data flow: `RecoveryService` returns `[CheckIn]` sorted by date descending. The ViewModel groups them into four buckets using `Calendar` date comparisons. The view switches on loading/empty/populated state and renders the appropriate UI.

Edge cases the AI should flag: empty sections should not render headers, the "This Week" section should exclude today and yesterday, timezone handling for date grouping, and the first load vs. subsequent refreshes.

### The Anti-Pattern

What you do NOT want to build:

- **`VStack` instead of `LazyVStack`** — a plain `VStack` creates every row upfront. With 200 check-ins, that means 200 views allocated on appear. `LazyVStack` only creates views as they scroll into the visible area. This is the single most common performance mistake in SwiftUI dashboard views.
- **Fetching all data with no state management** — no loading spinner on first open, no empty state, just a blank screen that eventually fills in. Users will think the app is broken.
- **Flat list with no grouping** — a wall of check-ins with no date context is disorienting. Grouping by date gives the dashboard structure and makes it scannable.

If the AI's plan includes any of these, correct it before moving to implementation.

## Execute Phase: Implementation

Now we execute. Send the implementation prompt.

### The Prompt

```
Build the recovery dashboard based on our plan. Create three files:

1. DashboardViewModel.swift
   - @Observable class
   - Properties: check-ins grouped as
     todayCheckIns, yesterdayCheckIns, thisWeekCheckIns, olderCheckIns
   - isLoading: Bool for first load
   - fetchCheckIns() method that reads from RecoveryService
   - Group check-ins using Calendar date comparisons

2. CheckInRow.swift
   - Takes a CheckIn
   - HStack layout:
     * Left: circle filled with the status color (12pt)
     * Center: VStack with emoji + note preview (2-line limit)
     * Right: relative timestamp using RelativeDateTimeFormatter
   - Compact, clean, no unnecessary padding

3. DashboardView.swift
   - NavigationStack with title "Dashboard"
   - Switch on state: loading, empty, populated
   - Loading: centered ProgressView
   - Empty: ContentUnavailableView with recovery-appropriate messaging
   - Populated: ScrollView + LazyVStack with pinned section headers
   - Each section: header label + ForEach of CheckInRow
   - .refreshable calls viewModel.fetchCheckIns()
   - .task calls fetchCheckIns() on first appear

Use RelativeDateTimeFormatter for timestamps. Follow Swift 6
conventions. Use os.Logger for errors.
```

### Reviewing the AI Output

The AI will generate all three files. Here is what to check:

**DashboardViewModel** — verify it uses `@Observable` (not `ObservableObject`), that `fetchCheckIns()` sets `isLoading` before the fetch and clears it after, and that date grouping uses `Calendar.current` methods like `isDateInToday` and `isDateInYesterday`. Common mistake: the AI might use raw date arithmetic instead of Calendar APIs — Calendar handles timezones and locale correctly, raw arithmetic does not.

**CheckInRow** — verify the layout is an `HStack`, the note preview has `.lineLimit(2)`, and the relative timestamp uses `RelativeDateTimeFormatter`. Check that the status color circle uses `.fill` style, not `.stroke`. Watch for the AI adding excessive padding or spacing — dashboard rows should be compact.

**DashboardView** — verify it uses `ScrollView` + `LazyVStack(pinnedViews: [.sectionHeaders])`, not `List`. Check that `.refreshable` does NOT wrap the call in an extra `Task` — the closure is already async. Verify the empty state uses `ContentUnavailableView`, not a custom VStack with an image.

Here is the scoring:

- The ViewModel uses `@Observable` and groups with Calendar APIs -- **correct**
- The row uses `RelativeDateTimeFormatter` -- **correct**
- The view uses `LazyVStack` with pinned headers -- **correct**
- `.refreshable` wraps in unnecessary `Task { }` -- **fix this**, the closure is already async
- Empty state uses a custom VStack instead of `ContentUnavailableView` -- **fix this**, use the system component

## Iteration

The first pass is functional but needs refinement. Send this follow-up:

```
Two fixes for the dashboard:

1. The .refreshable closure should NOT wrap in Task { }.
   The closure is already async. Remove the Task wrapper so
   SwiftUI can track when the refresh finishes and dismiss
   the spinner correctly.

2. Replace the custom empty state VStack with
   ContentUnavailableView. Use the "heart.text.clipboard"
   SF Symbol, title "No Check-Ins Yet", and description
   "Start tracking your recovery to see your dashboard."

Also add: when the view appears for the first time and
isLoading is true, show a ProgressView centered in the
screen. On subsequent refreshes (pull-to-refresh), keep
the existing check-ins visible — do not show the ProgressView
again.
```

This is the "yes, but..." pattern from Module 1. The structure is right, we are correcting details. Two minutes of prompting, and the output goes from good to production-ready.

## Verify Phase

Build and run in the simulator. Check each state:

1. **First launch (no check-ins)** — you should see the `ContentUnavailableView` with the clipboard icon and "No Check-Ins Yet" message. Not a blank screen. Not a spinner that never stops.

2. **Add a check-in from another screen, come back** — pull to refresh. The check-in should appear under the "Today" section with the correct emoji, note preview, and a relative timestamp like "Just now" or "2 minutes ago."

3. **Add several check-ins across multiple days** (adjust device date or seed test data) — verify that grouping works. Today's check-ins under "Today," yesterday's under "Yesterday," check-ins from earlier this week under "This Week," everything else under "Older." Empty sections should not show headers.

4. **Scroll performance** — add 50+ check-ins (seed them in the service for testing). Scroll quickly up and down. The dashboard should be smooth with no frame drops. If you see stuttering, verify you are using `LazyVStack` and not `VStack`.

5. **Pull-to-refresh** — pull down on the dashboard. The system refresh spinner should appear, the data should reload, and the spinner should dismiss when the fetch completes. If the spinner hangs indefinitely, check for the `Task { }` wrapper bug mentioned above.

## Final Code

Three files. Copy these into your project.

### DashboardViewModel.swift

```swift
import Foundation
import os

@Observable
final class DashboardViewModel {
    private(set) var todayCheckIns: [CheckIn] = []
    private(set) var yesterdayCheckIns: [CheckIn] = []
    private(set) var thisWeekCheckIns: [CheckIn] = []
    private(set) var olderCheckIns: [CheckIn] = []
    private(set) var isLoading = true

    private let service: RecoveryService
    private let calendar = Calendar.current
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "DashboardViewModel")

    var isEmpty: Bool {
        todayCheckIns.isEmpty
            && yesterdayCheckIns.isEmpty
            && thisWeekCheckIns.isEmpty
            && olderCheckIns.isEmpty
    }

    init(service: RecoveryService) {
        self.service = service
    }

    func fetchCheckIns() async {
        do {
            let allCheckIns = try await service.fetchAll()
            groupCheckIns(allCheckIns)
            logger.debug("Loaded \(allCheckIns.count) recovery check-ins")
        } catch {
            logger.error("Failed to fetch check-ins: \(error.localizedDescription)")
        }

        isLoading = false
    }

    private func groupCheckIns(_ checkIns: [CheckIn]) {
        let now = Date.now
        let startOfToday = calendar.startOfDay(for: now)

        guard let startOfYesterday = calendar.date(byAdding: .day, value: -1, to: startOfToday),
              let startOfWeek = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: now))
        else {
            todayCheckIns = checkIns
            return
        }

        var today: [CheckIn] = []
        var yesterday: [CheckIn] = []
        var thisWeek: [CheckIn] = []
        var older: [CheckIn] = []

        for checkIn in checkIns {
            if calendar.isDateInToday(checkIn.createdAt) {
                today.append(checkIn)
            } else if calendar.isDateInYesterday(checkIn.createdAt) {
                yesterday.append(checkIn)
            } else if checkIn.createdAt >= startOfWeek {
                thisWeek.append(checkIn)
            } else {
                older.append(checkIn)
            }
        }

        todayCheckIns = today.sorted { $0.createdAt > $1.createdAt }
        yesterdayCheckIns = yesterday.sorted { $0.createdAt > $1.createdAt }
        thisWeekCheckIns = thisWeek.sorted { $0.createdAt > $1.createdAt }
        olderCheckIns = older.sorted { $0.createdAt > $1.createdAt }
    }
}
```

A few things worth noting.

**`private(set)` on the check-in arrays.** The view can read them, but only the ViewModel can mutate them. This prevents accidental writes from the view layer.

**`Calendar.current` for all date logic.** We use `isDateInToday`, `isDateInYesterday`, and `startOfDay` — these handle timezones and locale automatically. Never do `Date().timeIntervalSince(checkIn.createdAt) < 86400` — that breaks across DST transitions and timezone changes.

**The `startOfWeek` calculation** uses `dateComponents([.yearForWeekOfYear, .weekOfYear])`. This respects the user's locale — the week starts on Monday in Europe and Sunday in the US. The Calendar handles it.

**`isLoading` starts as `true`** and gets set to `false` after the first fetch completes. On subsequent fetches (pull-to-refresh), `isLoading` stays `false` so the existing content remains visible.

### CheckInRow.swift

```swift
import SwiftUI

struct CheckInRow: View {
    let checkIn: CheckIn

    private var relativeTimestamp: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: checkIn.createdAt, relativeTo: .now)
    }

    var body: some View {
        HStack(spacing: 12) {
            Circle()
                .fill(checkIn.status.color)
                .frame(width: 12, height: 12)

            VStack(alignment: .leading, spacing: 2) {
                Text(checkIn.status.emoji)
                    .font(.title3)

                if !checkIn.note.isEmpty {
                    Text(checkIn.note)
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .lineLimit(2)
                }
            }

            Spacer()

            Text(relativeTimestamp)
                .font(.caption)
                .foregroundStyle(.tertiary)
        }
        .padding(.vertical, 6)
    }
}

#Preview {
    List {
        CheckInRow(
            checkIn: CheckIn(
                status: .strong,
                note: "Completed my morning breathing exercises. Feeling grounded and focused.",
                createdAt: Date.now.addingTimeInterval(-3600)
            )
        )
        CheckInRow(
            checkIn: CheckIn(
                status: .struggling,
                note: "",
                createdAt: Date.now.addingTimeInterval(-7200)
            )
        )
    }
}
```

**`RelativeDateTimeFormatter`** gives you localized strings like "2 hr. ago", "yesterday", "3 min. ago" — all without manual date math. The `.short` units style keeps the label compact, which is what you want in a row. Do not build this yourself. Apple already did the work, and it handles every locale.

**The note is optional in display.** If the check-in has no note, the `Text` does not render at all. No blank space, no "No note" placeholder. Clean.

**`.foregroundStyle(.tertiary)`** for the timestamp. This is lighter than `.secondary` — the timestamp is metadata, not content. It should be visible but not compete with the status indicator and note for attention.

### DashboardView.swift

```swift
import SwiftUI

struct DashboardView: View {
    @State private var viewModel: DashboardViewModel

    init(service: RecoveryService) {
        _viewModel = State(
            initialValue: DashboardViewModel(service: service)
        )
    }

    var body: some View {
        NavigationStack {
            Group {
                if viewModel.isLoading {
                    loadingView
                } else if viewModel.isEmpty {
                    emptyView
                } else {
                    dashboardContent
                }
            }
            .navigationTitle("Dashboard")
            .task {
                await viewModel.fetchCheckIns()
            }
        }
    }

    // MARK: - Loading State

    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .controlSize(.large)
            Text("Loading check-ins...")
                .font(.subheadline)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: - Empty State

    private var emptyView: some View {
        ContentUnavailableView(
            "No Check-Ins Yet",
            systemImage: "heart.text.clipboard",
            description: Text("Start tracking your recovery to see your dashboard.")
        )
    }

    // MARK: - Dashboard Content

    private var dashboardContent: some View {
        ScrollView {
            LazyVStack(alignment: .leading, spacing: 0, pinnedViews: [.sectionHeaders]) {
                dashboardSection("Today", checkIns: viewModel.todayCheckIns)
                dashboardSection("Yesterday", checkIns: viewModel.yesterdayCheckIns)
                dashboardSection("This Week", checkIns: viewModel.thisWeekCheckIns)
                dashboardSection("Older", checkIns: viewModel.olderCheckIns)
            }
        }
        .refreshable {
            await viewModel.fetchCheckIns()
        }
    }

    // MARK: - Section Builder

    @ViewBuilder
    private func dashboardSection(_ title: String, checkIns: [CheckIn]) -> some View {
        if !checkIns.isEmpty {
            Section {
                ForEach(checkIns) { checkIn in
                    CheckInRow(checkIn: checkIn)
                        .padding(.horizontal)
                }
            } header: {
                Text(title)
                    .font(.headline)
                    .foregroundStyle(.primary)
                    .padding(.horizontal)
                    .padding(.vertical, 8)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(.regularMaterial)
            }
        }
    }
}

#Preview {
    DashboardView(service: RecoveryService())
}
```

Let me walk through the key decisions.

**`LazyVStack(pinnedViews: [.sectionHeaders])`** — this pins section headers to the top of the scroll view as you scroll past them, just like `UITableView`'s plain-style section headers. Users see which date group they are in at all times. Without `pinnedViews`, the headers scroll away and the user loses context.

**The `@ViewBuilder` helper function.** Instead of repeating the section layout four times, `dashboardSection(_:checkIns:)` takes a title and array and builds the section. If the array is empty, `@ViewBuilder` returns `EmptyView` — no header renders for empty sections. This keeps the main body clean and eliminates duplication.

**`.refreshable` is directly on `ScrollView`.** The closure is `async` — no `Task { }` wrapper. SwiftUI manages the refresh indicator lifecycle. When `fetchCheckIns()` completes, the spinner dismisses automatically. Wrapping in `Task` breaks this contract and can cause the spinner to dismiss before the fetch finishes.

**`.task` for initial load.** The `.task` modifier fires once when the view appears and cancels automatically if the view disappears before it completes. This is the correct place for initial data loading — not `onAppear` with a manual `Task { }`.

**`.background(.regularMaterial)`** on the section header. This gives the pinned header a frosted glass effect so content scrolling underneath is blurred rather than overlapping with the header text. It matches the iOS system aesthetic.

## Checkpoint

Before moving to the next lesson, verify:

- [ ] Dashboard shows grouped check-ins under Today, Yesterday, This Week, and Older
- [ ] Empty sections do not render headers
- [ ] First launch with no data shows `ContentUnavailableView` with "No Check-Ins Yet"
- [ ] First launch shows `ProgressView` while check-ins load
- [ ] Pull-to-refresh triggers a reload and the spinner dismisses when done
- [ ] Relative timestamps display correctly ("2 min. ago", "1 hr. ago")
- [ ] Scrolling 50+ check-ins is smooth with no stuttering
- [ ] Section headers pin to the top during scroll

## Challenge

**Add a date label to the "Older" section rows.**

Right now, check-ins in the "Older" section show a relative timestamp like "2 weeks ago" — but once check-ins are more than a week old, relative timestamps lose precision. "2 weeks ago" could mean 8 days or 14 days.

Modify `CheckInRow` to accept an optional `showFullDate` parameter (default `false`). When `true`, display the full date (e.g., "Feb 10, 2026") instead of the relative timestamp. Then update `DashboardView` to pass `showFullDate: true` for check-ins in the "Older" section.

**Hint:** You will need to update the `dashboardSection` helper to accept a boolean and forward it to each `CheckInRow`. Use `.formatted(.dateTime.month(.abbreviated).day().year())` for the full date format.
