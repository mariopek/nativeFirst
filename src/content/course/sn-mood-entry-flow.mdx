---
title: "Check-In Flow"
description: "Create the multi-step recovery check-in experience with a custom status slider, emoji picker, text input, and tag selection ‚Äî complete with haptic feedback and smooth animations."
courseSlug: "ship-native"
module: 2
moduleTitle: "Core UI with SwiftUI"
lesson: 3
duration: "26 min read"
difficulty: "intermediate"
topics: ["SwiftUI", "Multi-Step Form", "Custom Slider", "Haptic Feedback", "Animation", "User Input", "UX Design", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

The dashboard shows existing check-ins. The design system makes them look consistent. Now we build the screen where users actually create a recovery check-in ‚Äî the single most important interaction in BetAway.

This is not a simple form. A recovery check-in is a vulnerable moment. The user is pausing their day to reflect on their progress and urges. The UX needs to respect that. It should feel smooth, guided, and supportive ‚Äî not like filling out a survey. We are going to build a multi-step flow with a custom slider, emoji picker, free-text input, tag selection, haptic feedback at every transition, and animations that make each step feel intentional.

## What You'll Learn

- How to architect a multi-step form with discrete steps and animated transitions
- Building a custom `RecoverySlider` with a gradient track and haptic feedback on each level
- Creating an `EmojiPicker` grid for quick status association
- Managing form state and validation with a dedicated ViewModel
- Handling keyboard appearance with the `.focused` modifier
- Wiring the save action through the service layer pattern
- Prompting AI for complex, multi-file features using the Plan-Execute-Verify workflow

## Why This Matters

Most recovery apps use a single screen with a basic slider and a text field. It works, but it feels clinical. Users log one check-in and never come back.

The multi-step approach solves this. Each step is focused ‚Äî one decision at a time. The user never feels overwhelmed. The haptic feedback and animations create a tactile loop that makes the interaction feel supportive. And the tag selection at the end gives structure to the check-in without requiring effort.

This pattern applies far beyond recovery tracking. Onboarding flows, checkout processes, survey experiences ‚Äî any time you need to collect multiple pieces of input from a user, a stepped flow with transitions and feedback will outperform a single monolithic form.

## Plan Phase: Defining What We Build

Before we touch any code, we need a plan. Open Claude Code in the BetAway project and send this:

```
I need to build the check-in flow for BetAway ‚Äî a multi-step
form that lets users log their recovery status. Before writing code,
help me plan the architecture.

The flow has four steps:
1. Recovery Status ‚Äî a custom slider from 1 (crisis) to 5 (thriving),
   with a gradient track and haptic feedback when the value changes
2. Emoji ‚Äî a grid of emoji options that map to recovery states
   (hopeful, struggling, anxious, calm, determined, tired, etc.)
3. Note ‚Äî a free-text field where the user can write about their
   recovery progress, with keyboard handling
4. Tags ‚Äî a selectable grid of predefined tags like "Urge",
   "Exercise", "Therapy", "Trigger", "Sleep", "Support Group"

Requirements:
- Each step has a "Next" button and a "Back" button
- Step 4 has a "Save" button instead of "Next"
- Smooth horizontal slide transition between steps
- The flow is presented as a sheet from the dashboard
- State is managed by a CheckInFlowViewModel (@Observable)
- Save goes through the RecoveryService

Think through:
1. What files do we need?
2. What state does the ViewModel manage?
3. How do we handle step transitions and validation?
4. What are the edge cases?

Give me the plan, no code yet.
```

Claude Code will come back with a file breakdown and architecture sketch. Review it. The pieces we need are:

- **CheckInFlowView.swift** ‚Äî the container that manages step transitions
- **CheckInFlowViewModel.swift** ‚Äî all form state, validation, and save logic
- **RecoverySlider.swift** ‚Äî the custom slider component for step 1
- **EmojiPicker.swift** ‚Äî the emoji grid component for step 2

Steps 3 and 4 are simple enough to live inside `CheckInFlowView` as inline sections. No need to extract them into separate files unless they grow.

### The Anti-Pattern: One Giant Form

Here is what happens when you skip the planning step and just prompt "build a check-in form":

```swift
// What AI generates without guidance ‚Äî do NOT do this
struct CheckInFlowView: View {
    @State private var statusLevel: Double = 3
    @State private var emoji = ""
    @State private var note = ""
    @State private var tags: [String] = []

    var body: some View {
        Form {
            Section("Recovery Status") {
                Slider(value: $statusLevel, in: 1...5, step: 1)
            }
            Section("Emoji") {
                TextField("Pick an emoji", text: $emoji)
            }
            Section("Note") {
                TextEditor(text: $note)
            }
            Section("Tags") {
                // 15 toggles in a row...
            }
            Button("Save") { /* save everything */ }
        }
    }
}
```

This is the default AI output for "build a form." It is a single scrolling view with every input crammed together. No steps. No transitions. No haptic feedback. The slider is a stock `Slider` ‚Äî no gradient, no personality. The emoji input is a `TextField` where the user has to type an emoji. The keyboard covers the note field. There is no validation.

It compiles. It "works." But no user would enjoy using it, and no one would come back to it a second time.

The difference between this and what we are going to build is the plan. Let us execute it.

## Execute Phase: Implementation

Now we build. We are going to send one focused prompt per file, review the output, and iterate where needed.

### CheckInFlowViewModel

The ViewModel comes first. It owns all the state, so every view depends on it.

```
Create CheckInFlowViewModel.swift for the BetAway check-in flow.

This is an @Observable class that manages a 4-step recovery check-in form.

State:
- currentStep: Int (1 through 4)
- statusLevel: Int (1 through 5, default 3)
- selectedEmoji: String? (optional, a single emoji character)
- noteText: String (default empty)
- selectedTags: Set<String>
- isSaving: Bool (default false)

Available tags (static let):
["Urge", "Exercise", "Therapy", "Trigger", "Sleep", "Support Group",
 "Finances", "Health", "Mindfulness", "CBT Exercise", "Relax", "Stress"]

Computed:
- canAdvance: Bool ‚Äî step 1 always true, step 2 requires an emoji,
  step 3 always true, step 4 always true
- isFirstStep: Bool
- isLastStep: Bool
- stepTitle: String ‚Äî "How are you doing?", "Pick an emoji",
  "Add a note", "Add tags"
- stepSubtitle: String ‚Äî short description for each step

Methods:
- advance() ‚Äî go to next step if canAdvance
- goBack() ‚Äî go to previous step
- save(using service: RecoveryService) async ‚Äî creates a
  CheckIn from the current state and saves via service.
  Sets isSaving during the operation.
- reset() ‚Äî clears all state back to defaults

Use Swift 6 conventions. Do not import UIKit.
```

Here is what Claude Code generates. Let me walk through the review.

```swift
import Foundation
import os

@Observable
final class CheckInFlowViewModel {
    // MARK: - Step State

    var currentStep = 1
    let totalSteps = 4

    // MARK: - Form State

    var statusLevel = 3
    var selectedEmoji: String?
    var noteText = ""
    var selectedTags: Set<String> = []
    var isSaving = false

    // MARK: - Constants

    static let availableTags = [
        "Urge", "Exercise", "Therapy", "Trigger", "Sleep", "Support Group",
        "Finances", "Health", "Mindfulness", "CBT Exercise", "Relax", "Stress"
    ]

    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "CheckIn")

    // MARK: - Computed Properties

    var canAdvance: Bool {
        switch currentStep {
        case 1: true
        case 2: selectedEmoji != nil
        case 3: true
        case 4: true
        default: false
        }
    }

    var isFirstStep: Bool { currentStep == 1 }
    var isLastStep: Bool { currentStep == totalSteps }

    var stepTitle: String {
        switch currentStep {
        case 1: "How are you doing?"
        case 2: "Pick an emoji"
        case 3: "Add a note"
        case 4: "Add tags"
        default: ""
        }
    }

    var stepSubtitle: String {
        switch currentStep {
        case 1: "Slide to match your current state"
        case 2: "Choose one that fits"
        case 3: "Optional ‚Äî write anything"
        case 4: "Optional ‚Äî what's on your mind?"
        default: ""
        }
    }

    // MARK: - Actions

    func advance() {
        guard canAdvance, currentStep < totalSteps else { return }
        currentStep += 1
    }

    func goBack() {
        guard currentStep > 1 else { return }
        currentStep -= 1
    }

    func save(using service: RecoveryService) async {
        isSaving = true
        defer { isSaving = false }

        let checkIn = CheckIn(
            statusLevel: statusLevel,
            emoji: selectedEmoji ?? "üòê",
            note: noteText.trimmingCharacters(in: .whitespacesAndNewlines),
            tags: Array(selectedTags),
            createdAt: .now
        )

        do {
            try await service.save(checkIn)
            logger.info("Check-in saved: status \(self.statusLevel)")
        } catch {
            logger.error("Failed to save check-in: \(error.localizedDescription)")
        }
    }

    func reset() {
        currentStep = 1
        statusLevel = 3
        selectedEmoji = nil
        noteText = ""
        selectedTags = []
        isSaving = false
    }
}
```

**Review:**

- ‚úÖ `@Observable` with `final class` ‚Äî correct modern pattern, not `ObservableObject`
- ‚úÖ `Logger` instead of `print()` ‚Äî follows our CLAUDE.md
- ‚úÖ `canAdvance` uses a clean switch ‚Äî step 2 requires emoji selection, others are permissive
- ‚úÖ `save` is async with `defer` for `isSaving` ‚Äî ensures the flag resets even on error
- ‚úÖ `reset()` clears everything ‚Äî we call this after a successful save or on dismiss
- ‚úÖ Note text is trimmed before saving ‚Äî good defensive code
- ‚ö†Ô∏è The fallback emoji `"üòê"` in `save` is a reasonable default, but we should ensure the UI prevents reaching save without an emoji. Our `canAdvance` on step 2 handles this, so the fallback is just a safety net. Acceptable.

This ViewModel is clean. No iteration needed. Let us move to the custom slider.

### RecoverySlider

This is the centerpiece of step 1. A stock `Slider` will not do ‚Äî we need a gradient track that shifts color based on the recovery status and haptic feedback on each discrete stop.

```
Create RecoverySlider.swift ‚Äî a custom SwiftUI slider for selecting
a recovery status from 1 to 5.

Requirements:
- Horizontal track with rounded ends
- Track fills with a gradient that shifts based on the current value:
  level 1 = deep blue/indigo, level 3 = yellow, level 5 = green
- A circular thumb that shows the current level number
- The thumb snaps to discrete values (1, 2, 3, 4, 5) ‚Äî no
  in-between values
- Trigger UIImpactFeedbackGenerator (.light) when the value
  changes to a new level
- A row of labels below the track: "Crisis", "Struggling",
  "Stable", "Strong", "Thriving"
- Use a DragGesture for the interaction, not a Slider view
- Binding to an Int value

The component should be self-contained and reusable.
Target iOS 17+. Use GeometryReader for track width calculation.
```

```swift
import SwiftUI
import UIKit

struct RecoverySlider: View {
    @Binding var value: Int

    private let range = 1...5
    private let labels = ["Crisis", "Struggling", "Stable", "Strong", "Thriving"]
    private let thumbSize: CGFloat = 44

    @State private var isDragging = false

    var body: some View {
        VStack(spacing: 16) {
            GeometryReader { geometry in
                let trackWidth = geometry.size.width - thumbSize
                let stepWidth = trackWidth / CGFloat(range.count - 1)
                let thumbOffset = CGFloat(value - range.lowerBound) * stepWidth

                ZStack(alignment: .leading) {
                    // Background track
                    Capsule()
                        .fill(Color(.systemGray5))
                        .frame(height: 8)
                        .padding(.horizontal, thumbSize / 2)

                    // Filled track with gradient
                    Capsule()
                        .fill(trackGradient)
                        .frame(width: thumbOffset + thumbSize / 2, height: 8)
                        .padding(.leading, thumbSize / 2)

                    // Thumb
                    Circle()
                        .fill(.white)
                        .shadow(color: .black.opacity(0.15), radius: 4, y: 2)
                        .frame(width: thumbSize, height: thumbSize)
                        .overlay {
                            Text("\(value)")
                                .font(.system(.title3, design: .rounded, weight: .bold))
                                .foregroundStyle(thumbColor)
                        }
                        .scaleEffect(isDragging ? 1.1 : 1.0)
                        .offset(x: thumbOffset)
                        .gesture(
                            DragGesture(minimumDistance: 0)
                                .onChanged { gesture in
                                    isDragging = true
                                    let newValue = calculateValue(
                                        from: gesture.location.x,
                                        trackWidth: trackWidth,
                                        stepWidth: stepWidth
                                    )
                                    if newValue != value {
                                        value = newValue
                                        triggerHaptic()
                                    }
                                }
                                .onEnded { _ in
                                    isDragging = false
                                }
                        )
                }
                .frame(height: thumbSize)
            }
            .frame(height: thumbSize)

            // Labels
            HStack {
                ForEach(Array(labels.enumerated()), id: \.offset) { index, label in
                    Text(label)
                        .font(.caption2)
                        .fontWeight(index + 1 == value ? .semibold : .regular)
                        .foregroundStyle(index + 1 == value ? thumbColor : .secondary)
                        .frame(maxWidth: .infinity)
                }
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: value)
        .animation(.spring(response: 0.2, dampingFraction: 0.6), value: isDragging)
    }

    // MARK: - Gradient

    private var trackGradient: LinearGradient {
        LinearGradient(
            colors: [.indigo, .blue, .yellow, .orange, .green],
            startPoint: .leading,
            endPoint: .trailing
        )
    }

    private var thumbColor: Color {
        switch value {
        case 1: .indigo
        case 2: .blue
        case 3: .yellow.opacity(0.9)
        case 4: .orange
        case 5: .green
        default: .gray
        }
    }

    // MARK: - Helpers

    private func calculateValue(
        from locationX: CGFloat,
        trackWidth: CGFloat,
        stepWidth: CGFloat
    ) -> Int {
        let clamped = min(max(locationX - thumbSize / 2, 0), trackWidth)
        let rawValue = Int(round(clamped / stepWidth)) + range.lowerBound
        return min(max(rawValue, range.lowerBound), range.upperBound)
    }

    private func triggerHaptic() {
        let generator = UIImpactFeedbackGenerator(style: .light)
        generator.impactOccurred()
    }
}

#Preview {
    @Previewable @State var status = 3
    RecoverySlider(value: $status)
        .padding(32)
}
```

**Review:**

- ‚úÖ Uses `DragGesture` instead of stock `Slider` ‚Äî full control over appearance and behavior
- ‚úÖ Discrete snapping ‚Äî `calculateValue` rounds to the nearest integer, no in-between values
- ‚úÖ Haptic feedback on every level change ‚Äî `triggerHaptic()` fires only when `newValue != value`
- ‚úÖ Gradient track fills proportionally ‚Äî the `Capsule` width grows with the thumb offset
- ‚úÖ Labels highlight the current selection with matching color and weight
- ‚úÖ Spring animations on thumb scale and position ‚Äî satisfying feel
- ‚úÖ Thumb meets the 44pt minimum tap target
- ‚ö†Ô∏è We import `UIKit` for `UIImpactFeedbackGenerator`. There is no pure SwiftUI haptic API that covers this use case. The iOS 17 `.sensoryFeedback` modifier is tied to value changes on views, not programmatic triggers during gestures. UIKit is the right call here.

### EmojiPicker

Step 2 needs a grid of emojis the user can tap to associate with their recovery status.

```
Create EmojiPicker.swift ‚Äî a grid of emoji options for the BetAway
check-in flow.

Requirements:
- Display a grid of emojis in a LazyVGrid with 4 columns
- Emojis: üòä üòî üò∞ üòå ‚ö° üò¥ üò° ü•∞ üòÇ ü§î üò¢ üéâ
- Each emoji is a tappable circle that highlights when selected
- Only one emoji can be selected at a time
- Binding to an optional String
- Selected state: emoji scales up slightly and gets a colored
  background ring
- Trigger UISelectionFeedbackGenerator when selection changes
- The component should be self-contained and reusable

Target iOS 17+.
```

```swift
import SwiftUI
import UIKit

struct EmojiPicker: View {
    @Binding var selection: String?

    private let emojis = [
        "üòä", "üòî", "üò∞", "üòå",
        "‚ö°", "üò¥", "üò°", "ü•∞",
        "üòÇ", "ü§î", "üò¢", "üéâ"
    ]

    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 12),
        count: 4
    )

    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(emojis, id: \.self) { emoji in
                let isSelected = selection == emoji

                Button {
                    if selection == emoji {
                        selection = nil
                    } else {
                        selection = emoji
                        triggerHaptic()
                    }
                } label: {
                    Text(emoji)
                        .font(.system(size: 36))
                        .frame(width: 64, height: 64)
                        .background(
                            Circle()
                                .fill(isSelected ? Color.accentColor.opacity(0.15) : Color(.systemGray6))
                        )
                        .overlay(
                            Circle()
                                .strokeBorder(
                                    isSelected ? Color.accentColor : .clear,
                                    lineWidth: 2.5
                                )
                        )
                        .scaleEffect(isSelected ? 1.1 : 1.0)
                }
                .buttonStyle(.plain)
                .accessibilityLabel(accessibilityName(for: emoji))
            }
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.7), value: selection)
    }

    private func triggerHaptic() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }

    private func accessibilityName(for emoji: String) -> String {
        switch emoji {
        case "üòä": "Happy"
        case "üòî": "Sad"
        case "üò∞": "Anxious"
        case "üòå": "Calm"
        case "‚ö°": "Energized"
        case "üò¥": "Tired"
        case "üò°": "Angry"
        case "ü•∞": "Loved"
        case "üòÇ": "Amused"
        case "ü§î": "Thoughtful"
        case "üò¢": "Tearful"
        case "üéâ": "Excited"
        default: emoji
        }
    }
}

#Preview {
    @Previewable @State var selected: String?
    EmojiPicker(selection: $selected)
        .padding()
}
```

**Review:**

- ‚úÖ `LazyVGrid` with 4 columns ‚Äî clean grid layout
- ‚úÖ Single selection with toggle-off ‚Äî tapping a selected emoji deselects it
- ‚úÖ Accessibility labels ‚Äî VoiceOver reads "Happy" instead of a raw emoji codepoint
- ‚úÖ `UISelectionFeedbackGenerator` ‚Äî the lighter, "tick" haptic that matches selection actions
- ‚úÖ Spring animation on selection ‚Äî the scale and ring feel responsive
- ‚úÖ 64pt tap targets ‚Äî exceeds the 44pt minimum
- ‚ùå Missing: the accessibility label should include the selected state. A VoiceOver user should hear "Happy, selected" when an emoji is chosen.

That last point is worth an iteration.

## Iteration

```
In EmojiPicker.swift, update the accessibility so that VoiceOver
announces "Happy, selected" when an emoji is chosen. Add
.accessibilityAddTraits(.isSelected) when isSelected is true.
```

The fix is two lines inside the `Button` label:

```swift
.accessibilityLabel(accessibilityName(for: emoji))
.accessibilityAddTraits(isSelected ? .isSelected : [])
```

Small change, big impact for accessibility. This is the kind of detail that AI misses in the first pass but handles perfectly when you point it out.

### CheckInFlowView ‚Äî The Container

Now we assemble everything. This is the view that manages the step transitions and calls into the ViewModel.

```
Create CheckInFlowView.swift ‚Äî the container for the BetAway
check-in flow. It is presented as a sheet.

Requirements:
- Takes a RecoveryService as a parameter for saving
- Creates a @State CheckInFlowViewModel
- Shows a navigation bar with "X" dismiss button, step indicator
  (e.g., "Step 2 of 4"), and the step title
- Content area switches between 4 steps based on
  viewModel.currentStep:
  Step 1: RecoverySlider bound to viewModel.statusLevel
  Step 2: EmojiPicker bound to viewModel.selectedEmoji
  Step 3: TextEditor for viewModel.noteText with placeholder,
          using @FocusState for keyboard management
  Step 4: Tag grid ‚Äî a LazyVGrid of toggleable capsule buttons
          from CheckInFlowViewModel.availableTags, binding to
          viewModel.selectedTags
- Footer with Back and Next/Save buttons
- Step transitions use .asymmetric transition: slide in from
  trailing, slide out to leading (forward), reverse for back
- Animate transitions with .easeInOut(duration: 0.25)
- "Save" button calls viewModel.save and dismisses on success
- Disable "Next" when viewModel.canAdvance is false
- Show a ProgressView overlay when viewModel.isSaving

Use @Environment(\.dismiss). Use .focused modifier for the
note text field. Trigger a success haptic on save.
```

```swift
import SwiftUI
import UIKit

struct CheckInFlowView: View {
    let service: RecoveryService

    @Environment(\.dismiss) private var dismiss
    @State private var viewModel = CheckInFlowViewModel()
    @FocusState private var isNoteFieldFocused: Bool
    @State private var direction: NavigationDirection = .forward

    enum NavigationDirection {
        case forward, backward
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Step indicator
                stepHeader

                // Content
                ZStack {
                    stepContent
                        .id(viewModel.currentStep)
                        .transition(stepTransition)
                }
                .frame(maxHeight: .infinity)
                .animation(.easeInOut(duration: 0.25), value: viewModel.currentStep)

                // Footer buttons
                footerButtons
            }
            .navigationTitle(viewModel.stepTitle)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .symbolRenderingMode(.hierarchical)
                            .foregroundStyle(.secondary)
                            .font(.title3)
                    }
                }

                ToolbarItem(placement: .principal) {
                    Text("Step \(viewModel.currentStep) of \(viewModel.totalSteps)")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
            .overlay {
                if viewModel.isSaving {
                    Color.black.opacity(0.2)
                        .ignoresSafeArea()
                        .overlay { ProgressView() }
                }
            }
            .interactiveDismissDisabled(viewModel.isSaving)
        }
    }

    // MARK: - Step Header

    private var stepHeader: some View {
        VStack(spacing: 4) {
            // Progress bar
            GeometryReader { geometry in
                let progress = CGFloat(viewModel.currentStep) / CGFloat(viewModel.totalSteps)
                ZStack(alignment: .leading) {
                    Capsule()
                        .fill(Color(.systemGray5))
                    Capsule()
                        .fill(Color.accentColor)
                        .frame(width: geometry.size.width * progress)
                }
            }
            .frame(height: 4)
            .padding(.horizontal)
            .animation(.easeInOut(duration: 0.25), value: viewModel.currentStep)

            Text(viewModel.stepSubtitle)
                .font(.subheadline)
                .foregroundStyle(.secondary)
                .padding(.top, 8)
        }
        .padding(.top, 8)
    }

    // MARK: - Step Content

    @ViewBuilder
    private var stepContent: some View {
        switch viewModel.currentStep {
        case 1:
            statusLevelStep
        case 2:
            emojiStep
        case 3:
            noteStep
        case 4:
            tagsStep
        default:
            EmptyView()
        }
    }

    private var statusLevelStep: some View {
        VStack {
            Spacer()
            RecoverySlider(value: $viewModel.statusLevel)
                .padding(.horizontal, 32)
            Spacer()
        }
    }

    private var emojiStep: some View {
        VStack {
            Spacer()
            EmojiPicker(selection: $viewModel.selectedEmoji)
                .padding(.horizontal, 24)
            Spacer()
        }
    }

    private var noteStep: some View {
        VStack(alignment: .leading, spacing: 12) {
            ZStack(alignment: .topLeading) {
                if viewModel.noteText.isEmpty {
                    Text("What's on your mind?")
                        .foregroundStyle(.tertiary)
                        .padding(.top, 8)
                        .padding(.leading, 5)
                }

                TextEditor(text: $viewModel.noteText)
                    .focused($isNoteFieldFocused)
                    .scrollContentBackground(.hidden)
                    .frame(minHeight: 120)
            }
            .padding()
            .background(Color(.systemGray6), in: RoundedRectangle(cornerRadius: 12))

            Text("\(viewModel.noteText.count)/280")
                .font(.caption)
                .foregroundStyle(.secondary)
                .frame(maxWidth: .infinity, alignment: .trailing)
        }
        .padding(.horizontal, 24)
        .padding(.top, 24)
        .onAppear { isNoteFieldFocused = true }
        .onDisappear { isNoteFieldFocused = false }
    }

    private var tagsStep: some View {
        let columns = Array(repeating: GridItem(.flexible(), spacing: 10), count: 3)

        return ScrollView {
            LazyVGrid(columns: columns, spacing: 10) {
                ForEach(CheckInFlowViewModel.availableTags, id: \.self) { tag in
                    let isSelected = viewModel.selectedTags.contains(tag)

                    Button {
                        if isSelected {
                            viewModel.selectedTags.remove(tag)
                        } else {
                            viewModel.selectedTags.insert(tag)
                            triggerSelectionHaptic()
                        }
                    } label: {
                        Text(tag)
                            .font(.subheadline)
                            .fontWeight(isSelected ? .semibold : .regular)
                            .foregroundStyle(isSelected ? .white : .primary)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(
                                isSelected ? Color.accentColor : Color(.systemGray6),
                                in: Capsule()
                            )
                    }
                    .buttonStyle(.plain)
                    .accessibilityAddTraits(isSelected ? .isSelected : [])
                }
            }
            .padding(.horizontal, 24)
            .padding(.top, 24)
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.8), value: viewModel.selectedTags)
    }

    // MARK: - Transition

    private var stepTransition: AnyTransition {
        switch direction {
        case .forward:
            .asymmetric(
                insertion: .move(edge: .trailing).combined(with: .opacity),
                removal: .move(edge: .leading).combined(with: .opacity)
            )
        case .backward:
            .asymmetric(
                insertion: .move(edge: .leading).combined(with: .opacity),
                removal: .move(edge: .trailing).combined(with: .opacity)
            )
        }
    }

    // MARK: - Footer

    private var footerButtons: some View {
        HStack(spacing: 16) {
            if !viewModel.isFirstStep {
                Button {
                    direction = .backward
                    isNoteFieldFocused = false
                    viewModel.goBack()
                } label: {
                    Label("Back", systemImage: "chevron.left")
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 14)
                }
                .buttonStyle(.bordered)
                .tint(.secondary)
            }

            Button {
                if viewModel.isLastStep {
                    saveEntry()
                } else {
                    direction = .forward
                    isNoteFieldFocused = false
                    viewModel.advance()
                }
            } label: {
                Group {
                    if viewModel.isLastStep {
                        Label("Save", systemImage: "checkmark")
                    } else {
                        Label("Next", systemImage: "chevron.right")
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 14)
            }
            .buttonStyle(.borderedProminent)
            .disabled(!viewModel.canAdvance || viewModel.isSaving)
        }
        .padding(.horizontal, 24)
        .padding(.vertical, 16)
        .background(.bar)
    }

    // MARK: - Actions

    private func saveEntry() {
        Task {
            await viewModel.save(using: service)
            if !viewModel.isSaving {
                triggerSuccessHaptic()
                dismiss()
            }
        }
    }

    private func triggerSelectionHaptic() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }

    private func triggerSuccessHaptic() {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.success)
    }
}

#Preview {
    CheckInFlowView(service: PreviewRecoveryService())
}
```

**Review:**

- ‚úÖ Step transitions use `.asymmetric` with direction tracking ‚Äî sliding forward goes left-to-right, backward goes right-to-left
- ‚úÖ `.id(viewModel.currentStep)` forces SwiftUI to re-render the content area, which triggers the transition
- ‚úÖ `@FocusState` for keyboard management ‚Äî the note field auto-focuses on appear and dismisses on navigation
- ‚úÖ `.interactiveDismissDisabled` during save ‚Äî prevents accidental swipe-dismiss while saving
- ‚úÖ Progress bar at the top gives spatial awareness of where the user is in the flow
- ‚úÖ Back button only appears after step 1 ‚Äî no confusion on the first step
- ‚úÖ Footer has `.background(.bar)` ‚Äî the system material that adapts to light/dark mode and provides the translucent bar effect
- ‚úÖ Tags use `Set<String>` for O(1) lookups on selection state
- ‚ö†Ô∏è The note step auto-focuses the keyboard. On step transition back from step 4, the keyboard will flash briefly. We should add a short delay or only focus when the step is fully visible. This is a polish item we can address later.

## Verify Phase

Build the project. Run it in the simulator and verify each step:

1. **Step 1 ‚Äî Recovery Slider.** Drag the thumb across all five levels. You should feel a light haptic tap at each stop. The gradient track should fill proportionally. The label below should highlight the current level.

2. **Step 2 ‚Äî Emoji Picker.** Tap an emoji. It should scale up and show a colored ring. Tap it again to deselect. The "Next" button should be disabled until an emoji is selected.

3. **Step 3 ‚Äî Note.** The keyboard should appear automatically. Type a few words. Tap "Next" ‚Äî the keyboard should dismiss. Tap "Back" ‚Äî the keyboard should reappear. The character count should update in real time.

4. **Step 4 ‚Äî Tags.** Tap several tags. They should toggle between filled and outlined. Tap "Save" ‚Äî you should feel a success haptic and the sheet should dismiss.

5. **Transitions.** Tap "Next" and "Back" repeatedly. The content should slide horizontally. Forward slides left-to-right out, right-to-left in. Backward is the reverse. No visual glitches.

6. **Edge cases.** Dismiss the sheet mid-flow. Present it again ‚Äî the state should be fresh (the ViewModel is recreated as `@State`). Try saving with an empty note ‚Äî it should work. Try saving with no tags ‚Äî it should work.

If any step fails, the ViewModel is the first place to look. Every piece of state flows through it, so bugs in display or behavior almost always trace back to a state issue.

## Final Code

Here is the complete set of files we built. Each file is self-contained and follows our architecture.

### CheckInFlowViewModel.swift

```swift
import Foundation
import os

@Observable
final class CheckInFlowViewModel {
    var currentStep = 1
    let totalSteps = 4

    var statusLevel = 3
    var selectedEmoji: String?
    var noteText = ""
    var selectedTags: Set<String> = []
    var isSaving = false

    static let availableTags = [
        "Urge", "Exercise", "Therapy", "Trigger", "Sleep", "Support Group",
        "Finances", "Health", "Mindfulness", "CBT Exercise", "Relax", "Stress"
    ]

    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "CheckIn")

    var canAdvance: Bool {
        switch currentStep {
        case 1: true
        case 2: selectedEmoji != nil
        case 3: true
        case 4: true
        default: false
        }
    }

    var isFirstStep: Bool { currentStep == 1 }
    var isLastStep: Bool { currentStep == totalSteps }

    var stepTitle: String {
        switch currentStep {
        case 1: "How are you doing?"
        case 2: "Pick an emoji"
        case 3: "Add a note"
        case 4: "Add tags"
        default: ""
        }
    }

    var stepSubtitle: String {
        switch currentStep {
        case 1: "Slide to match your current state"
        case 2: "Choose one that fits"
        case 3: "Optional ‚Äî write anything"
        case 4: "Optional ‚Äî what's on your mind?"
        default: ""
        }
    }

    func advance() {
        guard canAdvance, currentStep < totalSteps else { return }
        currentStep += 1
    }

    func goBack() {
        guard currentStep > 1 else { return }
        currentStep -= 1
    }

    func save(using service: RecoveryService) async {
        isSaving = true
        defer { isSaving = false }

        let checkIn = CheckIn(
            statusLevel: statusLevel,
            emoji: selectedEmoji ?? "üòê",
            note: noteText.trimmingCharacters(in: .whitespacesAndNewlines),
            tags: Array(selectedTags),
            createdAt: .now
        )

        do {
            try await service.save(checkIn)
            logger.info("Check-in saved: status \(self.statusLevel)")
        } catch {
            logger.error("Failed to save check-in: \(error.localizedDescription)")
        }
    }

    func reset() {
        currentStep = 1
        statusLevel = 3
        selectedEmoji = nil
        noteText = ""
        selectedTags = []
        isSaving = false
    }
}
```

### RecoverySlider.swift

```swift
import SwiftUI
import UIKit

struct RecoverySlider: View {
    @Binding var value: Int

    private let range = 1...5
    private let labels = ["Crisis", "Struggling", "Stable", "Strong", "Thriving"]
    private let thumbSize: CGFloat = 44

    @State private var isDragging = false

    var body: some View {
        VStack(spacing: 16) {
            GeometryReader { geometry in
                let trackWidth = geometry.size.width - thumbSize
                let stepWidth = trackWidth / CGFloat(range.count - 1)
                let thumbOffset = CGFloat(value - range.lowerBound) * stepWidth

                ZStack(alignment: .leading) {
                    Capsule()
                        .fill(Color(.systemGray5))
                        .frame(height: 8)
                        .padding(.horizontal, thumbSize / 2)

                    Capsule()
                        .fill(trackGradient)
                        .frame(width: thumbOffset + thumbSize / 2, height: 8)
                        .padding(.leading, thumbSize / 2)

                    Circle()
                        .fill(.white)
                        .shadow(color: .black.opacity(0.15), radius: 4, y: 2)
                        .frame(width: thumbSize, height: thumbSize)
                        .overlay {
                            Text("\(value)")
                                .font(.system(.title3, design: .rounded, weight: .bold))
                                .foregroundStyle(thumbColor)
                        }
                        .scaleEffect(isDragging ? 1.1 : 1.0)
                        .offset(x: thumbOffset)
                        .gesture(
                            DragGesture(minimumDistance: 0)
                                .onChanged { gesture in
                                    isDragging = true
                                    let newValue = calculateValue(
                                        from: gesture.location.x,
                                        trackWidth: trackWidth,
                                        stepWidth: stepWidth
                                    )
                                    if newValue != value {
                                        value = newValue
                                        triggerHaptic()
                                    }
                                }
                                .onEnded { _ in
                                    isDragging = false
                                }
                        )
                }
                .frame(height: thumbSize)
            }
            .frame(height: thumbSize)

            HStack {
                ForEach(Array(labels.enumerated()), id: \.offset) { index, label in
                    Text(label)
                        .font(.caption2)
                        .fontWeight(index + 1 == value ? .semibold : .regular)
                        .foregroundStyle(index + 1 == value ? thumbColor : .secondary)
                        .frame(maxWidth: .infinity)
                }
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: value)
        .animation(.spring(response: 0.2, dampingFraction: 0.6), value: isDragging)
    }

    private var trackGradient: LinearGradient {
        LinearGradient(
            colors: [.indigo, .blue, .yellow, .orange, .green],
            startPoint: .leading,
            endPoint: .trailing
        )
    }

    private var thumbColor: Color {
        switch value {
        case 1: .indigo
        case 2: .blue
        case 3: .yellow.opacity(0.9)
        case 4: .orange
        case 5: .green
        default: .gray
        }
    }

    private func calculateValue(
        from locationX: CGFloat,
        trackWidth: CGFloat,
        stepWidth: CGFloat
    ) -> Int {
        let clamped = min(max(locationX - thumbSize / 2, 0), trackWidth)
        let rawValue = Int(round(clamped / stepWidth)) + range.lowerBound
        return min(max(rawValue, range.lowerBound), range.upperBound)
    }

    private func triggerHaptic() {
        let generator = UIImpactFeedbackGenerator(style: .light)
        generator.impactOccurred()
    }
}

#Preview {
    @Previewable @State var status = 3
    RecoverySlider(value: $status)
        .padding(32)
}
```

### EmojiPicker.swift

```swift
import SwiftUI
import UIKit

struct EmojiPicker: View {
    @Binding var selection: String?

    private let emojis = [
        "üòä", "üòî", "üò∞", "üòå",
        "‚ö°", "üò¥", "üò°", "ü•∞",
        "üòÇ", "ü§î", "üò¢", "üéâ"
    ]

    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 12),
        count: 4
    )

    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(emojis, id: \.self) { emoji in
                let isSelected = selection == emoji

                Button {
                    if selection == emoji {
                        selection = nil
                    } else {
                        selection = emoji
                        triggerHaptic()
                    }
                } label: {
                    Text(emoji)
                        .font(.system(size: 36))
                        .frame(width: 64, height: 64)
                        .background(
                            Circle()
                                .fill(isSelected ? Color.accentColor.opacity(0.15) : Color(.systemGray6))
                        )
                        .overlay(
                            Circle()
                                .strokeBorder(
                                    isSelected ? Color.accentColor : .clear,
                                    lineWidth: 2.5
                                )
                        )
                        .scaleEffect(isSelected ? 1.1 : 1.0)
                }
                .buttonStyle(.plain)
                .accessibilityLabel(accessibilityName(for: emoji))
                .accessibilityAddTraits(isSelected ? .isSelected : [])
            }
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.7), value: selection)
    }

    private func triggerHaptic() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }

    private func accessibilityName(for emoji: String) -> String {
        switch emoji {
        case "üòä": "Happy"
        case "üòî": "Sad"
        case "üò∞": "Anxious"
        case "üòå": "Calm"
        case "‚ö°": "Energized"
        case "üò¥": "Tired"
        case "üò°": "Angry"
        case "ü•∞": "Loved"
        case "üòÇ": "Amused"
        case "ü§î": "Thoughtful"
        case "üò¢": "Tearful"
        case "üéâ": "Excited"
        default: emoji
        }
    }
}

#Preview {
    @Previewable @State var selected: String?
    EmojiPicker(selection: $selected)
        .padding()
}
```

### CheckInFlowView.swift

```swift
import SwiftUI
import UIKit

struct CheckInFlowView: View {
    let service: RecoveryService

    @Environment(\.dismiss) private var dismiss
    @State private var viewModel = CheckInFlowViewModel()
    @FocusState private var isNoteFieldFocused: Bool
    @State private var direction: NavigationDirection = .forward

    enum NavigationDirection {
        case forward, backward
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                stepHeader

                ZStack {
                    stepContent
                        .id(viewModel.currentStep)
                        .transition(stepTransition)
                }
                .frame(maxHeight: .infinity)
                .animation(.easeInOut(duration: 0.25), value: viewModel.currentStep)

                footerButtons
            }
            .navigationTitle(viewModel.stepTitle)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .symbolRenderingMode(.hierarchical)
                            .foregroundStyle(.secondary)
                            .font(.title3)
                    }
                }

                ToolbarItem(placement: .principal) {
                    Text("Step \(viewModel.currentStep) of \(viewModel.totalSteps)")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
            .overlay {
                if viewModel.isSaving {
                    Color.black.opacity(0.2)
                        .ignoresSafeArea()
                        .overlay { ProgressView() }
                }
            }
            .interactiveDismissDisabled(viewModel.isSaving)
        }
    }

    // MARK: - Step Header

    private var stepHeader: some View {
        VStack(spacing: 4) {
            GeometryReader { geometry in
                let progress = CGFloat(viewModel.currentStep) / CGFloat(viewModel.totalSteps)
                ZStack(alignment: .leading) {
                    Capsule()
                        .fill(Color(.systemGray5))
                    Capsule()
                        .fill(Color.accentColor)
                        .frame(width: geometry.size.width * progress)
                }
            }
            .frame(height: 4)
            .padding(.horizontal)
            .animation(.easeInOut(duration: 0.25), value: viewModel.currentStep)

            Text(viewModel.stepSubtitle)
                .font(.subheadline)
                .foregroundStyle(.secondary)
                .padding(.top, 8)
        }
        .padding(.top, 8)
    }

    // MARK: - Step Content

    @ViewBuilder
    private var stepContent: some View {
        switch viewModel.currentStep {
        case 1: statusLevelStep
        case 2: emojiStep
        case 3: noteStep
        case 4: tagsStep
        default: EmptyView()
        }
    }

    private var statusLevelStep: some View {
        VStack {
            Spacer()
            RecoverySlider(value: $viewModel.statusLevel)
                .padding(.horizontal, 32)
            Spacer()
        }
    }

    private var emojiStep: some View {
        VStack {
            Spacer()
            EmojiPicker(selection: $viewModel.selectedEmoji)
                .padding(.horizontal, 24)
            Spacer()
        }
    }

    private var noteStep: some View {
        VStack(alignment: .leading, spacing: 12) {
            ZStack(alignment: .topLeading) {
                if viewModel.noteText.isEmpty {
                    Text("What's on your mind?")
                        .foregroundStyle(.tertiary)
                        .padding(.top, 8)
                        .padding(.leading, 5)
                }

                TextEditor(text: $viewModel.noteText)
                    .focused($isNoteFieldFocused)
                    .scrollContentBackground(.hidden)
                    .frame(minHeight: 120)
            }
            .padding()
            .background(Color(.systemGray6), in: RoundedRectangle(cornerRadius: 12))

            Text("\(viewModel.noteText.count)/280")
                .font(.caption)
                .foregroundStyle(.secondary)
                .frame(maxWidth: .infinity, alignment: .trailing)
        }
        .padding(.horizontal, 24)
        .padding(.top, 24)
        .onAppear { isNoteFieldFocused = true }
        .onDisappear { isNoteFieldFocused = false }
    }

    private var tagsStep: some View {
        let columns = Array(repeating: GridItem(.flexible(), spacing: 10), count: 3)

        return ScrollView {
            LazyVGrid(columns: columns, spacing: 10) {
                ForEach(CheckInFlowViewModel.availableTags, id: \.self) { tag in
                    let isSelected = viewModel.selectedTags.contains(tag)

                    Button {
                        if isSelected {
                            viewModel.selectedTags.remove(tag)
                        } else {
                            viewModel.selectedTags.insert(tag)
                            triggerSelectionHaptic()
                        }
                    } label: {
                        Text(tag)
                            .font(.subheadline)
                            .fontWeight(isSelected ? .semibold : .regular)
                            .foregroundStyle(isSelected ? .white : .primary)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(
                                isSelected ? Color.accentColor : Color(.systemGray6),
                                in: Capsule()
                            )
                    }
                    .buttonStyle(.plain)
                    .accessibilityAddTraits(isSelected ? .isSelected : [])
                }
            }
            .padding(.horizontal, 24)
            .padding(.top, 24)
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.8), value: viewModel.selectedTags)
    }

    // MARK: - Transition

    private var stepTransition: AnyTransition {
        switch direction {
        case .forward:
            .asymmetric(
                insertion: .move(edge: .trailing).combined(with: .opacity),
                removal: .move(edge: .leading).combined(with: .opacity)
            )
        case .backward:
            .asymmetric(
                insertion: .move(edge: .leading).combined(with: .opacity),
                removal: .move(edge: .trailing).combined(with: .opacity)
            )
        }
    }

    // MARK: - Footer

    private var footerButtons: some View {
        HStack(spacing: 16) {
            if !viewModel.isFirstStep {
                Button {
                    direction = .backward
                    isNoteFieldFocused = false
                    viewModel.goBack()
                } label: {
                    Label("Back", systemImage: "chevron.left")
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 14)
                }
                .buttonStyle(.bordered)
                .tint(.secondary)
            }

            Button {
                if viewModel.isLastStep {
                    saveEntry()
                } else {
                    direction = .forward
                    isNoteFieldFocused = false
                    viewModel.advance()
                }
            } label: {
                Group {
                    if viewModel.isLastStep {
                        Label("Save", systemImage: "checkmark")
                    } else {
                        Label("Next", systemImage: "chevron.right")
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 14)
            }
            .buttonStyle(.borderedProminent)
            .disabled(!viewModel.canAdvance || viewModel.isSaving)
        }
        .padding(.horizontal, 24)
        .padding(.vertical, 16)
        .background(.bar)
    }

    // MARK: - Actions

    private func saveEntry() {
        Task {
            await viewModel.save(using: service)
            if !viewModel.isSaving {
                triggerSuccessHaptic()
                dismiss()
            }
        }
    }

    private func triggerSelectionHaptic() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }

    private func triggerSuccessHaptic() {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.success)
    }
}

#Preview {
    CheckInFlowView(service: PreviewRecoveryService())
}
```

## Checkpoint

Let us confirm what we built and why each piece matters.

**CheckInFlowViewModel** owns all form state. No state lives in the view. This means the view is purely declarative ‚Äî it reads from the ViewModel and sends actions to it. If you need to unit test the check-in logic (and you will, in Module 6), you test the ViewModel directly without touching any UI.

**RecoverySlider** replaces the stock `Slider` with a custom control that has personality. The gradient track, discrete snapping, and haptic feedback make a 1-5 selection feel physical. Users remember how an app feels more than how it looks.

**EmojiPicker** uses a grid instead of a text field. This is a critical UX choice ‚Äî giving users options to tap is always faster and more accessible than asking them to type. The accessibility labels ensure VoiceOver users get the same experience.

**CheckInFlowView** orchestrates the flow with directional transitions. The `.id` modifier combined with `.transition` is the pattern for animated view switching in SwiftUI. The `NavigationDirection` enum ensures the slides always match the user's mental model ‚Äî forward goes left, backward goes right.

**Haptic feedback** appears at three levels: light impact on the slider, selection tick on emoji and tag changes, and a success notification on save. These are not random ‚Äî they follow Apple's haptic design guidelines where impact means adjustment, selection means choice, and notification means completion.

---

## Challenge

You have the check-in flow. Now extend it.

**Add a fifth step: "Coping Strategy."** Between the current step 3 (note) and step 4 (tags), insert a new step that lets the user pick what coping strategy they used. Show a 2-column grid of strategies with SF Symbol icons: Breathing (wind), Journaling (book), Exercising (figure.run), CBT Exercise (brain.head.profile), Calling Sponsor (phone), Support Group (person.2), Meditation (bed.double), Walking Outdoors (sun.max).

This requires changes in three places:
1. The ViewModel ‚Äî add `selectedStrategy: String?`, update `totalSteps` to 5, shift step titles and `canAdvance` logic
2. The view ‚Äî add the strategy step content and adjust step numbering
3. The model ‚Äî add the strategy field to `CheckIn`

Prompt Claude Code for each change separately. Review each diff. This is the iterative workflow in action ‚Äî one focused change at a time, not one giant prompt for everything.
