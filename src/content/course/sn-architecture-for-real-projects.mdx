---
title: "Architecture for a Real Project"
description: "Set up the BetAway Xcode project with Swift 6 strict concurrency, define the MVVM + Service Layer architecture, and create the folder structure that will carry you through the entire build."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 1
duration: "22 min read"
difficulty: "intermediate"
topics: ["Swift 6", "Xcode", "MVVM", "Service Layer", "Architecture", "Project Setup", "Concurrency", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

This is where we start building BetAway — a real app, for real users, shipping to a real App Store. No toy examples. No "Hello World." We are laying the foundation that the rest of the course builds on, and a weak foundation means rework in every future lesson.

> **A note on naming.** The marketing name of the app is **BetAway** — that is what users see on the App Store. The Xcode project and Swift code prefix use **BetFree** (from the earlier working title "Bet Free"). You will see both throughout the course: BetAway in prose and UI copy, `BetFreeApp` in Swift structs and bundle identifiers. This is normal in production — marketing names evolve, but renaming every file and bundle ID mid-development is not worth the risk. In this first lesson we use `BetAwayApp` in prompts and initial setup. Later lessons use `BetFreeApp` in code, which is the actual shipped struct name.

In this lesson, we set up the Xcode project, lock in Swift 6 strict concurrency from day one, define the architecture, and create the folder structure. By the end, you will have a project that compiles, navigates, and is ready to accept features.

## What You'll Learn

- How to create an Xcode project configured for Swift 6 strict concurrency mode
- The MVVM + Service Layer architecture and why it scales for production apps
- A folder structure (`App/`, `Core/`, `Models/`, `Navigation/`, `ViewModels/`, `Views/`) that keeps a growing codebase navigable
- How to build a tab-based `AppRouter` with `@Observable` for type-safe navigation

## Why This Matters

Every production iOS app that survives past v1.0 has a clear architecture. Without one, you end up with massive view files, untestable logic, and a codebase that fights you on every change. Swift 6's strict concurrency catches data races at compile time — adopting it now saves you from mysterious crashes in production. The 20 minutes you spend on architecture today will save you 20 hours of refactoring later.

## Plan Phase: Defining What We Build

Open Claude Code (or your AI tool of choice) in Plan mode. We want the AI to think through the architecture before it writes a single line. Here is the prompt — copy-paste it exactly:

```
I am starting a new iOS app called "BetAway" — a free gambling
recovery app. Before writing any code, help me plan the project setup.

Requirements:
- Xcode 16+, iOS 17+, Swift 6 with strict concurrency enabled
- Architecture: MVVM + Service Layer pattern
- Navigation: enum-based Router with NavigationStack
- Persistence: SwiftData (set up the ModelContainer, no models yet)
- Logging: os.Logger everywhere, zero print() calls
- Dependency injection via protocols (no singletons)

Think through:
1. What Xcode project settings do I need for Swift 6 strict
   concurrency?
2. What is the folder structure?
3. What files do I need for the app entry point and router?
4. How should dependency injection work at the app root?
5. What protocols do I define now to keep things testable?

Do not generate code yet. Give me the plan.
```

### What the AI Plan Should Contain

A good plan from this prompt will include:

1. **Build Settings** — `SWIFT_STRICT_CONCURRENCY = complete` and the Swift language version set to 6 in the Xcode build settings.
2. **Folder structure** — something close to `App/`, `Core/`, `Models/`, `Navigation/`, `ViewModels/`, `Views/`, `Tests/`, with clear separation of concerns.
3. **Entry point** — `BetAwayApp.swift` with a `ModelContainer` configured and injected into the environment.
4. **Router** — an `@Observable` `AppRouter` class with a `Tab` enum for tab navigation, `NavigationPath` for drill-down, and onboarding state management.
5. **Protocols** — at minimum, a service protocol pattern so the data layer can be swapped for mocks in tests.
6. **DI strategy** — config and theme in `Core/`, models in `Models/`, injected at the `App` level via SwiftUI environment.

If the plan is missing any of these, ask a follow-up. The plan is cheap. Rework is expensive.

### Anti-Pattern: The Lazy Prompt

Here is what NOT to send:

```
Set up an Xcode project for a gambling recovery app
```

This prompt gives the AI almost nothing to work with. You will get Swift 5 defaults, no concurrency settings, `NavigationView` instead of `NavigationStack`, `print()` statements, a flat file structure, and an architecture that is "whatever the AI felt like today." Vague input produces vague output. Every time.

## Execute Phase: Implementation

Now that we have a plan, switch to Execute mode. Here is the implementation prompt:

```
Create the BetAway project foundation. Generate the following
files with full Swift 6 strict concurrency compliance:

1. BetAwayApp.swift — @main entry point
   - Configure a SwiftData ModelContainer with schema for our models
   - Create and inject an AppRouter as an @State property
   - Register custom fonts at runtime via CoreText
   - Inject router and locale into the environment
   - Force dark mode with .preferredColorScheme(.dark)
   - Add ModelContainer error recovery (delete + recreate if corrupted)

2. AppRouter.swift — navigation + state controller
   - An @Observable final class
   - A Tab enum with cases: dashboard, journal, progress, settings
     (each with a localizedName and SF Symbol icon)
   - A NavigationPath for drill-down navigation
   - Onboarding state: showOnboarding Bool driven by UserDefaults
   - Methods: completeOnboarding(), popToRoot(), lock(), unlock()
   - Use spring animations from AnimationPresets for transitions

3. Folder structure:
   App/           → BetAwayApp.swift
   Core/Config/   → AppConfig.swift (constants, feature flags, keys)
   Core/Theme/    → ColorPalette, Typography, Spacing, AnimationPresets
   Models/        → (SwiftData models — added next lesson)
   Navigation/    → AppRouter.swift
   ViewModels/    → (added in Module 2)
   Views/         → MainTabView, RootView, feature folders
   Tests/         → (added in Module 6)

Every type that touches UI must be @MainActor.
Every Sendable boundary must be explicit.
Zero warnings under strict concurrency.
```

### Analyzing the AI Output

When the AI responds, here is what to look for:

**BetAwayApp.swift:**

- ✅ Uses `@main` and conforms to `App`
- ✅ Creates `ModelContainer` with a full schema and error recovery
- ✅ Injects the router via `.environment()` using the iOS 17+ `@Environment(AppRouter.self)` pattern
- ✅ Registers custom fonts at runtime — no Info.plist entries needed
- ✅ Forces `.preferredColorScheme(.dark)` for the whole app
- ⚠️ If it uses `fatalError` in the `ModelContainer` catch — that is acceptable only after a recovery attempt (delete and recreate). Our code tries twice before crashing
- ❌ If it uses `@StateObject` — reject. We use `@State` with `@Observable` in modern SwiftUI
- ❌ If it uses `NavigationView` — reject. `NavigationStack` only
- ❌ If it imports `Combine` — reject. We use `@Observable`, not `ObservableObject`

**AppRouter.swift:**

- ✅ Marked `@Observable` as a `final class`
- ✅ `Tab` enum is `CaseIterable` and `Identifiable` (for `ForEach` in tab bar)
- ✅ Uses `NavigationPath` for drill-down navigation within tabs
- ✅ Manages onboarding state via `UserDefaults`
- ✅ Uses `AnimationPresets` for smooth transitions (not raw `withAnimation`)
- ❌ If it uses a singleton pattern (`static let shared`) — reject immediately
- ❌ If it uses `@Published` — reject. `@Observable` handles this

## Iteration

After reviewing the output, send this follow-up to tighten things up:

```
Good start. Make these adjustments:

1. Use @Environment(AppRouter.self) — the iOS 17+ syntax that
   does not require a custom EnvironmentKey. Simpler and cleaner
2. Add a lock() / unlock() method pair for biometric lock support
3. Add a resetForNewUser() method that clears UserDefaults and
   resets all navigation state (onboarding, tab, path)
4. Use AnimationPresets.gentle for onboarding transitions and
   AnimationPresets.smooth for navigation state changes
5. Make sure the Tab enum has both a localizedName (via
   LanguageManager) and an SF Symbol icon property

Zero warnings. Swift 6 strict concurrency.
```

This is the iteration pattern: review, identify gaps, send targeted fixes. Never re-describe the whole thing — just tell the AI what to change.

## Verify Phase

Before moving to the next lesson, verify these things:

**In Xcode:**
1. Build the project with `Cmd+B` — zero errors, zero warnings
2. Open Build Settings, search "Swift Concurrency" — confirm `Strict Concurrency Checking` is set to `Complete`
3. Open Build Settings, search "Swift Language Version" — confirm it is set to `Swift 6`
4. Run the app in the Simulator — it should launch without crashing (you will see an empty view, which is correct)

**In the code:**
1. Grep for `print(` — there should be zero matches
2. Grep for `ObservableObject`, `@Published`, `@StateObject` — zero matches
3. Confirm `AppRouter` uses `@Observable` and is a `final class`
4. Confirm `Tab` enum conforms to `CaseIterable` and `Identifiable`
5. Confirm `ModelContainer` has error recovery logic (delete + recreate)

**Navigation test:**
1. Launch the app — `RootView` should check `showOnboarding` and display accordingly
2. After onboarding, `MainTabView` should show with four tabs
3. Tap each tab — confirm `selectedTab` updates and the correct view loads
4. Call `router.popToRoot()` — confirm `NavigationPath` resets

## Final Code

Here are the complete, compilable files for this lesson.

### Folder Structure

```
BetAway/
├── App/
│   └── BetAwayApp.swift
├── Core/
│   ├── Config/
│   │   └── AppConfig.swift
│   └── Theme/
│       ├── ColorPalette.swift
│       ├── Typography.swift
│       ├── Spacing.swift
│       └── AnimationPresets.swift
├── Models/
│   ├── UserProfile.swift
│   ├── DailyCheckin.swift
│   ├── UrgeLog.swift
│   ├── JournalEntry.swift
│   ├── Enums.swift
│   └── EmergencyContact.swift
├── Navigation/
│   └── AppRouter.swift
├── ViewModels/
│   ├── DashboardViewModel.swift
│   ├── UrgeViewModel.swift
│   └── SettingsViewModel.swift
├── Views/
│   ├── MainTabView.swift
│   ├── RootView.swift
│   ├── Dashboard/
│   ├── Journal/
│   ├── Progress/
│   ├── Settings/
│   ├── Onboarding/
│   └── Components/
└── Tests/
    └── (added in Module 6)
```

### BetAwayApp.swift

```swift
import SwiftUI
import SwiftData
import CoreText

@main
struct BetAwayApp: App {
    @State private var appRouter = AppRouter()
    @State private var languageManager = LanguageManager()

    init() {
        UserDefaults.standard.register(defaults: [
            AppConfig.StorageKeys.hapticFeedbackEnabled: true
        ])
        Self.registerCustomFonts()
    }

    /// Register bundled custom fonts at runtime (no Info.plist needed)
    private static func registerCustomFonts() {
        let fontNames = ["Nunito-Variable"]
        for name in fontNames {
            guard let url = Bundle.main.url(forResource: name, withExtension: "ttf") else { continue }
            CTFontManagerRegisterFontsForURL(url as CFURL, .process, nil)
        }
    }

    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            UserProfile.self,
            DailyCheckin.self,
            UrgeLog.self,
            JournalEntry.self,
        ])
        let modelConfiguration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: false
        )

        do {
            return try ModelContainer(for: schema, configurations: [modelConfiguration])
        } catch {
            // If the database is corrupted, try deleting and recreating
            let urls = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
            if let appSupportURL = urls.first {
                let storeURL = appSupportURL.appendingPathComponent("default.store")
                try? FileManager.default.removeItem(at: storeURL)

                // Also remove related files (.store-shm, .store-wal)
                for suffix in ["-shm", "-wal"] {
                    let relatedURL = appSupportURL.appendingPathComponent("default.store\(suffix)")
                    try? FileManager.default.removeItem(at: relatedURL)
                }
            }

            do {
                return try ModelContainer(for: schema, configurations: [modelConfiguration])
            } catch {
                fatalError("Could not create ModelContainer after reset: \(error)")
            }
        }
    }()

    var body: some Scene {
        WindowGroup {
            RootView()
                .environment(appRouter)
                .environment(languageManager)
                .environment(\.locale, languageManager.locale)
                .preferredColorScheme(.dark)
        }
        .modelContainer(sharedModelContainer)
    }
}
```

Notice a few production-level details that a simple tutorial would skip:

- **Custom font registration via CoreText** — `CTFontManagerRegisterFontsForURL` lets you register fonts at runtime without touching Info.plist. This is cleaner for variable fonts and avoids build system weirdness with font file references.
- **ModelContainer error recovery** — if the SQLite database is corrupted (happens more often than you think on real devices), we delete the `.store`, `.store-shm`, and `.store-wal` files and try again. Only if the second attempt fails do we crash.
- **`LanguageManager` injection** — BetAway supports 12 languages. The `LanguageManager` is injected into the environment and also overrides `\.locale` so all system-provided strings (dates, numbers) match the user's language choice.
- **Dark mode enforced** — `.preferredColorScheme(.dark)` at the root. The entire design system is built for dark backgrounds. No light mode toggle needed.

### AppRouter.swift

```swift
import SwiftUI

@Observable
final class AppRouter {
    var showOnboarding: Bool
    var isLocked: Bool = false
    var selectedTab: Tab = .dashboard
    var navigationPath = NavigationPath()

    enum Tab: String, CaseIterable, Identifiable {
        case dashboard = "Dashboard"
        case journal = "Journal"
        case progress = "Progress"
        case settings = "Settings"

        var id: String { rawValue }

        var localizedName: String {
            LanguageManager.shared.bundle.localizedString(forKey: rawValue, value: nil, table: nil)
        }

        var icon: String {
            switch self {
            case .dashboard: return AppConfig.Icons.house
            case .journal: return AppConfig.Icons.journal
            case .progress: return AppConfig.Icons.chart
            case .settings: return AppConfig.Icons.settings
            }
        }
    }

    init() {
        self.showOnboarding = !UserDefaults.standard.bool(forKey: AppConfig.StorageKeys.hasCompletedOnboarding)
    }

    func completeOnboarding() {
        UserDefaults.standard.set(true, forKey: AppConfig.StorageKeys.hasCompletedOnboarding)
        withAnimation(AnimationPresets.gentle) {
            showOnboarding = false
        }
    }

    func popToRoot() {
        navigationPath = NavigationPath()
    }

    func lock() {
        withAnimation(AnimationPresets.fade) {
            isLocked = true
        }
    }

    func unlock() {
        withAnimation(AnimationPresets.smooth) {
            isLocked = false
        }
    }

    func resetForNewUser() {
        UserDefaults.standard.set(false, forKey: AppConfig.StorageKeys.hasCompletedOnboarding)
        withAnimation(AnimationPresets.gentle) {
            showOnboarding = true
            selectedTab = .dashboard
            navigationPath = NavigationPath()
        }
    }
}
```

Compare this to a textbook router and you will notice several real-world additions:

- **`showOnboarding`** — driven by `UserDefaults`, not hardcoded. When the user completes onboarding, one `Bool` flip hides it forever.
- **`isLocked`** — supports biometric lock (Face ID / Touch ID). The `lock()` and `unlock()` methods wrap state changes in animations so the transition feels native.
- **`Tab` enum** — uses `CaseIterable` so the custom tab bar can `ForEach` over all cases. Each tab knows its own `localizedName` and SF Symbol `icon`. No string mapping tables.
- **`AnimationPresets`** — instead of raw `withAnimation(.spring(...))` calls scattered everywhere, we centralize animation curves in an `AnimationPresets` enum (built in the Design System lesson). Every transition in the app uses the same timing.
- **`resetForNewUser()`** — wipes UserDefaults and resets all navigation state. Used in Settings when the user wants to start over. This is the kind of method you never think about until a real user asks "how do I reset the app?"

Note that we do **not** use `@MainActor` annotation on the class itself. With `@Observable` in Swift 6, the compiler already enforces that property mutations happen on the main actor when the type is used in SwiftUI views. The `withAnimation` calls implicitly run on `@MainActor`. If you get concurrency warnings later, adding `@MainActor` is always safe — but start without it and let the compiler tell you if it is needed.

Also note we use `@Environment(AppRouter.self)` (iOS 17+) instead of a custom `EnvironmentKey`. This is simpler — you inject with `.environment(appRouter)` and read with `@Environment(AppRouter.self) private var router`. No boilerplate `EnvironmentKey` struct needed.

### Key Design Decisions

**Why `@Observable` instead of `ObservableObject`?** The `@Observable` macro (iOS 17+) gives you granular property tracking without `@Published` wrappers. SwiftUI only re-renders views that read specific properties that changed, rather than any view that observes the object. Less boilerplate, better performance.

**Why a `Tab` enum instead of a `Route` enum?** BetAway uses a `TabView` as its primary navigation. Each tab has its own `NavigationStack`. The `Tab` enum drives the tab bar, while `NavigationPath` handles drill-down within each tab. This is the standard pattern for any app with a tab bar — which is most production iOS apps.

**Why `NavigationPath` alongside tabs?** `NavigationPath` handles pushing detail views within a tab (e.g., tapping a journal entry to see its detail). The tab bar handles top-level navigation. Separating these two concerns means switching tabs does not destroy the navigation state within each tab.

**Why `UserDefaults` for onboarding state?** It is a single boolean. SwiftData would be overkill. `UserDefaults` persists across launches, is synchronous, and costs nothing. The key is defined in `AppConfig.StorageKeys` so you never have a string typo.

**Why `AnimationPresets` instead of inline animations?** Consistency. When every screen uses `AnimationPresets.smooth` or `AnimationPresets.bouncy`, the app feels cohesive. When each developer writes their own `withAnimation(.spring(response: 0.3, dampingFraction: 0.7))`, you get inconsistent timing across screens. Centralize your animation curves like you centralize your colors.

## Checkpoint

Before moving to Lesson 1.2, confirm every item:

- [ ] Xcode project builds with zero errors and zero warnings
- [ ] Swift Language Version is set to 6 in Build Settings
- [ ] Strict Concurrency Checking is set to Complete
- [ ] `BetAwayApp.swift` compiles with `ModelContainer`, router injection, and font registration
- [ ] `AppRouter.swift` compiles with `@Observable`, `Tab` enum, and `NavigationPath`
- [ ] `@Environment(AppRouter.self)` resolves correctly in views
- [ ] App launches in the Simulator without crashing (dark mode, empty dashboard)
- [ ] No `print()` statements in the codebase
- [ ] `AppConfig` centralizes all constants (storage keys, icons, feature flags)
- [ ] Folder structure matches: `App/`, `Core/`, `Models/`, `Navigation/`, `ViewModels/`, `Views/`

## Challenge

**Build the `MainTabView` that consumes the `AppRouter`.**

Using the `AppRouter` you just built, create a `MainTabView` that:

1. Reads the router from the environment with `@Environment(AppRouter.self)`
2. Creates a `TabView(selection:)` bound to `router.selectedTab`
3. Wraps each tab's content in its own `NavigationStack`
4. Hides the system tab bar (`.toolbar(.hidden, for: .tabBar)`) and adds a custom animated tab bar at the bottom

<details>
<summary>Hint</summary>

The key pattern is `@Bindable var router = router` inside the `body` to get a binding from `@Environment`:

```swift
struct MainTabView: View {
    @Environment(AppRouter.self) private var router

    var body: some View {
        @Bindable var router = router

        VStack(spacing: 0) {
            TabView(selection: $router.selectedTab) {
                NavigationStack(path: $router.navigationPath) {
                    DashboardView()
                }
                .tag(AppRouter.Tab.dashboard)

                NavigationStack {
                    JournalView()
                }
                .tag(AppRouter.Tab.journal)

                NavigationStack {
                    ProgressAnalyticsView()
                }
                .tag(AppRouter.Tab.progress)

                NavigationStack {
                    SettingsView()
                }
                .tag(AppRouter.Tab.settings)
            }
            .toolbar(.hidden, for: .tabBar)

            CustomTabBar(selectedTab: $router.selectedTab)
        }
    }
}
```

The `@Bindable` pattern is required because `@Environment` gives you a read-only value. `@Bindable` creates a binding to the `@Observable` object's properties. This is the standard way to get two-way bindings from environment-injected observable objects in iOS 17+.
</details>

> **Pro tip:** Before starting any project, search the App Store for your app name. We originally built this project as "BetFree" — and only discovered the name was taken when we submitted to the App Store. We had to rename to "BetAway" at the last minute. Research your name early so you do not have to rename your Xcode project, bundle ID, and marketing materials after months of development.

---

Next up: **Lesson 1.2 — Data Modeling with SwiftData**, where we define the `UserProfile`, `DailyCheckin`, `UrgeLog`, and `JournalEntry` models, set up relationships with delete rules, and build the enum-based domain types that the entire app depends on.
