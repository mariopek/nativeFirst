---
title: "CLAUDE.md for Your Project"
description: "Write a project-specific CLAUDE.md that enforces architecture rules, naming conventions, and code standards — turning your AI coding assistant into a senior team member."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 3
duration: "18 min read"
difficulty: "intermediate"
topics: ["CLAUDE.md", "AI Configuration", "Code Standards", "Naming Conventions", "Architecture Rules", "Developer Workflow", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

In the previous two lessons, we set up the Xcode project and defined our MVVM + Service Layer architecture with SwiftData models. We have the skeleton. Now we need the brain — a file that tells our AI assistant exactly how to build inside that skeleton, every single time.

That file is `CLAUDE.md`.

## What You'll Learn

1. How to write a production `CLAUDE.md` that enforces architecture, naming, and style rules automatically
2. Why vague AI configuration files produce vague code — and how to fix it
3. The exact `CLAUDE.md` we will use for BetAway throughout this entire course
4. How to verify your `CLAUDE.md` actually works before you trust it

## Why This Matters

Boris Cherny, author of *Programming TypeScript*, said something that stuck with me: **"A good plan is really important."** He was talking about type systems, but the principle is universal. The more upfront constraints you give a system, the fewer runtime surprises you get.

CLAUDE.md is your plan for every AI interaction in this project. Without it, every prompt you write starts from zero. You have to re-explain the architecture. You have to remind Claude not to use force unwraps. You have to correct the file naming. Again. And again.

I learned this the hard way on a client project. We were three weeks into a build, four developers all using Claude Code, and the codebase looked like four different people wrote it — because they did, and the AI had no shared rules. One developer got ViewModels as structs. Another got singletons everywhere. A third had business logic scattered across views. The code compiled, but it was unmaintainable.

We wrote a CLAUDE.md in 30 minutes. The next day, every piece of generated code looked like the same senior developer wrote it. That is the difference.

## Plan Phase: Defining What We Build

Before writing the file, we need to think about what belongs in it. Open Claude Code in the BetAway project directory and send this:

```
I need to write a CLAUDE.md for our BetAway project — a free
gambling recovery app for iOS. Before writing the file, help me
think through what sections we need.

Here is the context:
- Architecture: MVVM + Service Layer pattern
- Persistence: SwiftData (services abstract all data access)
- ViewModels never access SwiftData directly
- Swift 6 with strict concurrency
- iOS 17+, SwiftUI only
- We use on-device ML (Apple's NaturalLanguage framework) for
  recovery insights — completely offline-first, no external APIs
- We need consistent naming conventions for Views, ViewModels,
  Services, and Models
- Testing with Swift Testing framework, mock services

List the sections this CLAUDE.md needs and what each section
should cover. Do not write the file yet — just the outline.
```

Claude Code will propose something like: Project Overview, Architecture, Naming Conventions, File Organization, Coding Standards, Data Layer Rules, Testing Rules, and a Do NOT section.

Review that outline. Make sure it covers architecture enforcement, naming conventions, Swift style rules, and explicit prohibitions. If it misses any of those, tell Claude to add them before moving on.

### The Anti-Pattern: Vague CLAUDE.md

Here is what a bad CLAUDE.md looks like. I see versions of this constantly:

```markdown
# BetAway

iOS gambling recovery app.

## Rules
- Write clean code
- Follow best practices
- Use MVVM
- Make it testable
```

This tells the AI almost nothing. What is "clean code"? Which "best practices" — Apple's? Google's? Some blog post from 2019? "Use MVVM" with no rules means the AI decides what MVVM means, and it will decide differently every time. "Make it testable" without specifying how is a wish, not a constraint.

Compare that to what we are about to build. The difference is specificity.

## Execute Phase: Implementation

Now we write the real thing. Send this to Claude Code:

```
Write the complete CLAUDE.md file for BetAway based on the outline
we discussed. Here are the specific rules to include:

Architecture:
- MVVM + Service Layer pattern
- ViewModels are @Observable classes, never ObservableObject
- Views own ViewModels via @State private var viewModel
- ViewModels depend on service protocols, never concrete types
- Services abstract all SwiftData access — ViewModels never
  import SwiftData
- Use dependency injection, not service locators or singletons

Naming:
- Views: [Feature]View (CheckInView, DashboardView)
- ViewModels: [Feature]ViewModel (CheckInViewModel)
- Service protocols: [Domain]Service protocol, SwiftData[Domain]Service
  concrete class
- Models: singular nouns (CheckIn, not CheckIns)

Swift style:
- Swift 6 strict concurrency — mark actors, Sendable conformances
- guard-let for early exits, not nested if-let
- No force unwraps — ever
- Enum-based constants (no magic strings or numbers)
- os.Logger for debugging, never print()

File organization:
- Feature-grouped folders under BetAway/
- Shared/ for reusable components, extensions, constants

Testing:
- Swift Testing framework, not XCTest
- Mock services conforming to protocols
- Test naming: test_[method]_[scenario]_[expected]

Do NOT list:
- No god classes, no singletons, no force unwraps
- No hardcoded API keys
- No UIKit unless absolutely necessary
- No third-party UI libraries
- Always plan before implementing multi-file features
```

### Reviewing the Output

When Claude Code generates the file, review it against these criteria:

- ✅ **Architecture is enforced, not suggested.** "ViewModels never import SwiftData" is a rule. "Try to keep data access separate" is a suggestion. You want rules.
- ✅ **Naming conventions have concrete examples.** Every naming rule should include at least one example. "Views: `[Feature]View` (e.g., `CheckInView`)" — the example removes all ambiguity.
- ✅ **The Do NOT section exists and is specific.** At least 5-7 explicit prohibitions. These are the highest-value lines in the entire file.
- ⚠️ **Watch for contradictions.** If one section says "use `@Observable`" and another mentions `ObservableObject`, fix it immediately. Contradictions make the AI guess, and guessing is what we are eliminating.
- ❌ **Reject generic filler.** If you see "write clean, maintainable code" or "follow industry best practices," delete it. Those phrases consume tokens and convey zero information.

## Iteration

The first draft will be close but not perfect. Send a follow-up:

```
Update the CLAUDE.md with these changes:

1. Add the complete folder structure for BetAway showing where
   every file type goes
2. In the coding standards section, add: "Use .task {} for async
   work in views, not .onAppear with Task {}"
3. Add a section about AI workflow rules: always plan multi-file
   features before implementing, explain reasoning when making
   architecture decisions, ask for clarification rather than
   guessing on ambiguous requirements
4. Make sure the Do NOT section includes: no AnyView, no
   hardcoded colors (use semantic colors or the design system),
   no business logic in Views
```

This iterative refinement is the same process we use for code. First draft, review, improve. The CLAUDE.md should go through at least two rounds before you trust it.

## Verify Phase

A CLAUDE.md is only valuable if it actually changes the AI's output. Here is how to test it.

**Test 1 — Architecture Compliance:**

```
Create a new ViewModel called SettingsViewModel that loads the
user's notification preferences.
```

Check: Does it use `@Observable`? Does it depend on a service protocol? Does it avoid importing SwiftData?

**Test 2 — Naming Conventions:**

```
Create the view and view model for a recovery statistics screen.
```

Check: Are the files named `RecoveryStatsView.swift` and `RecoveryStatsViewModel.swift`? Not `StatsScreen.swift` or `RecoveryStatisticsVM.swift`.

**Test 3 — The Do NOT Rules:**

```
Add a quick way to fetch recovery check-ins directly in the view.
```

This is a trap prompt. If the AI puts a `@Query` or SwiftData fetch directly in the view, your CLAUDE.md is not strong enough. It should route through the ViewModel and service.

If any test fails, strengthen the relevant rule. Make it more explicit, add an example, or move it higher in the file (rules near the top get more weight).

## Final Code

Here is the complete `CLAUDE.md` for BetAway. This is the exact file we will use for the rest of the course.

```markdown
# BetAway

Free gambling recovery app for iOS. Users track recovery streaks,
complete CBT-based therapy exercises, access crisis intervention,
and receive on-device ML insights about their recovery patterns.

## Tech Stack
- Language: Swift 6 (strict concurrency)
- UI: SwiftUI
- Persistence: SwiftData
- ML: Apple NaturalLanguage framework (on-device, offline-first)
- Minimum Target: iOS 17.0
- Architecture: MVVM + Service Layer

## Architecture

### MVVM + Service Layer Pattern
- Every screen has a View and a ViewModel
- ViewModels are `@Observable` classes (NOT ObservableObject)
- Views own ViewModels via `@State private var viewModel`
- Views are purely declarative — zero business logic
- ViewModels handle all business logic, data transformation, and state
- Services abstract all data access — ViewModels never import SwiftData
- ViewModels depend on service protocols, never concrete implementations
- Use initializer-based dependency injection

### Data Flow
```
View → ViewModel → Service Protocol → SwiftDataService → SwiftData
```

### File Organization
```
BetAway/
  App/
    BetAwayApp.swift
  Models/
    CheckIn.swift
    RecoveryInsight.swift
    UserSettings.swift
  Services/
    Protocols/
      RecoveryService.swift
      InsightService.swift
    SwiftData/
      SwiftDataRecoveryService.swift
      SwiftDataInsightService.swift
  ViewModels/
    DashboardViewModel.swift
    CheckInViewModel.swift
    InsightsViewModel.swift
    SettingsViewModel.swift
  Views/
    Dashboard/
      DashboardView.swift
      StreakCardView.swift
    CheckIn/
      CheckInView.swift
      RecoveryStatusPickerView.swift
    Insights/
      InsightsView.swift
      InsightCardView.swift
    Settings/
      SettingsView.swift
  Navigation/
    Router.swift
    AppRoutes.swift
  Shared/
    Components/
      RecoveryBadge.swift
      LoadingStateView.swift
    Extensions/
      Date+Formatting.swift
      Color+RecoveryTheme.swift
    Constants/
      AppConstants.swift
  Resources/
    Assets.xcassets
```

## Naming Conventions

### Types
- Views: `[Feature]View` — CheckInView, DashboardView, SettingsView
- ViewModels: `[Feature]ViewModel` — CheckInViewModel, DashboardViewModel
- Service protocols: `[Domain]Service` — RecoveryService
- Service implementations: `SwiftData[Domain]Service` — SwiftDataRecoveryService
- Models: singular nouns — CheckIn, RecoveryInsight, UserSettings
- Router: `Router` (one per app)

### Properties and Methods
- camelCase for all properties and methods
- Boolean prefix: `is`, `has`, `should` — isLoading, hasCheckIns, shouldRefresh
- Async methods: verb-first — fetchCheckIns(), saveCheckIn(), deleteInsight()
- Computed properties: noun or adjective — filteredCheckIns, isEmpty

### Constants
- Enum-based, never magic strings or numbers
- `AppConstants.animation.defaultDuration` not `0.3` scattered in code

## Coding Standards

### Swift 6 Concurrency
- Enable strict concurrency checking
- Mark ViewModels as `@MainActor`
- Mark service protocols with appropriate actor isolation
- Use `Sendable` conformance for types crossing isolation boundaries
- Use `async/await` for all asynchronous work

### Style Rules
- `guard let` / `guard else` for early exits — no nested `if let` chains
- No force unwraps (`!`) — ever. Use `guard`, `if let`, or nil coalescing
- No implicitly unwrapped optionals except `@IBOutlet` (which we do not use)
- Use `.task {}` for async work in views, not `.onAppear` with `Task {}`
- Use `os.Logger` for debugging, never `print()`
- Prefer smaller, composable views — extract when body exceeds ~40 lines
- Include `#Preview` for every view
- Format dates with user locale, never hardcode date formats

### Error Handling
- Define domain-specific error enums (RecoveryError, PersistenceError)
- User-facing errors must be human-readable
- Log technical details with `os.Logger`
- Surface errors in ViewModels via published error state
- Display errors using `.alert` modifier

## UI/UX Rules
- Follow Apple Human Interface Guidelines
- Use semantic colors (Color.primary, Color.secondary) and design system tokens
- Use SF Symbols for all icons — no custom icon assets unless necessary
- Support Dynamic Type — never hardcode font sizes
- Support Dark Mode — semantic colors only, no hardcoded color values
- Use NavigationStack (not deprecated NavigationView)
- Use `navigationDestination(for:)` for type-safe navigation
- Minimum tap target: 44x44 points
- Accessibility labels on all interactive elements

## Testing

### Framework
- Use Swift Testing (`import Testing`), not XCTest
- Test file naming: `[ClassName]Tests.swift`
- Test function naming: `test_[method]_[scenario]_[expectedResult]()`

### Strategy
- Unit test all ViewModel logic
- Use mock services conforming to service protocols
- Mock files go in `BetAwayTests/Mocks/`
- Test both success and failure paths
- Test edge cases: empty data, nil values, boundary dates

### Example
```swift
@Test func test_fetchCheckIns_emptyService_returnsEmptyArray() async {
    let mockService = MockRecoveryService(checkIns: [])
    let viewModel = DashboardViewModel(service: mockService)
    await viewModel.loadCheckIns()
    #expect(viewModel.checkIns.isEmpty)
}
```

## AI Workflow Rules
- ALWAYS plan before implementing features that touch multiple files
- Explain architectural reasoning when making design decisions
- Ask for clarification on ambiguous requirements — do not guess
- When creating a new feature: define the model first, then service
  protocol, then implementation, then ViewModel, then View
- Keep PRs focused — one feature per prompt when possible

## Do NOT
- Use singletons or the singleton pattern for any purpose
- Create god classes — if a file exceeds 200 lines, it likely needs splitting
- Access SwiftData directly from Views or ViewModels — always go through services
- Force unwrap optionals (`!`)
- Use `AnyView` — prefer concrete types or `@ViewBuilder`
- Use `ObservableObject` / `@Published` — use `@Observable` exclusively
- Use UIKit or UIViewRepresentable unless absolutely necessary
- Import third-party UI libraries (no SnapKit, no Kingfisher)
- Hardcode API keys or secrets — use environment configuration
- Hardcode colors — use semantic colors or design system tokens
- Put business logic in Views — Views are declarative UI only
- Use `print()` for logging — use `os.Logger`
- Skip `#Preview` — every view must have one
- Commit commented-out code
```

Let me walk through why this works.

**The architecture section is prescriptive, not descriptive.** It does not say "we use MVVM." It says exactly how data flows: `View → ViewModel → Service Protocol → SwiftDataService → SwiftData`. Any prompt Claude Code processes will follow that chain. If you ask for a new feature, the AI will create the service protocol first, then the implementation, then the ViewModel, then the view. Every time.

**The naming conventions include examples for every pattern.** There is no ambiguity about whether a service should be called `RecoveryRepo`, `RecoveryDataStore`, or `RecoveryService`. The rule says `[Domain]Service`, the example says `RecoveryService`. Done.

**The Do NOT section is long — and that is intentional.** Fourteen explicit prohibitions. Each one prevents a specific class of mistake that AI models commonly make. "No singletons" stops a pattern that appears in millions of training examples. "No AnyView" prevents a type erasure habit that kills SwiftUI performance. "No force unwraps" prevents runtime crashes. These lines will save you more debugging time than any other part of the file.

### Before and After

Here is what the same prompt produces with a bad CLAUDE.md versus our production one.

**Prompt:** "Add a way to delete a recovery check-in"

**With the vague CLAUDE.md** ("write clean code, use MVVM"):
```swift
// The AI might put this directly in the View
struct DashboardView: View {
    @Query var checkIns: [CheckIn]
    @Environment(\.modelContext) var context

    func delete(_ checkIn: CheckIn) {
        context.delete(checkIn)
        try? context.save()  // force try, no error handling
    }
}
```

Problems: SwiftData access in the View. No ViewModel. No service. Force try. No error handling. No separation of concerns.

**With our BetAway CLAUDE.md:**
```swift
// Service protocol
protocol RecoveryService {
    func delete(_ checkIn: CheckIn) async throws
}

// ViewModel
@Observable @MainActor
class DashboardViewModel {
    private let service: RecoveryService

    func deleteCheckIn(_ checkIn: CheckIn) async {
        do {
            try await service.delete(checkIn)
            checkIns.removeAll { $0.id == checkIn.id }
        } catch {
            self.error = error
        }
    }
}

// View — just calls the ViewModel
Button("Delete", role: .destructive) {
    Task { await viewModel.deleteCheckIn(checkIn) }
}
```

Same prompt. Radically different output. The CLAUDE.md did the work.

## Checkpoint

Before moving on, verify:

- [ ] `CLAUDE.md` exists in your BetAway project root
- [ ] Architecture section specifies MVVM + Service Layer with the data flow chain
- [ ] Naming conventions cover Views, ViewModels, Services, and Models with examples
- [ ] Swift style rules include strict concurrency, guard-let, no force unwraps, enum constants
- [ ] File organization shows the complete folder structure
- [ ] Testing section specifies Swift Testing, mock services, and naming conventions
- [ ] Do NOT section has at least 10 specific prohibitions
- [ ] You ran at least one test prompt and confirmed the AI follows the rules

## Challenge

**Write a CLAUDE.md extension for a new feature area.**

BetAway will eventually include a Charts module for visualizing recovery trends over time (we build this in Module 5). Write an additional section for the CLAUDE.md that covers:

- Chart-specific naming conventions
- What framework to use (hint: Swift Charts)
- Rules about data preparation (where does chart data transformation happen?)
- Accessibility requirements for charts

Add it to your existing CLAUDE.md and test it with this prompt:

```
Create a RecoveryChartView that shows recovery scores over the last 7 days
as a line chart.
```

Does the output follow your new rules?

<details>
<summary>Hint</summary>

Think about where chart data transformation should happen. It is the same answer as every other data question in this architecture — the ViewModel. The View should receive ready-to-render data points, not raw CheckIn arrays. Your section should specify something like: "Chart ViewModels transform raw model data into chart-ready structs. Views never perform data aggregation."

Also consider: should the chart section specify `import Charts` only in Views, or is it acceptable in ViewModels too? Since Charts is a UI framework, it belongs in the View layer.

</details>
