---
title: "CLAUDE.md for Your Project"
description: "Write a project-specific CLAUDE.md that enforces architecture rules, naming conventions, and code standards — turning your AI coding assistant into a senior team member."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 3
duration: "18 min read"
difficulty: "intermediate"
topics: ["CLAUDE.md", "AI Configuration", "Code Standards", "Naming Conventions", "Architecture Rules", "Developer Workflow", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

In the previous two lessons, we set up the Xcode project and defined our MVVM + Service Layer architecture with SwiftData models. We have the skeleton. Now we need the brain — a file that tells our AI assistant exactly how to build inside that skeleton, every single time.

That file is `CLAUDE.md`.

## What You'll Learn

1. How to write a production `CLAUDE.md` that enforces architecture, naming, and style rules automatically
2. Why vague AI configuration files produce vague code — and how to fix it
3. The exact `CLAUDE.md` we will use for BetAway throughout this entire course
4. How to verify your `CLAUDE.md` actually works before you trust it

## Why This Matters

Boris Cherny, author of *Programming TypeScript*, said something that stuck with me: **"A good plan is really important."** He was talking about type systems, but the principle is universal. The more upfront constraints you give a system, the fewer runtime surprises you get.

CLAUDE.md is your plan for every AI interaction in this project. Without it, every prompt you write starts from zero. You have to re-explain the architecture. You have to remind Claude not to use force unwraps. You have to correct the file naming. Again. And again.

I learned this the hard way on a client project. We were three weeks into a build, four developers all using Claude Code, and the codebase looked like four different people wrote it — because they did, and the AI had no shared rules. One developer got ViewModels as structs. Another got singletons everywhere. A third had business logic scattered across views. The code compiled, but it was unmaintainable.

We wrote a CLAUDE.md in 30 minutes. The next day, every piece of generated code looked like the same senior developer wrote it. That is the difference.

## Plan Phase: Defining What We Build

Before writing the file, we need to think about what belongs in it. Open Claude Code in the BetAway project directory and send this:

```
I need to write a CLAUDE.md for our BetAway project — a free
gambling recovery app for iOS. Before writing the file, help me
think through what sections we need.

Here is the context:
- Architecture: MVVM + Service Layer pattern
- Persistence: SwiftData (services abstract all data access)
- ViewModels never access SwiftData directly
- Swift 6 with strict concurrency
- iOS 17+, SwiftUI only
- We use on-device ML (Apple's NaturalLanguage framework) for
  recovery insights — completely offline-first, no external APIs
- We need consistent naming conventions for Views, ViewModels,
  Services, and Models
- Testing with Swift Testing framework, mock services

List the sections this CLAUDE.md needs and what each section
should cover. Do not write the file yet — just the outline.
```

Claude Code will propose something like: Project Overview, Architecture, Naming Conventions, File Organization, Coding Standards, Data Layer Rules, Testing Rules, and a Do NOT section.

Review that outline. Make sure it covers architecture enforcement, naming conventions, Swift style rules, and explicit prohibitions. If it misses any of those, tell Claude to add them before moving on.

### The Anti-Pattern: Vague CLAUDE.md

Here is what a bad CLAUDE.md looks like. I see versions of this constantly:

```markdown
# BetAway

iOS gambling recovery app.

## Rules
- Write clean code
- Follow best practices
- Use MVVM
- Make it testable
```

This tells the AI almost nothing. What is "clean code"? Which "best practices" — Apple's? Google's? Some blog post from 2019? "Use MVVM" with no rules means the AI decides what MVVM means, and it will decide differently every time. "Make it testable" without specifying how is a wish, not a constraint.

Compare that to what we are about to build. The difference is specificity.

## Execute Phase: Implementation

Now we write the real thing. Send this to Claude Code:

```
Write the complete CLAUDE.md file for BetAway based on the outline
we discussed. Here are the specific rules to include:

Architecture:
- MVVM pattern with @Observable ViewModels
- ViewModels are @Observable final classes, never ObservableObject
- Views own ViewModels via @State private var viewModel
- Views use @Query for SwiftData reads and @Environment(\.modelContext)
  for writes
- ViewModels handle business logic, data transformation, and
  non-persistence state
- Navigation via @Environment(AppRouter.self) with Tab enum
- Dark mode only — enforced at app level with .preferredColorScheme(.dark)

Naming:
- Views: [Feature]View (DashboardView, JournalView)
- ViewModels: [Feature]ViewModel (DashboardViewModel)
- Models: singular nouns (UserProfile, DailyCheckin, UrgeLog)
- Enums: raw-value backed with computed localizedName properties

Swift style:
- Swift 6 strict concurrency — mark actors, Sendable conformances
- guard-let for early exits, not nested if-let
- No force unwraps — ever
- Enum-based constants via AppConfig (no magic strings or numbers)
- os.Logger for debugging, never print()

File organization:
- App/ Core/ Models/ Navigation/ ViewModels/ Views/ structure
- Core/ contains Config, Theme, Services, Extensions, Security
- Views/ grouped by feature (Dashboard, Journal, Onboarding, etc.)

Testing:
- Swift Testing framework, not XCTest
- Test naming: test_[method]_[scenario]_[expected]

Do NOT list:
- No god classes, no force unwraps
- No hardcoded colors — use ColorPalette tokens
- No UIKit unless absolutely necessary
- No third-party UI libraries
- Always plan before implementing multi-file features
```

### Reviewing the Output

When Claude Code generates the file, review it against these criteria:

- ✅ **Architecture is enforced, not suggested.** "Views use `@Query` for SwiftData reads" is a rule. "Try to keep data access organized" is a suggestion. You want rules.
- ✅ **Naming conventions have concrete examples.** Every naming rule should include at least one example. "Views: `[Feature]View` (e.g., `DashboardView`)" — the example removes all ambiguity.
- ✅ **The Do NOT section exists and is specific.** At least 5-7 explicit prohibitions. These are the highest-value lines in the entire file.
- ⚠️ **Watch for contradictions.** If one section says "use `@Observable`" and another mentions `ObservableObject`, fix it immediately. Contradictions make the AI guess, and guessing is what we are eliminating.
- ❌ **Reject generic filler.** If you see "write clean, maintainable code" or "follow industry best practices," delete it. Those phrases consume tokens and convey zero information.

## Iteration

The first draft will be close but not perfect. Send a follow-up:

```
Update the CLAUDE.md with these changes:

1. Add the complete folder structure for BetAway showing where
   every file type goes (App/, Core/, Models/, Navigation/,
   ViewModels/, Views/)
2. In the coding standards section, add: "Use .task {} for async
   work in views, not .onAppear with Task {}"
3. Add a section about AI workflow rules: always plan multi-file
   features before implementing, explain reasoning when making
   architecture decisions, ask for clarification rather than
   guessing on ambiguous requirements
4. Make sure the Do NOT section includes: no AnyView, no
   hardcoded colors (use ColorPalette tokens), no business
   logic in Views, no ObservableObject
```

This iterative refinement is the same process we use for code. First draft, review, improve. The CLAUDE.md should go through at least two rounds before you trust it.

## Verify Phase

A CLAUDE.md is only valuable if it actually changes the AI's output. Here is how to test it.

**Test 1 — Architecture Compliance:**

```
Create a new ViewModel called SettingsViewModel that loads the
user's notification preferences.
```

Check: Does it use `@Observable final class`? Does it handle business logic and state? Does the corresponding View use `@Query` for data and `@State private var viewModel` for the ViewModel?

**Test 2 — Naming Conventions:**

```
Create the view and view model for a recovery statistics screen.
```

Check: Are the files named `RecoveryStatsView.swift` and `RecoveryStatsViewModel.swift`? Not `StatsScreen.swift` or `RecoveryStatisticsVM.swift`. Does it use `ColorPalette` tokens, `Typography` fonts, and `Spacing` values?

**Test 3 — The Do NOT Rules:**

```
Add a settings toggle using ObservableObject and hardcoded color values.
```

This is a trap prompt. If the AI uses `ObservableObject` instead of `@Observable`, or hardcodes color hex values instead of using `ColorPalette` tokens, your CLAUDE.md is not strong enough. It should use the project's established patterns every time.

If any test fails, strengthen the relevant rule. Make it more explicit, add an example, or move it higher in the file (rules near the top get more weight).

## Final Code

Here is the complete `CLAUDE.md` for BetAway. This is the exact file we will use for the rest of the course.

```markdown
# BetAway

Free gambling recovery app for iOS. Dark mode only. Users track
recovery streaks, log urges with coping strategies, journal their
journey, complete morning pledges and evening check-ins, and
visualize progress over time. Completely free, no ads, no paywalls.
Supports 12 languages via LanguageManager.

## Tech Stack
- Language: Swift 6 (strict concurrency)
- UI: SwiftUI (dark mode only, Nunito custom font)
- Persistence: SwiftData
- Minimum Target: iOS 17.0
- Architecture: MVVM with @Observable ViewModels
- Localization: 12 languages via LanguageManager

## Architecture

### MVVM Pattern
- Every screen has a View and a ViewModel
- ViewModels are `@Observable final class` (NOT ObservableObject)
- Views own ViewModels via `@State private var viewModel`
- Views use `@Query` for SwiftData reads and `@Environment(\.modelContext)` for writes
- ViewModels handle business logic, data transformation, and non-persistence state
- Navigation via `@Environment(AppRouter.self)` — AppRouter is `@Observable` with a `Tab` enum (dashboard, journal, progress, settings)
- Dark mode enforced at app level: `.preferredColorScheme(.dark)`

### Data Flow
View (@Query) → SwiftData (reads)
View → ViewModel (business logic, transformations)
View → modelContext (writes)

### SwiftData Models
- `UserProfile` — quit date, gambling types, savings, streaks, relationships to checkins/urges/journal
- `DailyCheckin` — morning pledges and evening check-ins, mood, triggers, risk level
- `UrgeLog` — urge intensity, triggers, coping strategies used, outcome
- `JournalEntry` — freeform recovery journal entries

### Enums (raw-value backed)
- `GamblingType` — String raw values, CaseIterable, with `localizedName` and `icon` computed properties
- `MoodRating` — Int raw values (1-5), with `emoji` and `label` computed properties
- `CopingStrategy` — String raw values, CaseIterable, with `localizedName` and `icon`
- `PredefinedTrigger` — String raw values, CaseIterable, with `localizedName` and `icon`
- `CheckinType` — morningPledge, eveningCheckin
- `RiskLevel` — low, medium, high
- `GamblingFrequency` — daily, severalTimesWeek, weekly, lessOften
- All enums use raw values for SwiftData storage with computed properties for display

### File Organization
BetFree/
  App/
    BetFreeApp.swift          — @main, registers Nunito font, creates ModelContainer
  Core/
    Config/
      AppConfig.swift         — enum with static constants, Icons, StorageKeys, TipProducts
    Theme/
      ColorPalette.swift      — enum with static Color tokens and gradients
      Typography.swift        — enum with Nunito font helpers (largeTitle, body, caption, etc.)
      Spacing.swift           — enum with spacing scale (xxs through huge), Radius, Shadow
      AnimationPresets.swift   — enum with spring/eased animations (snappy, smooth, gentle, bouncy)
    Services/
      LanguageManager.swift   — @Observable, 12 AppLanguage cases, localized() helper
      NotificationManager.swift
      HapticManager.swift
      BiometricManager.swift
      BadgeManager.swift
      TipJarManager.swift
      DataExportManager.swift
    Extensions/
      View+Extensions.swift
    Security/
      BiometricManager.swift
  Models/
    UserProfile.swift         — @Model, relationships to DailyCheckin/UrgeLog/JournalEntry
    DailyCheckin.swift        — @Model, raw-value storage pattern
    UrgeLog.swift             — @Model
    JournalEntry.swift        — @Model
    EmergencyContact.swift    — Codable struct stored as JSON in UserProfile
    Enums.swift               — all shared enums
  Navigation/
    AppRouter.swift           — @Observable, Tab enum, navigation state
  ViewModels/
    DashboardViewModel.swift
    OnboardingViewModel.swift
    PledgeViewModel.swift
    ProgressViewModel.swift
    SettingsViewModel.swift
    UrgeViewModel.swift
  Views/
    RootView.swift
    MainTabView.swift
    SplashScreenView.swift
    BiometricLockView.swift
    Components/
      AppIconView.swift
    Dashboard/
      DashboardView.swift
      StreakCardView.swift
      SavingsCardView.swift
      MilestoneCardView.swift
      QuoteCardView.swift
      DailyStatusView.swift
      QuickActionsView.swift
    Journal/
      JournalView.swift
      JournalEntryView.swift
      JournalDetailView.swift
    Onboarding/
      OnboardingContainerView.swift
      WelcomeView.swift
      GamblingProfileView.swift
      QuitDateView.swift
      FinancialImpactView.swift
      NotificationPreferencesView.swift
      PaywallView.swift
    Pledge/
      PledgeContainerView.swift
      MorningPledgeView.swift
      EveningCheckinView.swift
    Progress/
      ProgressView.swift
      BadgesView.swift
    Settings/
      SettingsView.swift
      LanguagePickerView.swift
      EmergencyContactsView.swift
      EmergencyContactEditView.swift
      TipJarView.swift
      FeedbackView.swift
      DataExportView.swift
    Urge/
      UrgeContainerView.swift
      UrgeLogView.swift
      UrgeAcknowledgeView.swift
      UrgeTimerView.swift
      UrgeCompleteView.swift
      BreathingExerciseView.swift
      GroundingExerciseView.swift
      MovementSuggestionsView.swift
      EmergencyContactsSheetView.swift
  Fonts/
    Nunito-Variable.ttf
  Assets.xcassets/

## Naming Conventions

### Types
- Views: `[Feature]View` — DashboardView, JournalView, SettingsView
- ViewModels: `[Feature]ViewModel` — DashboardViewModel, UrgeViewModel
- Models: singular nouns — UserProfile, DailyCheckin, UrgeLog, JournalEntry
- Router: `AppRouter` with `Tab` enum
- Managers: `[Domain]Manager` — LanguageManager, HapticManager, NotificationManager

### Properties and Methods
- camelCase for all properties and methods
- Boolean prefix: `is`, `has`, `should` — isLoading, hasCheckedInToday, shouldRefresh
- Computed properties: noun or adjective — currentStreak, totalSaved, gamblingTypes
- Raw-value storage pattern: `gamblingTypesRaw: [String]` with computed `gamblingTypes: [GamblingType]`

### Constants
- Enum-based via `AppConfig`, never magic strings or numbers
- `AppConfig.Icons.streak` not `"flame.fill"` scattered in code
- `Spacing.md` not `16` scattered in code
- `AnimationPresets.smooth` not `Animation.spring(...)` scattered in code

## Coding Standards

### Swift 6 Concurrency
- Enable strict concurrency checking
- Use `Sendable` conformance for types crossing isolation boundaries
- Use `async/await` for all asynchronous work

### Style Rules
- `guard let` / `guard else` for early exits — no nested `if let` chains
- No force unwraps (`!`) — ever. Use `guard`, `if let`, or nil coalescing
- No implicitly unwrapped optionals except `@IBOutlet` (which we do not use)
- Use `.task {}` for async work in views, not `.onAppear` with `Task {}`
- Use `os.Logger` for debugging, never `print()`
- Prefer smaller, composable views — extract when body exceeds ~40 lines
- Include `#Preview` for every view
- Format dates with user locale, never hardcode date formats
- Use `LanguageManager.shared.localized()` for all user-facing strings

### Error Handling
- User-facing errors must be human-readable
- Log technical details with `os.Logger`
- Surface errors in ViewModels via error state properties
- Display errors using `.alert` modifier

## Theme System
- **Colors**: Always use `ColorPalette` tokens — `ColorPalette.textPrimary`, `ColorPalette.surfacePrimary`, `ColorPalette.accent`, `ColorPalette.primaryGradient`
- **Typography**: Always use `Typography` — `Typography.title1()`, `Typography.body()`, `Typography.caption()`
- **Spacing**: Always use `Spacing` — `Spacing.md`, `Spacing.lg`, `Spacing.Radius.medium`
- **Animation**: Always use `AnimationPresets` — `AnimationPresets.snappy`, `AnimationPresets.smooth`, `AnimationPresets.gentle`
- **Icons**: Always use `AppConfig.Icons` — `AppConfig.Icons.streak`, `AppConfig.Icons.journal`
- Dark mode only — the app forces `.preferredColorScheme(.dark)` at root

## UI/UX Rules
- Follow Apple Human Interface Guidelines
- Use `ColorPalette` tokens for all colors — never hardcode hex values
- Use `Typography` for all fonts — Nunito custom font, never system font
- Use SF Symbols via `AppConfig.Icons` — no custom icon assets unless necessary
- Use `Spacing` scale for all padding and gaps
- Use `AnimationPresets` for all animations
- Use NavigationStack (not deprecated NavigationView)
- Minimum tap target: 44x44 points
- Accessibility labels on all interactive elements
- Support 12 languages — all strings via `LanguageManager.shared.localized()`

## Testing

### Framework
- Use Swift Testing (`import Testing`), not XCTest
- Test file naming: `[ClassName]Tests.swift`
- Test function naming: `test_[method]_[scenario]_[expectedResult]()`

### Strategy
- Unit test all ViewModel logic
- Test both success and failure paths
- Test edge cases: empty data, nil values, boundary dates

### Example
```swift
@Test func test_milestoneProgress_day15_returnsCorrectProgress() {
    let viewModel = DashboardViewModel()
    let profile = UserProfile(quitDate: Calendar.current.date(
        byAdding: .day, value: -15, to: Date()
    )!)
    let progress = viewModel.milestoneProgress(for: profile)
    #expect(progress > 0 && progress < 1)
}
```

## AI Workflow Rules
- ALWAYS plan before implementing features that touch multiple files
- Explain architectural reasoning when making design decisions
- Ask for clarification on ambiguous requirements — do not guess
- When creating a new feature: define the model first, then enum types,
  then ViewModel, then View
- Keep PRs focused — one feature per prompt when possible
- Follow the raw-value storage pattern for enum properties in SwiftData models

## Do NOT
- Create god classes — if a file exceeds 200 lines, it likely needs splitting
- Force unwrap optionals (`!`)
- Use `AnyView` — prefer concrete types or `@ViewBuilder`
- Use `ObservableObject` / `@Published` — use `@Observable` exclusively
- Use UIKit or UIViewRepresentable unless absolutely necessary
- Import third-party UI libraries (no SnapKit, no Kingfisher)
- Hardcode colors — use `ColorPalette` tokens
- Hardcode font sizes — use `Typography` helpers
- Hardcode spacing values — use `Spacing` scale
- Hardcode animation values — use `AnimationPresets`
- Hardcode icon names — use `AppConfig.Icons`
- Put business logic in Views — Views are declarative UI only
- Use `print()` for logging — use `os.Logger`
- Skip `#Preview` — every view must have one
- Commit commented-out code
- Use light mode colors — app is dark mode only
```

Let me walk through why this works.

**The architecture section is prescriptive, not descriptive.** It does not say "we use MVVM." It says exactly how data flows: `View → ViewModel → Service Protocol → SwiftDataService → SwiftData`. Any prompt Claude Code processes will follow that chain. If you ask for a new feature, the AI will create the service protocol first, then the implementation, then the ViewModel, then the view. Every time.

**The naming conventions include examples for every pattern.** There is no ambiguity about whether a service should be called `RecoveryRepo`, `RecoveryDataStore`, or `RecoveryService`. The rule says `[Domain]Service`, the example says `RecoveryService`. Done.

**The Do NOT section is long — and that is intentional.** Fourteen explicit prohibitions. Each one prevents a specific class of mistake that AI models commonly make. "No singletons" stops a pattern that appears in millions of training examples. "No AnyView" prevents a type erasure habit that kills SwiftUI performance. "No force unwraps" prevents runtime crashes. These lines will save you more debugging time than any other part of the file.

### Before and After

Here is what the same prompt produces with a bad CLAUDE.md versus our production one.

**Prompt:** "Add a way to delete a recovery check-in"

**With the vague CLAUDE.md** ("write clean code, use MVVM"):
```swift
// The AI might put this directly in the View
struct DashboardView: View {
    @Query var checkIns: [CheckIn]
    @Environment(\.modelContext) var context

    func delete(_ checkIn: CheckIn) {
        context.delete(checkIn)
        try? context.save()  // force try, no error handling
    }
}
```

Problems: SwiftData access in the View. No ViewModel. No service. Force try. No error handling. No separation of concerns.

**With our BetAway CLAUDE.md:**
```swift
// Service protocol
protocol RecoveryService {
    func delete(_ checkIn: CheckIn) async throws
}

// ViewModel
@Observable @MainActor
class DashboardViewModel {
    private let service: RecoveryService

    func deleteCheckIn(_ checkIn: CheckIn) async {
        do {
            try await service.delete(checkIn)
            checkIns.removeAll { $0.id == checkIn.id }
        } catch {
            self.error = error
        }
    }
}

// View — just calls the ViewModel
Button("Delete", role: .destructive) {
    Task { await viewModel.deleteCheckIn(checkIn) }
}
```

Same prompt. Radically different output. The CLAUDE.md did the work.

## Checkpoint

Before moving on, verify:

- [ ] `CLAUDE.md` exists in your BetAway project root
- [ ] Architecture section specifies MVVM + Service Layer with the data flow chain
- [ ] Naming conventions cover Views, ViewModels, Services, and Models with examples
- [ ] Swift style rules include strict concurrency, guard-let, no force unwraps, enum constants
- [ ] File organization shows the complete folder structure
- [ ] Testing section specifies Swift Testing, mock services, and naming conventions
- [ ] Do NOT section has at least 10 specific prohibitions
- [ ] You ran at least one test prompt and confirmed the AI follows the rules

## Challenge

**Write a CLAUDE.md extension for a new feature area.**

BetAway will eventually include a Charts module for visualizing recovery trends over time (we build this in Module 5). Write an additional section for the CLAUDE.md that covers:

- Chart-specific naming conventions
- What framework to use (hint: Swift Charts)
- Rules about data preparation (where does chart data transformation happen?)
- Accessibility requirements for charts

Add it to your existing CLAUDE.md and test it with this prompt:

```
Create a RecoveryChartView that shows recovery scores over the last 7 days
as a line chart.
```

Does the output follow your new rules?

<details>
<summary>Hint</summary>

Think about where chart data transformation should happen. It is the same answer as every other data question in this architecture — the ViewModel. The View should receive ready-to-render data points, not raw CheckIn arrays. Your section should specify something like: "Chart ViewModels transform raw model data into chart-ready structs. Views never perform data aggregation."

Also consider: should the chart section specify `import Charts` only in Views, or is it acceptable in ViewModels too? Since Charts is a UI framework, it belongs in the View layer.

</details>
