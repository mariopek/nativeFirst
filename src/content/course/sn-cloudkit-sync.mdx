---
title: "CloudKit Sync"
description: "Add multi-device sync to BetAway with SwiftData's CloudKit integration — configure the container, handle merge conflicts, and test sync between simulator and device."
courseSlug: "ship-native"
module: 9
moduleTitle: "Bonus: Advanced Topics"
lesson: 1
duration: "24 min read"
difficulty: "advanced"
topics: ["CloudKit", "SwiftData Sync", "iCloud", "Conflict Resolution", "Multi-Device", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Your users have an iPhone and an iPad. They log a check-in on the train with their phone, then open the iPad at home and expect to see it there. If it is not there, they do not file a bug report — they just stop using your app. Multi-device sync is not a feature. It is table stakes.

The good news: SwiftData and CloudKit were designed to work together. The bad news: "designed to work together" does not mean "works without thinking." Merge conflicts, network failures, and sync delays are real, and ignoring them produces an app that silently loses data. This lesson gets you through the full setup, the conflict resolution strategy, and the testing workflow you need to ship sync with confidence.

## What You'll Learn

- How to enable CloudKit sync in a SwiftData `ModelConfiguration` with a single property change and configure the iCloud container in Xcode
- What CloudKit-compatibility constraints apply to your SwiftData model — and why `@Attribute(.unique)` breaks everything
- Merge conflict strategies (last-write-wins vs. custom resolution) and how SwiftData handles them by default
- A testing workflow for verifying sync between simulator instances and physical devices, including offline-to-online transitions

## Why This Matters

Users expect their data to follow them across devices. Apple makes this possible through iCloud and CloudKit, and SwiftData's integration means you do not need to build a backend, manage authentication, or run a server. But the abstraction is leaky — sync is eventually consistent, not instant, and merge conflicts are silent unless you handle them. Understanding what happens under the hood is the difference between "sync works" and "sync works until two devices edit the same entry, then one user's data disappears."

## Plan Phase: Designing the CloudKit Integration

Open plan mode and think through the full integration before writing code:

```
I want to add iCloud sync to BetAway using SwiftData's CloudKit
integration.

Current setup:
- SwiftData ModelContainer with CheckIn model
- CheckIn has: id (UUID), recoveryStatus (Int), note (String), date (Date),
  aiInsight (String?)
- Local persistence already works (from Module 3)
- Swift 6 strict concurrency, iOS 17+

Plan the CloudKit integration:
1. What changes to ModelConfiguration are needed?
2. What Xcode capabilities and entitlements must I add?
3. What iCloud container do I need and how do I create it?
4. What happens when two devices edit the same CheckIn? What is
   SwiftData's default conflict resolution?
5. What model constraints affect CloudKit compatibility? (e.g.,
   unique constraints, optional vs required fields, relationships)
6. What does NOT sync? (e.g., @Transient properties)
7. How do I test sync without two physical devices?
8. How do I handle the app being offline?

Do not generate code yet. Plan first.
```

### AI Plan Review

The AI plan should contain these specific items. If any are missing, push back before moving to code:

- ✅ **ModelConfiguration change** — set `cloudKitDatabase: .automatic` (or `.private`) on the `ModelConfiguration`. That is the entire SwiftData change to enable sync. If the plan says to import CloudKit and manually create `CKContainer` instances, it is overcomplicating things.
- ✅ **Xcode capabilities** — iCloud capability with CloudKit checked, plus Background Modes with "Remote notifications" enabled. CloudKit uses silent push notifications to trigger sync between devices.
- ✅ **Container identifier** — an iCloud container identifier like `iCloud.com.yourname.betaway`, created in the Apple Developer portal or automatically by Xcode when you check the CloudKit capability.
- ✅ **Entitlements** — `com.apple.developer.icloud-container-identifiers` and `com.apple.developer.icloud-services` with `CloudKit` value in the entitlements file.
- ✅ **Conflict resolution** — SwiftData with CloudKit uses last-write-wins by default. The most recent change (by device timestamp) overwrites the older one. No merge, no prompt. If the plan describes field-level merging as a built-in feature, it is wrong.
- ⚠️ **CloudKit limitations** — `@Attribute(.unique)` constraints are **not supported** with CloudKit. All properties should be optional or have default values. `@Transient` properties do not sync. Relationships must be optional. If the plan does not mention the `@Attribute(.unique)` restriction, flag it. This is the single most common cause of "sync just does not work" bugs.
- ⚠️ **Testing strategy** — use two simulator instances signed into the same iCloud account, or one simulator plus one physical device. The CloudKit Dashboard at `console.developer.apple.com` shows records in real time.
- ❌ If the plan says to use `NSPersistentCloudKitContainer` directly — reject. SwiftData wraps this internally. You should not be creating Core Data containers alongside SwiftData.
- ❌ If the plan ignores offline handling — push back. SwiftData queues changes locally and syncs when connectivity returns. No extra code is needed for basic offline support, but you should know this behavior exists.

### Anti-Pattern: Assuming Instant Sync

```
Just enable CloudKit and it will sync automatically
```

Technically true. Practically misleading. CloudKit sync is eventually consistent, meaning changes can take seconds to minutes to propagate depending on network conditions, iCloud account status, and Apple's server load. If your tests assume instant sync, they will be flaky. If your UI assumes instant sync, users will think the app is broken. Plan for latency from the start.

## Execute Phase: Building the Sync Layer

We need two things: an updated model that is CloudKit-compatible and a container configuration that enables sync.

### Step 1: Model Compatibility

First, make sure the data model works with CloudKit:

```
Review and update the CheckIn SwiftData model for CloudKit
compatibility.

Current model:
@Model
final class CheckIn {
    var id: UUID
    var recoveryStatus: Int
    var note: String
    var date: Date
    var aiInsight: String?
}

Requirements for CloudKit sync:
1. Remove any @Attribute(.unique) constraints (not supported)
2. Ensure all non-optional properties have default values
3. Mark properties that should NOT sync as @Transient
4. Add a lastModified timestamp for conflict debugging
5. Keep Swift 6 strict concurrency compliance

Generate the updated model.
```

### Code Review

Review the AI output against these criteria:

- ✅ No `@Attribute(.unique)` on any property — CloudKit manages its own record identifiers via `CKRecord.ID`
- ✅ All properties have default values — CloudKit requires this for new fields added in future schema versions
- ✅ `aiInsight` remains optional, which is correct
- ✅ `lastModified` property added with a default of `Date.now` for conflict debugging
- ⚠️ If the AI added `@Transient` to `aiInsight` — discuss whether you want insights to sync. If the user switches devices, do they want to re-generate insights or see the original? There is no universal right answer, but the decision should be intentional
- ❌ If the AI kept `@Attribute(.unique)` on `id` — reject. A unique constraint on UUID will cause sync failures with cryptic Core Data errors in the console
- ❌ If the AI added explicit `CKRecord` handling — reject. SwiftData abstracts this entirely

### Step 2: Container Configuration

```
Generate the updated ModelContainer configuration for BetAway with
CloudKit sync enabled.

Requirements:
1. Update BetAwayApp.swift to use a ModelConfiguration with
   cloudKitDatabase set to .automatic
2. Set the container identifier to "iCloud.com.yourname.betaway"
3. Keep the existing local-only fallback for previews and tests
4. Add a static method that creates an in-memory, non-syncing
   container for SwiftUI previews
5. Log sync status using os.Logger
6. Handle the case where the user is not signed into iCloud
   gracefully (the app should still work locally)

Swift 6 strict concurrency. Zero warnings.
```

### Code Review

- ✅ `ModelConfiguration` uses `cloudKitDatabase: .automatic`
- ✅ Container identifier string matches the format `iCloud.com.yourname.betaway`
- ✅ Preview container uses `cloudKitDatabase: .none` and `isStoredInMemoryOnly: true`
- ✅ No force unwrapping on container creation
- ⚠️ If it does not handle the "not signed into iCloud" case — the app will still work (SwiftData falls back to local), but logging a warning helps debugging
- ❌ If it uses a hardcoded `cloudKitContainerIdentifier` that does not match the entitlements — sync will silently fail with no user-visible error

## Iteration: Adding Sync Visibility

After reviewing the generated model and container code, we need a way to see what is happening. Silent sync is fine for users, but during development you need visibility:

```
Good. Now add these improvements:

1. Create a SyncMonitor class that listens to
   NSPersistentCloudKitContainer.eventChangedNotification to track
   sync status (importing, exporting, idle, error)
2. Expose the sync status as an @Observable property so the UI can
   show a subtle sync indicator
3. Add a method to check if iCloud is available using
   FileManager.default.ubiquityIdentityToken
4. Log all sync events with os.Logger including the event type and
   any errors
5. Make SyncMonitor @MainActor for safe UI binding

Keep it minimal. We are not building a full sync engine — just enough
visibility to debug issues and inform the user.
```

Then add the UI component:

```
Create a small SyncStatusView that reads from SyncMonitor and shows:
- A green checkmark.icloud icon when idle
- A rotating arrow.triangle.2.circlepath.icloud when syncing
- A red exclamationmark.icloud when there is an error
- An icloud.slash icon when no iCloud account is available

Use SF Symbols and keep it small enough to put in a toolbar or
settings screen. Use .symbolEffect for the rotation animation.
```

## Verify Phase: Testing Sync End-to-End

CloudKit sync requires careful testing because failures are often silent. Work through this verification plan:

**Xcode configuration:**
1. Target > Signing & Capabilities > iCloud: CloudKit is checked
2. Container identifier matches your `ModelConfiguration`
3. Background Modes capability added with "Remote notifications" enabled
4. Entitlements file contains `com.apple.developer.icloud-container-identifiers` with the correct container
5. Build and run — zero errors, zero warnings

**CloudKit Dashboard:**
1. Open [CloudKit Console](https://icloud.developer.apple.com/)
2. Select your container
3. Navigate to the "Development" environment
4. Check that SwiftData has created the record types matching your model (this happens on first launch)
5. You should see a record type for `CheckIn` with fields matching your properties

**Sync testing — two simulators:**
1. Open two iOS Simulator instances (Xcode > Open Developer Tool > Simulator, then File > New Simulator)
2. Sign both into the same iCloud account (Settings > Apple ID)
3. Run the app on Simulator A, create a check-in
4. Wait 10-30 seconds
5. Run the app on Simulator B — the entry should appear
6. Edit the entry on Simulator B, wait, confirm the edit appears on Simulator A

**Offline-to-online transition:**
1. Enable Airplane Mode on the simulator (or use Network Link Conditioner)
2. Create three recovery check-ins while offline
3. Disable Airplane Mode
4. Confirm all three entries sync to the other device within 60 seconds

**Conflict test:**
1. On Device A, open an entry for editing but do not save yet
2. On Device B, edit the same entry and save
3. On Device A, save your edit
4. Observe which version wins (should be the last save — Device A)
5. Confirm no data loss and no crash

## Final Code

### CloudKitConfiguration.swift

This file centralizes all CloudKit-related configuration so the rest of the app does not need to know the details:

```swift
import Foundation
import SwiftData
import os

/// Centralizes CloudKit and ModelContainer configuration for BetAway.
enum CloudKitConfiguration {
    private static let logger = Logger(
        subsystem: "com.nativefirst.betaway.app",
        category: "CloudKit"
    )

    /// The iCloud container identifier. Must match the entitlements file.
    static let containerIdentifier = "iCloud.com.yourname.betaway"

    /// Creates the production ModelContainer with CloudKit sync enabled.
    ///
    /// If the user is not signed into iCloud, SwiftData falls back to
    /// local-only persistence automatically — no extra handling needed.
    static func makeProductionContainer() -> ModelContainer {
        do {
            let configuration = ModelConfiguration(
                "BetAway",
                schema: Schema([CheckIn.self]),
                cloudKitDatabase: .automatic
            )
            let container = try ModelContainer(
                for: CheckIn.self,
                configurations: [configuration]
            )
            logger.info("ModelContainer created with CloudKit sync enabled.")
            return container
        } catch {
            logger.fault(
                "Failed to create ModelContainer: \(error.localizedDescription)"
            )
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }

    /// Creates an in-memory container for SwiftUI previews. No sync.
    static func makePreviewContainer() -> ModelContainer {
        let configuration = ModelConfiguration(
            isStoredInMemoryOnly: true,
            cloudKitDatabase: .none
        )
        do {
            return try ModelContainer(
                for: CheckIn.self,
                configurations: [configuration]
            )
        } catch {
            fatalError("Preview container failed: \(error)")
        }
    }

    /// Checks whether the user has an active iCloud account.
    ///
    /// This does not guarantee sync will work — the user might have
    /// disabled iCloud Drive for this app — but it catches the most
    /// common case: not signed in at all.
    static func isCloudAvailable() -> Bool {
        let token = FileManager.default.ubiquityIdentityToken
        if token == nil {
            logger.warning("No iCloud account detected. Data is local only.")
        }
        return token != nil
    }
}
```

### CheckIn.swift (Updated for CloudKit)

```swift
import Foundation
import SwiftData

/// A single recovery app entry, synced across devices via CloudKit.
///
/// CloudKit compatibility rules enforced here:
/// - No @Attribute(.unique) constraints
/// - All non-optional properties have default values
/// - @Transient properties are local-only and do not sync
@Model
final class CheckIn {
    /// Stable identifier for the entry.
    /// NOT marked @Attribute(.unique) — CloudKit manages its own
    /// record IDs and unique constraints break sync.
    var id: UUID = UUID()

    /// Recovery status rating from 1 (lowest) to 5 (highest).
    var recoveryStatus: Int = 3

    /// User-written note accompanying the check-in.
    var note: String = ""

    /// When the entry was created.
    var date: Date = Date.now

    /// When the entry was last modified on any device.
    /// Used for debugging conflict resolution — the entry with the
    /// latest lastModified timestamp wins in a conflict.
    var lastModified: Date = Date.now

    /// AI-generated insight. Nil if not yet generated.
    /// Syncs across devices so the user does not re-generate insights.
    var aiInsight: String?

    /// Local-only flag for entries pending AI analysis.
    /// Not synced — Device A waiting for an API response does not
    /// concern Device B.
    @Transient
    var isPendingAnalysis: Bool = false

    init(
        recoveryStatus: Int,
        note: String,
        date: Date = .now
    ) {
        self.id = UUID()
        self.recoveryStatus = recoveryStatus
        self.note = note
        self.date = date
        self.lastModified = .now
        self.aiInsight = nil
        self.isPendingAnalysis = false
    }
}
```

### BetAwayApp.swift (Updated with CloudKit Container)

```swift
import SwiftUI
import SwiftData
import os

@main
struct BetAwayApp: App {
    private static let logger = Logger(
        subsystem: "com.nativefirst.betaway.app",
        category: "App"
    )

    @State private var router = AppRouter()
    @State private var syncMonitor = SyncMonitor()
    let modelContainer: ModelContainer

    init() {
        self.modelContainer = CloudKitConfiguration.makeProductionContainer()
    }

    var body: some Scene {
        WindowGroup {
            NavigationStack(path: $router.path) {
                HomeView()
                    .navigationDestination(for: AppRouter.Route.self) { route in
                        router.destination(for: route)
                    }
            }
            .environment(\.router, router)
            .environment(syncMonitor)
        }
        .modelContainer(modelContainer)
    }
}
```

### SyncMonitor.swift

```swift
import Foundation
import CoreData
import os

/// Observes CloudKit sync events and exposes status for the UI.
///
/// SyncMonitor listens to NSPersistentCloudKitContainer notifications
/// (which SwiftData fires internally) and translates them into a
/// simple status enum that views can observe.
@MainActor
@Observable
final class SyncMonitor {
    private let logger = Logger(
        subsystem: "com.nativefirst.betaway.app",
        category: "Sync"
    )

    /// Current sync status.
    enum Status: String, Sendable {
        case idle = "Up to date"
        case importing = "Downloading..."
        case exporting = "Uploading..."
        case error = "Sync error"
        case noAccount = "No iCloud account"
    }

    /// The current sync status, observable by SwiftUI views.
    private(set) var status: Status = .idle

    /// Whether iCloud is available on this device.
    private(set) var isCloudAvailable: Bool = false

    /// The last time a sync export completed successfully.
    /// Useful for displaying "Last synced: 2 minutes ago" in settings.
    private(set) var lastSyncDate: Date?

    init() {
        checkCloudAvailability()
        startObserving()
    }

    /// Checks whether the user is signed into iCloud.
    private func checkCloudAvailability() {
        isCloudAvailable = CloudKitConfiguration.isCloudAvailable()
        if !isCloudAvailable {
            status = .noAccount
        }
    }

    /// Subscribes to CloudKit sync event notifications.
    ///
    /// SwiftData uses NSPersistentCloudKitContainer internally, so these
    /// notifications fire even though we never create the container ourselves.
    private func startObserving() {
        NotificationCenter.default.addObserver(
            forName: NSPersistentCloudKitContainer.eventChangedNotification,
            object: nil,
            queue: nil
        ) { [weak self] notification in
            guard let event = notification.userInfo?[
                NSPersistentCloudKitContainer.eventNotificationUserInfoKey
            ] as? NSPersistentCloudKitContainer.Event else {
                return
            }
            Task { @MainActor [weak self] in
                self?.handleSyncEvent(event)
            }
        }
    }

    /// Maps a CloudKit sync event to a user-visible status.
    private func handleSyncEvent(
        _ event: NSPersistentCloudKitContainer.Event
    ) {
        if let error = event.error {
            status = .error
            logger.error(
                "Sync error (\(event.type.label)): \(error.localizedDescription)"
            )
            return
        }

        if event.endDate == nil {
            // Event is in progress.
            switch event.type {
            case .import:
                status = .importing
                logger.debug("Sync: importing from CloudKit.")
            case .export:
                status = .exporting
                logger.debug("Sync: exporting to CloudKit.")
            case .setup:
                logger.debug("Sync: setup in progress.")
            @unknown default:
                logger.debug("Sync: unknown event type.")
            }
        } else {
            // Event finished successfully.
            if event.type == .export {
                lastSyncDate = Date.now
            }
            status = .idle
            logger.debug("Sync: \(event.type.label) completed.")
        }
    }
}

// MARK: - Event Type Label

extension NSPersistentCloudKitContainer.EventType {
    var label: String {
        switch self {
        case .setup:  return "setup"
        case .import: return "import"
        case .export: return "export"
        @unknown default: return "unknown"
        }
    }
}
```

### SyncStatusView.swift

```swift
import SwiftUI

/// A small indicator showing the current CloudKit sync status.
///
/// Place this in a toolbar, settings screen, or anywhere you want
/// a subtle indicator of sync health. It stays small and unobtrusive.
struct SyncStatusView: View {
    @Environment(SyncMonitor.self) private var syncMonitor

    var body: some View {
        HStack(spacing: 6) {
            statusIcon
                .font(.caption)
            Text(syncMonitor.status.rawValue)
                .font(.caption2)
                .foregroundStyle(.secondary)
        }
        .animation(.easeInOut(duration: 0.3), value: syncMonitor.status)
    }

    @ViewBuilder
    private var statusIcon: some View {
        switch syncMonitor.status {
        case .idle:
            Image(systemName: "checkmark.icloud")
                .foregroundStyle(.green)
        case .importing, .exporting:
            Image(systemName: "arrow.triangle.2.circlepath.icloud")
                .foregroundStyle(.blue)
                .symbolEffect(.rotate, isActive: true)
        case .error:
            Image(systemName: "exclamationmark.icloud")
                .foregroundStyle(.red)
        case .noAccount:
            Image(systemName: "icloud.slash")
                .foregroundStyle(.secondary)
        }
    }
}

#Preview {
    SyncStatusView()
        .environment(SyncMonitor())
}
```

### Key Design Decisions

**Why `cloudKitDatabase: .automatic` instead of `.private`?** The `.automatic` option uses the private database by default but allows Apple to determine the best configuration. For most apps, this is the right choice. Use `.private` explicitly only if you need to guarantee no data touches a public or shared database.

**Why no `@Attribute(.unique)` on `id`?** CloudKit manages record identity internally using `CKRecord.ID`. Adding a unique constraint on your own `id` field causes the persistent store coordinator to throw merge errors during sync, because CloudKit's conflict resolution operates at the record level, not the field level. Your `id` is still useful as a stable application-level identifier — just do not enforce uniqueness at the database level.

**Why last-write-wins?** SwiftData with CloudKit does not offer built-in field-level merge. The entire record is replaced by whichever device wrote last (by timestamp). For a recovery app, this is acceptable — users rarely edit the same entry on two devices simultaneously. For collaborative apps (shared documents, team task lists), you would need a custom merge strategy or a different sync backend entirely.

**Why `@Transient` on `isPendingAnalysis`?** This flag is a local UI concern. If Device A is waiting for an AI response, Device B does not need to know. Syncing transient state creates unnecessary network traffic and confusing UX where one device shows a spinner for another device's network request.

## Checkpoint

Before considering CloudKit sync complete, verify every item:

1. iCloud capability added in Xcode with CloudKit checked
2. Background Modes capability added with "Remote notifications" enabled
3. Container identifier matches between Xcode entitlements and `ModelConfiguration`
4. `CheckIn` has no `@Attribute(.unique)` constraints on any property
5. All non-optional properties in `CheckIn` have default values
6. App builds and runs with zero warnings under Swift 6 strict concurrency
7. CloudKit Dashboard shows the `CheckIn` record type after first launch
8. Creating an entry on Device A appears on Device B within 60 seconds
9. Editing an entry on one device reflects on the other
10. Deleting an entry on one device removes it from the other
11. App works normally when iCloud is unavailable (local-only fallback)
12. `SyncMonitor` logs sync events in the Xcode console
13. Creating entries offline and then going online results in successful sync

## Challenge

**Implement a manual sync status indicator in the Settings screen.**

Add `SyncStatusView` to the Settings screen. Below the status indicator, show the last successful sync time. Add a "Sync Now" button that triggers a save on the `ModelContext` to nudge the persistent store into attempting an export. If `isCloudAvailable` is false, show a message directing the user to sign into iCloud in Settings.

<details>
<summary>Hint</summary>

The last sync time is already tracked in `SyncMonitor.lastSyncDate`. Display it with a relative format:

```swift
if let lastSync = syncMonitor.lastSyncDate {
    Text("Last synced: \(lastSync, format: .relative(presentation: .named))")
        .font(.caption)
        .foregroundStyle(.secondary)
}
```

The "Sync Now" button triggers a context save, which prompts the CloudKit integration to check for pending changes:

```swift
@Environment(\.modelContext) private var modelContext

Button("Sync Now") {
    try? modelContext.save()
}
.disabled(!syncMonitor.isCloudAvailable)
```

This does not force an immediate sync — CloudKit decides the actual timing — but it ensures any unsaved local changes are flushed to the persistent store where the sync engine can pick them up. For the "no account" state:

```swift
if !syncMonitor.isCloudAvailable {
    ContentUnavailableView(
        "iCloud Not Available",
        systemImage: "icloud.slash",
        description: Text("Sign into iCloud in Settings to sync your recovery check-ins across devices.")
    )
}
```
</details>

---

Next up: **Bonus Lesson 9.2 — Share Extension & Beyond**, where we build a Share Extension for quick check-in logging from any app and chart your path forward as an AI-augmented iOS developer.
