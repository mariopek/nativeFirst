---
title: "CloudKit Sync"
description: "Add multi-device sync to Moodbit with SwiftData's CloudKit integration — configure the container, handle merge conflicts, and test sync between simulator and device."
courseSlug: "ship-native"
module: 9
moduleTitle: "Bonus — Advanced Patterns"
lesson: 1
duration: "22 min read"
difficulty: "advanced"
topics: ["CloudKit", "Sync", "SwiftData", "Multi-Device", "Conflict Resolution", "iCloud", "Moodbit"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Your users have an iPhone and an iPad. They log a mood on the train with their phone, then open the iPad at home and expect to see it there. If it is not there, they do not file a bug report — they just stop using your app. Multi-device sync is not a feature. It is table stakes.

The good news: SwiftData and CloudKit were designed to work together. The bad news: "designed to work together" does not mean "works without thinking." Merge conflicts, network failures, and sync delays are real, and ignoring them produces an app that silently loses data. This lesson gets you through the full setup, the gotchas, and the testing strategy.

## What You'll Learn

- How to enable CloudKit sync in a SwiftData `ModelConfiguration` with a single line change
- How to configure the iCloud container, entitlements, and capabilities in Xcode
- Merge conflict strategies (last-write-wins vs. custom resolution) and how SwiftData handles them by default
- A testing workflow for verifying sync between simulator instances and physical devices, including offline-to-online transitions

## Why This Matters

Users expect their data to follow them across devices. Apple makes this possible through iCloud and CloudKit, and SwiftData's integration means you do not need to build a backend, manage authentication, or run a server. But the abstraction is leaky — sync is eventually consistent, not instant, and merge conflicts are silent unless you handle them. Understanding what happens under the hood is the difference between "sync works" and "sync works until two devices edit the same entry, then one user's data disappears."

## Plan Phase: Defining What We Build

Open plan mode and think through the full integration before writing code:

```
I want to add iCloud sync to Moodbit using SwiftData's CloudKit
integration.

Current setup:
- SwiftData ModelContainer with MoodEntry model
- MoodEntry has: id (UUID), mood (Int), note (String), date (Date),
  aiInsight (String?)
- Local persistence already works (from Module 3)
- Swift 6 strict concurrency, iOS 17+

Plan the CloudKit integration:
1. What changes to ModelConfiguration are needed?
2. What Xcode capabilities and entitlements must I add?
3. What iCloud container do I need and how do I create it?
4. What happens when two devices edit the same MoodEntry? What is
   SwiftData's default conflict resolution?
5. What model constraints affect CloudKit compatibility? (e.g.,
   unique constraints, optional vs required fields, relationships)
6. What does NOT sync? (e.g., @Transient properties)
7. How do I test sync without two physical devices?
8. How do I handle the app being offline?

Do not generate code yet. Plan first.
```

### What the AI Plan Should Contain

1. **ModelConfiguration change** — set `cloudKitDatabase: .automatic` (or `.private`) on the `ModelConfiguration`. That is the entire SwiftData change to enable sync.
2. **Xcode capabilities** — iCloud capability with CloudKit checked, plus Background Modes with "Remote notifications" enabled (CloudKit uses silent push to trigger sync).
3. **Container setup** — an iCloud container identifier like `iCloud.com.yourname.moodbit`, created in the Apple Developer portal or automatically by Xcode.
4. **Entitlements** — `com.apple.developer.icloud-container-identifiers` and `com.apple.developer.icloud-services` with `CloudKit` value.
5. **Conflict resolution** — SwiftData with CloudKit uses last-write-wins by default. The most recent change (by device timestamp) overwrites the older one. No merge, no prompt. If you need field-level merging, you must implement it yourself.
6. **CloudKit limitations** — `@Attribute(.unique)` constraints are not supported with CloudKit. All properties should be optional or have default values. `@Transient` properties do not sync. Relationships must be optional.
7. **Testing** — use two simulator instances signed into the same iCloud account, or one simulator + one physical device. The CloudKit Dashboard (console.developer.apple.com) shows records in real time.
8. **Offline handling** — SwiftData queues changes locally and syncs when connectivity returns. No code needed for basic offline support, but you should handle `NSPersistentCloudKitContainer` notifications if you want to show sync status.

If the plan does not mention that `@Attribute(.unique)` breaks CloudKit sync, flag it. This is the single most common cause of "sync just does not work" bugs.

### Anti-Pattern: Assuming Instant Sync

```
Just enable CloudKit and it will sync automatically
```

Technically true. Practically misleading. CloudKit sync is eventually consistent, meaning changes can take seconds to minutes to propagate depending on network conditions, iCloud account status, and Apple's server load. If your tests assume instant sync, they will be flaky. If your UI assumes instant sync, users will think the app is broken. Plan for latency from the start.

## Execute Phase: Implementation

### Step 1: Model Compatibility

First, make sure the data model is CloudKit-compatible:

```
Review and update the MoodEntry SwiftData model for CloudKit
compatibility.

Current model:
@Model
final class MoodEntry {
    var id: UUID
    var mood: Int
    var note: String
    var date: Date
    var aiInsight: String?
}

Requirements for CloudKit sync:
1. Remove any @Attribute(.unique) constraints (not supported)
2. Ensure all non-optional properties have default values
3. Mark properties that should NOT sync as @Transient
4. Add a lastModified timestamp for conflict debugging
5. Keep Swift 6 strict concurrency compliance

Generate the updated model.
```

### Analyzing the AI Output

- ✅ No `@Attribute(.unique)` on any property
- ✅ All properties have default values (CloudKit requires this for new fields added in future schema versions)
- ✅ `aiInsight` remains optional (as it should be — not every entry has one)
- ✅ `lastModified` property added with a default of `Date.now`
- ⚠️ If the AI added `@Transient` to `aiInsight` — discuss whether you want insights to sync. If the user switches devices, do they want to re-generate insights or see the original? There is no universal right answer
- ❌ If the AI kept `@Attribute(.unique)` on `id` — reject. CloudKit manages its own record identifiers. A unique constraint on UUID will cause sync failures
- ❌ If the AI added explicit `CKRecord` handling — reject. SwiftData abstracts this away. You should not be touching `CKRecord` directly

### Step 2: Container Configuration

```
Generate the updated ModelContainer configuration for Moodbit with
CloudKit sync enabled.

Requirements:
1. Update MoodbitApp.swift to use a ModelConfiguration with
   cloudKitDatabase set to .automatic
2. Set the container identifier to "iCloud.com.yourname.moodbit"
3. Keep the existing local-only fallback for previews and tests
4. Add a static method that creates an in-memory, non-syncing
   container for SwiftUI previews
5. Log sync status using os.Logger
6. Handle the case where the user is not signed into iCloud
   gracefully (the app should still work locally)

Swift 6 strict concurrency. Zero warnings.
```

### Analyzing the Output

- ✅ `ModelConfiguration` uses `cloudKitDatabase: .automatic`
- ✅ Container identifier string matches the format `iCloud.com.yourname.moodbit`
- ✅ Preview container uses `cloudKitDatabase: .none` and `isStoredInMemoryOnly: true`
- ✅ No force unwrapping on container creation
- ⚠️ If it does not handle the "not signed into iCloud" case — the app will still work (SwiftData falls back to local), but logging a warning helps with debugging
- ❌ If it uses a hardcoded `cloudKitContainerIdentifier` that does not match the entitlements — sync will silently fail

## Iteration

After reviewing the generated code, tighten it:

```
Good. Now add these improvements:

1. Create a SyncMonitor class that listens to
   NSPersistentCloudKitContainer.eventChangedNotification to track
   sync status (importing, exporting, idle, error)
2. Expose the sync status as an @Observable property so the UI can
   show a subtle sync indicator
3. Add a method to check if iCloud is available using
   FileManager.default.ubiquityIdentityToken
4. Log all sync events with os.Logger including the event type and
   any errors
5. Make SyncMonitor @MainActor for safe UI binding

Keep it minimal. We are not building a full sync engine — just enough
visibility to debug issues and inform the user.
```

## Verify Phase

CloudKit sync requires careful testing because failures are often silent. Work through this verification plan:

**Xcode configuration:**
1. Target > Signing & Capabilities > iCloud: CloudKit is checked
2. Container identifier matches your `ModelConfiguration`
3. Background Modes capability added with "Remote notifications" enabled
4. Entitlements file contains `com.apple.developer.icloud-container-identifiers` with the correct container
5. Build and run — zero errors, zero warnings

**CloudKit Dashboard:**
1. Open [CloudKit Console](https://icloud.developer.apple.com/)
2. Select your container
3. Navigate to the "Development" environment
4. Check that SwiftData has created the record types matching your model (this happens on first launch)
5. You should see a record type for `MoodEntry` with fields matching your properties

**Sync testing — two simulators:**
1. Open two iOS Simulator instances (Xcode > Open Developer Tool > Simulator, then File > New Simulator)
2. Sign both into the same iCloud account (Settings > Apple ID)
3. Run the app on Simulator A, create a mood entry
4. Wait 10-30 seconds
5. Run the app on Simulator B — the entry should appear
6. Edit the entry on Simulator B, wait, confirm the edit appears on Simulator A

**Offline-to-online transition:**
1. Enable Airplane Mode on the simulator (or use Network Link Conditioner)
2. Create three mood entries while offline
3. Disable Airplane Mode
4. Confirm all three entries sync to the other device within 60 seconds

**Conflict test:**
1. On Device A, open an entry for editing but do not save yet
2. On Device B, edit the same entry and save
3. On Device A, save your edit
4. Observe which version wins (should be the last save — Device A)
5. Confirm no data loss and no crash

## Final Code

### MoodEntry.swift (Updated for CloudKit)

```swift
import Foundation
import SwiftData

/// A single mood journal entry, synced across devices via CloudKit.
@Model
final class MoodEntry {
    /// Stable identifier for the entry.
    var id: UUID = UUID()

    /// Mood rating from 1 (lowest) to 5 (highest).
    var mood: Int = 3

    /// User-written note accompanying the mood.
    var note: String = ""

    /// When the entry was created.
    var date: Date = Date.now

    /// When the entry was last modified (used for conflict debugging).
    var lastModified: Date = Date.now

    /// AI-generated insight. Nil if not yet generated.
    var aiInsight: String?

    /// Local-only flag for entries pending AI analysis. Not synced.
    @Transient
    var isPendingAnalysis: Bool = false

    init(
        mood: Int,
        note: String,
        date: Date = .now
    ) {
        self.id = UUID()
        self.mood = mood
        self.note = note
        self.date = date
        self.lastModified = .now
        self.aiInsight = nil
        self.isPendingAnalysis = false
    }
}
```

### MoodbitApp.swift (Updated with CloudKit Container)

```swift
import SwiftUI
import SwiftData
import os

@main
struct MoodbitApp: App {
    private static let logger = Logger(
        subsystem: "com.moodbit.app",
        category: "App"
    )

    @State private var router = AppRouter()
    @State private var syncMonitor = SyncMonitor()
    let modelContainer: ModelContainer

    init() {
        self.modelContainer = Self.makeModelContainer()
    }

    var body: some Scene {
        WindowGroup {
            NavigationStack(path: $router.path) {
                HomeView()
                    .navigationDestination(for: AppRouter.Route.self) { route in
                        router.destination(for: route)
                    }
            }
            .environment(\.router, router)
            .environment(syncMonitor)
        }
        .modelContainer(modelContainer)
    }

    /// Creates the SwiftData container with CloudKit sync enabled.
    private static func makeModelContainer() -> ModelContainer {
        do {
            let configuration = ModelConfiguration(
                "Moodbit",
                schema: Schema([MoodEntry.self]),
                cloudKitDatabase: .automatic
            )
            let container = try ModelContainer(
                for: MoodEntry.self,
                configurations: [configuration]
            )
            logger.info("ModelContainer created with CloudKit sync.")
            return container
        } catch {
            logger.fault(
                "Failed to create ModelContainer: \(error.localizedDescription)"
            )
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }

    /// Creates an in-memory container for SwiftUI previews. No sync.
    static func previewContainer() -> ModelContainer {
        let configuration = ModelConfiguration(
            isStoredInMemoryOnly: true,
            cloudKitDatabase: .none
        )
        do {
            return try ModelContainer(
                for: MoodEntry.self,
                configurations: [configuration]
            )
        } catch {
            fatalError("Preview container failed: \(error)")
        }
    }
}
```

### SyncMonitor.swift

```swift
import Foundation
import CoreData
import os

/// Observes CloudKit sync events and exposes status for the UI.
@MainActor
@Observable
final class SyncMonitor {
    private let logger = Logger(
        subsystem: "com.moodbit.app",
        category: "Sync"
    )

    /// Current sync status.
    enum Status: String, Sendable {
        case idle = "Up to date"
        case importing = "Downloading..."
        case exporting = "Uploading..."
        case error = "Sync error"
        case noAccount = "No iCloud account"
    }

    /// The current sync status, observable by SwiftUI views.
    private(set) var status: Status = .idle

    /// Whether iCloud is available on this device.
    private(set) var isCloudAvailable: Bool = false

    init() {
        checkCloudAvailability()
        startObserving()
    }

    /// Checks whether the user is signed into iCloud.
    private func checkCloudAvailability() {
        let token = FileManager.default.ubiquityIdentityToken
        isCloudAvailable = token != nil
        if !isCloudAvailable {
            status = .noAccount
            logger.warning("iCloud account not available. Data is local only.")
        } else {
            logger.info("iCloud account detected. Sync enabled.")
        }
    }

    /// Subscribes to CloudKit sync event notifications.
    private func startObserving() {
        NotificationCenter.default.addObserver(
            forName: NSPersistentCloudKitContainer.eventChangedNotification,
            object: nil,
            queue: nil
        ) { [weak self] notification in
            guard let event = notification.userInfo?[
                NSPersistentCloudKitContainer.eventNotificationUserInfoKey
            ] as? NSPersistentCloudKitContainer.Event else {
                return
            }
            Task { @MainActor [weak self] in
                self?.handleSyncEvent(event)
            }
        }
    }

    /// Maps a CloudKit sync event to a user-visible status.
    private func handleSyncEvent(
        _ event: NSPersistentCloudKitContainer.Event
    ) {
        if let error = event.error {
            status = .error
            logger.error(
                "Sync error (\(event.type.description)): \(error.localizedDescription)"
            )
            return
        }

        if event.endDate == nil {
            // Event is in progress.
            switch event.type {
            case .import:
                status = .importing
                logger.debug("Sync: importing from CloudKit.")
            case .export:
                status = .exporting
                logger.debug("Sync: exporting to CloudKit.")
            case .setup:
                logger.debug("Sync: setup in progress.")
            @unknown default:
                logger.debug("Sync: unknown event type.")
            }
        } else {
            // Event finished.
            status = .idle
            logger.debug("Sync: \(event.type.description) completed.")
        }
    }
}

// MARK: - Event Type Description

extension NSPersistentCloudKitContainer.EventType {
    var description: String {
        switch self {
        case .setup:  return "setup"
        case .import: return "import"
        case .export: return "export"
        @unknown default: return "unknown"
        }
    }
}
```

### SyncStatusView.swift (Optional UI Component)

```swift
import SwiftUI

/// A small indicator showing the current CloudKit sync status.
struct SyncStatusView: View {
    @Environment(SyncMonitor.self) private var syncMonitor

    var body: some View {
        HStack(spacing: 6) {
            statusIcon
                .font(.caption)
            Text(syncMonitor.status.rawValue)
                .font(.caption2)
                .foregroundStyle(.secondary)
        }
        .animation(.easeInOut(duration: 0.3), value: syncMonitor.status)
    }

    @ViewBuilder
    private var statusIcon: some View {
        switch syncMonitor.status {
        case .idle:
            Image(systemName: "checkmark.icloud")
                .foregroundStyle(.green)
        case .importing, .exporting:
            Image(systemName: "arrow.triangle.2.circlepath.icloud")
                .foregroundStyle(.blue)
                .symbolEffect(.rotate, isActive: true)
        case .error:
            Image(systemName: "exclamationmark.icloud")
                .foregroundStyle(.red)
        case .noAccount:
            Image(systemName: "icloud.slash")
                .foregroundStyle(.secondary)
        }
    }
}
```

### Key Design Decisions

**Why `cloudKitDatabase: .automatic` instead of `.private`?** The `.automatic` option uses the private database by default but allows Apple to determine the best configuration. For most apps, this is the right choice. Use `.private` explicitly only if you need to guarantee no data touches a public or shared database.

**Why no `@Attribute(.unique)` on `id`?** CloudKit manages record identity internally using `CKRecord.ID`. Adding a unique constraint on your own `id` field causes the persistent store coordinator to throw merge errors during sync, because CloudKit's conflict resolution operates at the record level, not the field level. Your `id` is still useful as a stable application-level identifier — just do not enforce uniqueness at the database level.

**Why last-write-wins?** SwiftData with CloudKit does not offer built-in field-level merge. The entire record is replaced by whichever device wrote last (by timestamp). For a mood journal, this is acceptable — users rarely edit the same entry on two devices simultaneously. For collaborative apps (shared documents, team task lists), you would need a custom merge strategy or a different sync backend.

**Why `@Transient` on `isPendingAnalysis`?** This flag is a local UI concern. If Device A is waiting for an AI response, Device B does not need to know. Syncing transient state creates unnecessary network traffic and confusing UX.

## Checkpoint

Before considering CloudKit sync complete, verify every item:

- [ ] iCloud capability added in Xcode with CloudKit checked
- [ ] Background Modes capability added with "Remote notifications"
- [ ] Container identifier matches between Xcode entitlements and `ModelConfiguration`
- [ ] `MoodEntry` has no `@Attribute(.unique)` constraints
- [ ] All non-optional properties in `MoodEntry` have default values
- [ ] App builds and runs with zero warnings under Swift 6 strict concurrency
- [ ] CloudKit Dashboard shows the `MoodEntry` record type after first launch
- [ ] Creating an entry on Device A appears on Device B within 60 seconds
- [ ] Editing an entry on one device reflects on the other
- [ ] Deleting an entry on one device removes it from the other
- [ ] App works normally when iCloud is unavailable (local-only fallback)
- [ ] `SyncMonitor` logs sync events in the Xcode console
- [ ] Creating entries offline and then going online results in successful sync

## Challenge

**Implement a manual sync status indicator in the Settings screen.**

1. Add `SyncStatusView` to the Settings screen
2. Below the status indicator, show the last successful sync time (store it in `SyncMonitor` when an export event completes)
3. Add a "Sync Now" button that triggers a save on the `ModelContext` (this nudges the persistent store to attempt an export)
4. If `isCloudAvailable` is false, show a message directing the user to sign into iCloud in Settings

<details>
<summary>Hint</summary>

Store the last sync time in `SyncMonitor`:

```swift
private(set) var lastSyncDate: Date?
```

Update it when an export event finishes:

```swift
if event.endDate != nil && event.type == .export {
    status = .idle
    lastSyncDate = Date.now
}
```

The "Sync Now" button triggers a context save, which prompts the CloudKit integration to check for pending changes:

```swift
Button("Sync Now") {
    try? modelContext.save()
}
.disabled(!syncMonitor.isCloudAvailable)
```

This does not force an immediate sync — CloudKit decides the actual timing — but it ensures any unsaved local changes are flushed to the persistent store where the sync engine can pick them up.
</details>

---

Next up: **Bonus Lesson B.2 — Share Extension & Beyond**, where we build a Share Extension for quick mood logging and chart your path forward as an AI-augmented iOS developer.
