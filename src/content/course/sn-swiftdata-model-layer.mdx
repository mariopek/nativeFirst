---
title: "SwiftData Model Layer"
description: "Design and implement the MoodEntry, MoodTag, and DailyInsight SwiftData models with relationships, configure the ModelContainer, and build the repository protocol for data access."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 2
duration: "25 min read"
difficulty: "intermediate"
topics: ["SwiftData", "@Model", "Data Modeling", "Relationships", "Repository Pattern", "CRUD", "Predicates", "Moodbit"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Your architecture is set. Your CLAUDE.md is written. Now we build the thing that every feature in Moodbit depends on: the data layer.

If you get the models wrong, every view, every query, every insight engine built on top of them will be wrong. If you get them right, everything else falls into place. This is why we build models first, views second, and AI features last.

In this lesson, we design three SwiftData models, wire their relationships, configure the ModelContainer, and create a repository protocol that gives us a clean, testable API for data access. We do it using the Plan-Execute-Verify workflow â€” the same workflow you will use for every feature in this course.

## What You'll Learn

- How to design `@Model` classes with relationships and inverse references using SwiftData
- How to write `#Predicate` queries for filtered, sorted data access
- How to configure a `ModelContainer` in a Swift 6 strict concurrency environment
- How to abstract persistence behind a protocol so your views never touch SwiftData directly

## Why This Matters

Every production iOS app needs a persistence layer, and SwiftData is Apple's answer for Swift-native apps. But SwiftData is opinionated â€” get the relationships, delete rules, or thread safety wrong and you hit runtime crashes that the compiler will not catch. The repository pattern we build here is the same pattern used in banking apps, health apps, and anything that ships to the App Store with real user data on the line.

## Plan Phase: Defining What We Build

Before we prompt for code, we tell the AI what we want and ask it to think. Here is the planning prompt:

```
I am building Moodbit, an AI-powered mood journal for iOS.
I need the SwiftData model layer. Before writing code, plan
the following:

1. MoodEntry â€” the core model. Properties: id (UUID),
   moodLevel (Int, 1-5), emoji (String), note (String,
   optional), createdAt (Date). It should have a many-to-many
   relationship with MoodTag.

2. MoodTag â€” a tagging model. Properties: id (UUID),
   name (String), color (String, hex value). It should have
   an inverse relationship back to MoodEntry.

3. DailyInsight â€” AI-generated daily summary. Properties:
   id (UUID), date (Date, unique per day), summary (String),
   sentimentScore (Double, 0.0-1.0), generatedAt (Date).

4. A MoodRepository protocol that defines CRUD operations
   for MoodEntry, including filtered fetches by date range
   and mood level.

5. ModelContainer configuration for the App struct.

Think through: relationship types, delete rules, which
properties need defaults, and how #Predicate queries will
work for the repository. Then implement everything in
Swift 6 with strict concurrency.
```

### Why This Prompt Works

This prompt follows every principle from Lesson 1.1. It states the app name and purpose. It lists every model with exact property names and types. It specifies the relationships explicitly â€” "many-to-many" and "inverse" â€” because SwiftData will not infer these for you. It asks the AI to think before coding, which triggers chain-of-thought reasoning and catches design issues before they become bugs.

It also specifies Swift 6 strict concurrency, which matters because SwiftData's `ModelContext` is not `Sendable`. If you forget this constraint, the AI will generate code that compiles under Swift 5 but crashes under Swift 6.

### The Anti-Pattern: What Not to Prompt

```
Make SwiftData models for a mood app. I need entries, tags,
and insights. Also add CRUD.
```

This will produce code. It will also produce models with `String!` force-unwrapped optionals, missing inverse relationships, no delete rules, and a ViewModel that directly calls `ModelContext` from the view layer. You will spend more time fixing the output than you saved generating it. Vague input produces vague output â€” always.

## Execute Phase: Implementation

Now we send the planning prompt. Claude Code generates the full model layer. Let us review each file.

### MoodEntry.swift

```swift
import Foundation
import SwiftData

@Model
final class MoodEntry {
    @Attribute(.unique) var id: UUID
    var moodLevel: Int
    var emoji: String
    var note: String
    var createdAt: Date

    @Relationship(deleteRule: .nullify, inverse: \MoodTag.entries)
    var tags: [MoodTag]

    init(
        id: UUID = UUID(),
        moodLevel: Int,
        emoji: String,
        note: String = "",
        createdAt: Date = .now
    ) {
        self.id = id
        self.moodLevel = moodLevel
        self.emoji = emoji
        self.note = note
        self.createdAt = createdAt
        self.tags = []
    }
}
```

Let us verify the critical details:

- **`@Attribute(.unique)` on `id`.** This tells SwiftData to enforce uniqueness at the database level. Without it, you could accidentally insert duplicate entries.
- **`moodLevel` is a plain `Int`, not optional.** Every mood entry must have a level. The prompt said 1-5, so we enforce that in the repository layer, not the model. SwiftData does not support range constraints natively.
- **`note` defaults to an empty string** instead of being optional. This simplifies every view that displays notes â€” no nil checking, no `if let`. An empty string and a nil string mean the same thing semantically, so pick the simpler representation.
- **`deleteRule: .nullify`** on the tags relationship means deleting an entry removes it from any tag's `entries` array without deleting the tags. This is correct â€” tags are shared across entries.
- **`inverse: \MoodTag.entries`** explicitly links the two sides of the relationship. If you omit this, SwiftData can silently fail to update the inverse side, leading to stale data.
- **`tags` is initialized to an empty array** in the init, not as `nil`. For a to-many relationship, an empty array is the correct "no tags" state.

### MoodTag.swift

```swift
import Foundation
import SwiftData

@Model
final class MoodTag {
    @Attribute(.unique) var id: UUID
    var name: String
    var color: String

    @Relationship(deleteRule: .nullify)
    var entries: [MoodEntry]

    init(
        id: UUID = UUID(),
        name: String,
        color: String
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.entries = []
    }

    static let predefined: [(name: String, color: String)] = [
        ("Work", "#4A90D9"),
        ("Exercise", "#2ECC71"),
        ("Social", "#F39C12"),
        ("Family", "#E74C3C"),
        ("Health", "#1ABC9C"),
        ("Creative", "#9B59B6"),
    ]
}
```

Review:

- **`color` is a `String` (hex), not a SwiftUI `Color`.** SwiftData cannot persist `Color` directly. We store the hex value and convert in the view layer. This is the right trade-off.
- **`deleteRule: .nullify`** on entries means deleting a tag removes it from all entries' `tags` arrays. Entries are never deleted when a tag is removed.
- **No `inverse:` parameter on `entries`.** We already declared the inverse on `MoodEntry.tags`. Declaring it on both sides causes a compiler error. One side declares the inverse â€” the other is the target.
- **`predefined` is a tuple array, not `@Model` instances.** You cannot create SwiftData objects statically. We seed these into the database at first launch, just like we would with Core Data.

### DailyInsight.swift

```swift
import Foundation
import SwiftData

@Model
final class DailyInsight {
    @Attribute(.unique) var id: UUID
    var date: Date
    var summary: String
    var sentimentScore: Double
    var generatedAt: Date

    init(
        id: UUID = UUID(),
        date: Date,
        summary: String,
        sentimentScore: Double,
        generatedAt: Date = .now
    ) {
        self.id = id
        self.date = date
        self.summary = summary
        self.sentimentScore = sentimentScore
        self.generatedAt = generatedAt
    }
}
```

This is the simplest model. No relationships â€” insights are derived data, not relational. A few notes:

- **`date` is the calendar day the insight covers.** We will query by date range. In a production app you would normalize this to `startOfDay` before saving. We handle that in the repository.
- **`sentimentScore` is a `Double` from 0.0 to 1.0.** Like `moodLevel`, the range is enforced in the repository, not the model. SwiftData models are data containers, not validation layers.
- **`generatedAt` defaults to `.now`.** This tracks when the AI generated the insight, useful for cache invalidation.

### AI Output Review

Here is how I evaluate what the AI generated:

- **Relationship declarations with explicit inverses** â€” the AI got this right, including the asymmetric pattern where only one side declares `inverse:`
- **Delete rules are `.nullify` across the board** â€” correct for a many-to-many where neither side owns the other
- **No force unwraps anywhere** â€” every property is either non-optional with a default or genuinely required in the init
- **`@Attribute(.unique)` on id fields** â€” good practice, though SwiftData generates its own `persistentModelID` internally. The unique constraint prevents accidental duplicates during sync or migration

One thing to watch: the AI might generate `var tags: [MoodTag]?` as an optional array. If it does, change it to a non-optional `[MoodTag]` initialized to `[]`. Optional arrays in SwiftData relationships create unnecessary nil-checking in every query and view.

## Iteration

The initial generation is solid, but we need the repository and the container configuration. Here is the follow-up prompt:

```
Now create two things:

1. A MoodRepository protocol in Repositories/MoodRepository.swift
   with these methods:
   - addEntry(moodLevel:emoji:note:tags:) -> MoodEntry
   - deleteEntry(_ entry: MoodEntry)
   - fetchEntries(from:to:) -> [MoodEntry] using #Predicate
   - fetchEntries(moodLevel:) -> [MoodEntry] using #Predicate
   - fetchAllTags() -> [MoodTag]
   - addTag(name:color:) -> MoodTag
   - fetchInsight(for date: Date) -> DailyInsight?
   - saveInsight(date:summary:sentimentScore:) -> DailyInsight

2. A SwiftDataMoodRepository class that implements this
   protocol using a ModelContext. Mark it @MainActor since
   ModelContext is not Sendable.

3. Update MoodbitApp.swift to configure a ModelContainer
   with all three models and inject a SwiftDataMoodRepository
   into the environment.

Use #Predicate for all queries. Handle errors with
os.Logger, not print(). Use Swift 6 strict concurrency.
```

### MoodRepository Protocol and Implementation

```swift
import Foundation
import SwiftData
import os

protocol MoodRepository {
    func addEntry(moodLevel: Int, emoji: String, note: String, tags: [MoodTag]) -> MoodEntry
    func deleteEntry(_ entry: MoodEntry)
    func fetchEntries(from startDate: Date, to endDate: Date) -> [MoodEntry]
    func fetchEntries(moodLevel: Int) -> [MoodEntry]
    func fetchAllTags() -> [MoodTag]
    func addTag(name: String, color: String) -> MoodTag
    func fetchInsight(for date: Date) -> DailyInsight?
    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> DailyInsight
}

@MainActor
final class SwiftDataMoodRepository: MoodRepository {
    private let modelContext: ModelContext
    private let logger = Logger(subsystem: "com.moodbit", category: "MoodRepository")

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func addEntry(moodLevel: Int, emoji: String, note: String, tags: [MoodTag]) -> MoodEntry {
        let entry = MoodEntry(moodLevel: moodLevel, emoji: emoji, note: note)
        entry.tags = tags
        modelContext.insert(entry)
        save()
        return entry
    }

    func deleteEntry(_ entry: MoodEntry) {
        modelContext.delete(entry)
        save()
    }

    func fetchEntries(from startDate: Date, to endDate: Date) -> [MoodEntry] {
        let predicate = #Predicate<MoodEntry> {
            $0.createdAt >= startDate && $0.createdAt <= endDate
        }
        let descriptor = FetchDescriptor<MoodEntry>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch entries by date range: \(error.localizedDescription)")
            return []
        }
    }

    func fetchEntries(moodLevel: Int) -> [MoodEntry] {
        let predicate = #Predicate<MoodEntry> {
            $0.moodLevel == moodLevel
        }
        let descriptor = FetchDescriptor<MoodEntry>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch entries by mood level: \(error.localizedDescription)")
            return []
        }
    }

    func fetchAllTags() -> [MoodTag] {
        let descriptor = FetchDescriptor<MoodTag>(
            sortBy: [SortDescriptor(\.name)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch tags: \(error.localizedDescription)")
            return []
        }
    }

    func addTag(name: String, color: String) -> MoodTag {
        let tag = MoodTag(name: name, color: color)
        modelContext.insert(tag)
        save()
        return tag
    }

    func fetchInsight(for date: Date) -> DailyInsight? {
        let startOfDay = Calendar.current.startOfDay(for: date)
        let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: startOfDay)!

        let predicate = #Predicate<DailyInsight> {
            $0.date >= startOfDay && $0.date < endOfDay
        }
        let descriptor = FetchDescriptor<DailyInsight>(predicate: predicate)
        do {
            return try modelContext.fetch(descriptor).first
        } catch {
            logger.error("Failed to fetch insight: \(error.localizedDescription)")
            return nil
        }
    }

    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> DailyInsight {
        let normalizedDate = Calendar.current.startOfDay(for: date)
        let insight = DailyInsight(
            date: normalizedDate,
            summary: summary,
            sentimentScore: sentimentScore
        )
        modelContext.insert(insight)
        save()
        return insight
    }

    // MARK: - Private

    private func save() {
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save context: \(error.localizedDescription)")
        }
    }
}
```

This is the core of the lesson, so let us break down the decisions that matter.

**Why a protocol at all?** Because in Module 6, we write unit tests. Tests need a mock repository that returns controlled data without touching a real database. If your views call `ModelContext` directly, you cannot test them without standing up a full SwiftData stack. The protocol gives us a seam to inject either the real implementation or a mock.

**`@MainActor` on the class.** `ModelContext` is bound to the actor that created it. In SwiftUI apps, the main context lives on `@MainActor`. If you try to use it from a background thread under Swift 6 strict concurrency, the compiler stops you. Marking the repository `@MainActor` makes this explicit and safe.

**`#Predicate` for every query.** This is SwiftData's compile-time-checked query syntax. Unlike Core Data's `NSPredicate` (which is a runtime string), `#Predicate` catches type errors at compile time. If you rename `createdAt` to `timestamp`, every `#Predicate` that references it will show a compiler error â€” no silent runtime failures.

**`fetchInsight(for:)` normalizes to start-of-day.** We query for insights by calendar day, not exact timestamp. The predicate uses `>= startOfDay && < endOfDay` (note: strict less-than on the upper bound). This is the correct pattern for day-based queries â€” using `<=` on the end date would include the first instant of the next day.

**`saveInsight` normalizes the date before insertion.** This ensures that two insights for the same day always have the same `date` value, which prevents duplicates and makes queries reliable.

### ModelContainer Configuration

```swift
import SwiftUI
import SwiftData

@main
struct MoodbitApp: App {
    let modelContainer: ModelContainer

    init() {
        do {
            let schema = Schema([
                MoodEntry.self,
                MoodTag.self,
                DailyInsight.self,
            ])
            let configuration = ModelConfiguration(isStoredInMemoryOnly: false)
            modelContainer = try ModelContainer(for: schema, configurations: [configuration])
            seedTagsIfNeeded()
        } catch {
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(
                    SwiftDataMoodRepository(modelContext: modelContainer.mainContext)
                )
        }
        .modelContainer(modelContainer)
    }

    private func seedTagsIfNeeded() {
        let hasSeeded = UserDefaults.standard.bool(forKey: "hasSeededTags")
        guard !hasSeeded else { return }

        let context = modelContainer.mainContext
        for item in MoodTag.predefined {
            let tag = MoodTag(name: item.name, color: item.color)
            context.insert(tag)
        }

        do {
            try context.save()
            UserDefaults.standard.set(true, forKey: "hasSeededTags")
        } catch {
            print("Failed to seed tags: \(error)")
        }
    }
}
```

**`fatalError` in the catch block is intentional.** If the database cannot be created, the app has no persistence. There is no graceful recovery â€” this is the standard Apple pattern.

**Repository injection via `.environment()`.** We create the repository once at the app level and inject it into the view hierarchy. Every view that needs data access reads it from the environment. This is dependency injection without any third-party framework.

**Tag seeding uses the same `UserDefaults` flag pattern** we used in the free course. Simple, reliable, one-time execution.

## Verify Phase

Before moving to the next lesson, verify these things manually:

1. **Build the project.** All four files should compile with zero warnings under Swift 6 strict concurrency. If you see `Sendable` warnings on the repository, confirm that `@MainActor` is on the class declaration.

2. **Check the relationship inverse.** Open `MoodEntry.swift` and confirm that `@Relationship(inverse: \MoodTag.entries)` points to the correct keypath. Open `MoodTag.swift` and confirm it does NOT also declare an `inverse:` parameter. Only one side declares the inverse.

3. **Check delete rules.** Both relationships should use `.nullify`. If the AI generated `.cascade` on either side, change it. Cascade on a many-to-many means deleting one entry would delete all its tags â€” and those tags would then be removed from every other entry that used them. Cascade is almost never correct for many-to-many.

4. **Check that no property is force-unwrapped.** Search for `!` in all model files. There should be exactly one â€” the `endOfDay` calculation in `fetchInsight`, which is safe because `Calendar.date(byAdding:)` only returns nil for absurd inputs.

5. **Test the repository.** Create a temporary button in ContentView that calls `repository.addEntry(moodLevel: 4, emoji: "ðŸ˜Š", note: "Test", tags: [])`. Tap it, quit the app, relaunch. The entry should persist.

## Final Code

Here is every file, complete and compilable.

**Models/MoodEntry.swift**

```swift
import Foundation
import SwiftData

@Model
final class MoodEntry {
    @Attribute(.unique) var id: UUID
    var moodLevel: Int
    var emoji: String
    var note: String
    var createdAt: Date

    @Relationship(deleteRule: .nullify, inverse: \MoodTag.entries)
    var tags: [MoodTag]

    init(
        id: UUID = UUID(),
        moodLevel: Int,
        emoji: String,
        note: String = "",
        createdAt: Date = .now
    ) {
        self.id = id
        self.moodLevel = moodLevel
        self.emoji = emoji
        self.note = note
        self.createdAt = createdAt
        self.tags = []
    }
}
```

**Models/MoodTag.swift**

```swift
import Foundation
import SwiftData

@Model
final class MoodTag {
    @Attribute(.unique) var id: UUID
    var name: String
    var color: String

    @Relationship(deleteRule: .nullify)
    var entries: [MoodEntry]

    init(
        id: UUID = UUID(),
        name: String,
        color: String
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.entries = []
    }

    static let predefined: [(name: String, color: String)] = [
        ("Work", "#4A90D9"),
        ("Exercise", "#2ECC71"),
        ("Social", "#F39C12"),
        ("Family", "#E74C3C"),
        ("Health", "#1ABC9C"),
        ("Creative", "#9B59B6"),
    ]
}
```

**Models/DailyInsight.swift**

```swift
import Foundation
import SwiftData

@Model
final class DailyInsight {
    @Attribute(.unique) var id: UUID
    var date: Date
    var summary: String
    var sentimentScore: Double
    var generatedAt: Date

    init(
        id: UUID = UUID(),
        date: Date,
        summary: String,
        sentimentScore: Double,
        generatedAt: Date = .now
    ) {
        self.id = id
        self.date = date
        self.summary = summary
        self.sentimentScore = sentimentScore
        self.generatedAt = generatedAt
    }
}
```

**Repositories/MoodRepository.swift**

```swift
import Foundation
import SwiftData
import os

protocol MoodRepository {
    func addEntry(moodLevel: Int, emoji: String, note: String, tags: [MoodTag]) -> MoodEntry
    func deleteEntry(_ entry: MoodEntry)
    func fetchEntries(from startDate: Date, to endDate: Date) -> [MoodEntry]
    func fetchEntries(moodLevel: Int) -> [MoodEntry]
    func fetchAllTags() -> [MoodTag]
    func addTag(name: String, color: String) -> MoodTag
    func fetchInsight(for date: Date) -> DailyInsight?
    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> DailyInsight
}

@MainActor
final class SwiftDataMoodRepository: MoodRepository {
    private let modelContext: ModelContext
    private let logger = Logger(subsystem: "com.moodbit", category: "MoodRepository")

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func addEntry(moodLevel: Int, emoji: String, note: String, tags: [MoodTag]) -> MoodEntry {
        let entry = MoodEntry(moodLevel: moodLevel, emoji: emoji, note: note)
        entry.tags = tags
        modelContext.insert(entry)
        save()
        return entry
    }

    func deleteEntry(_ entry: MoodEntry) {
        modelContext.delete(entry)
        save()
    }

    func fetchEntries(from startDate: Date, to endDate: Date) -> [MoodEntry] {
        let predicate = #Predicate<MoodEntry> {
            $0.createdAt >= startDate && $0.createdAt <= endDate
        }
        let descriptor = FetchDescriptor<MoodEntry>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch entries by date: \(error.localizedDescription)")
            return []
        }
    }

    func fetchEntries(moodLevel: Int) -> [MoodEntry] {
        let predicate = #Predicate<MoodEntry> {
            $0.moodLevel == moodLevel
        }
        let descriptor = FetchDescriptor<MoodEntry>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch entries by level: \(error.localizedDescription)")
            return []
        }
    }

    func fetchAllTags() -> [MoodTag] {
        let descriptor = FetchDescriptor<MoodTag>(
            sortBy: [SortDescriptor(\.name)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch tags: \(error.localizedDescription)")
            return []
        }
    }

    func addTag(name: String, color: String) -> MoodTag {
        let tag = MoodTag(name: name, color: color)
        modelContext.insert(tag)
        save()
        return tag
    }

    func fetchInsight(for date: Date) -> DailyInsight? {
        let startOfDay = Calendar.current.startOfDay(for: date)
        let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: startOfDay)!

        let predicate = #Predicate<DailyInsight> {
            $0.date >= startOfDay && $0.date < endOfDay
        }
        let descriptor = FetchDescriptor<DailyInsight>(predicate: predicate)
        do {
            return try modelContext.fetch(descriptor).first
        } catch {
            logger.error("Failed to fetch insight: \(error.localizedDescription)")
            return nil
        }
    }

    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> DailyInsight {
        let normalizedDate = Calendar.current.startOfDay(for: date)
        let insight = DailyInsight(
            date: normalizedDate,
            summary: summary,
            sentimentScore: sentimentScore
        )
        modelContext.insert(insight)
        save()
        return insight
    }

    private func save() {
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save context: \(error.localizedDescription)")
        }
    }
}
```

## Checkpoint

Before moving to Lesson 1.3, confirm all of these:

- [ ] `MoodEntry`, `MoodTag`, and `DailyInsight` compile with zero warnings under Swift 6
- [ ] The `MoodEntry.tags` relationship declares `inverse: \MoodTag.entries`
- [ ] `MoodTag.entries` does NOT also declare an inverse (only one side does)
- [ ] All delete rules are `.nullify`, not `.cascade`
- [ ] `MoodRepository` protocol exists with eight methods
- [ ] `SwiftDataMoodRepository` is marked `@MainActor`
- [ ] All queries use `#Predicate`, not string-based predicates
- [ ] `ModelContainer` is configured in `MoodbitApp.init()` with all three model types
- [ ] Predefined tags are seeded on first launch
- [ ] You can add an entry, quit, relaunch, and the entry persists

## Challenge

**Add a `fetchRecentEntries(limit:)` method** to both the protocol and the implementation. It should return the most recent N entries, sorted by `createdAt` descending.

Hint: `FetchDescriptor` has a `fetchLimit` property. Set it after creating the descriptor:

```swift
var descriptor = FetchDescriptor<MoodEntry>(
    sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
)
descriptor.fetchLimit = limit
```

Try prompting Claude Code for this. Then compare the output with the hint. If the AI generates a `#Predicate` that tries to do the limiting â€” that is wrong. Limiting is a fetch descriptor concern, not a predicate concern. The predicate filters *which* records match. The fetch limit controls *how many* come back. These are different operations.
