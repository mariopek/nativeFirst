---
title: "SwiftData Model Layer"
description: "Design and implement the CheckIn, RecoveryTag, and RecoveryInsight SwiftData models with relationships, configure the ModelContainer, and build the service protocol for data access."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 2
duration: "25 min read"
difficulty: "intermediate"
topics: ["SwiftData", "@Model", "Data Modeling", "Relationships", "Service Layer", "CRUD", "Predicates", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Your architecture is set. Your CLAUDE.md is written. Now we build the thing that every feature in BetAway depends on: the data layer.

If you get the models wrong, every view, every query, every insight engine built on top of them will be wrong. If you get them right, everything else falls into place. This is why we build models first, views second, and AI features last.

In this lesson, we design three SwiftData models, wire their relationships, configure the ModelContainer, and create a service protocol that gives us a clean, testable API for data access. We do it using the Plan-Execute-Verify workflow â€” the same workflow you will use for every feature in this course.

## What You'll Learn

- How to design `@Model` classes with relationships and inverse references using SwiftData
- How to write `#Predicate` queries for filtered, sorted data access
- How to configure a `ModelContainer` in a Swift 6 strict concurrency environment
- How to abstract persistence behind a service protocol so your views never touch SwiftData directly

## Why This Matters

Every production iOS app needs a persistence layer, and SwiftData is Apple's answer for Swift-native apps. But SwiftData is opinionated â€” get the relationships, delete rules, or thread safety wrong and you hit runtime crashes that the compiler will not catch. The service layer pattern we build here is the same pattern used in banking apps, health apps, and anything that ships to the App Store with real user data on the line.

## Plan Phase: Defining What We Build

Before we prompt for code, we tell the AI what we want and ask it to think. Here is the planning prompt:

```
I am building BetAway, a free gambling recovery app for iOS.
I need the SwiftData model layer. Before writing code, plan
the following:

1. CheckIn â€” the core model. Properties: id (UUID),
   recoveryStatus (Int, 1-5), emoji (String), note (String,
   optional), createdAt (Date). It should have a many-to-many
   relationship with RecoveryTag.

2. RecoveryTag â€” a tagging model. Properties: id (UUID),
   name (String), color (String, hex value). It should have
   an inverse relationship back to CheckIn.

3. RecoveryInsight â€” on-device ML generated daily summary.
   Properties: id (UUID), date (Date, unique per day),
   summary (String), sentimentScore (Double, 0.0-1.0),
   generatedAt (Date).

4. A RecoveryService protocol that defines CRUD operations
   for CheckIn, including filtered fetches by date range
   and recovery status.

5. ModelContainer configuration for the App struct.

Think through: relationship types, delete rules, which
properties need defaults, and how #Predicate queries will
work for the service. Then implement everything in
Swift 6 with strict concurrency.
```

### Why This Prompt Works

This prompt follows every principle from Lesson 1.1. It states the app name and purpose. It lists every model with exact property names and types. It specifies the relationships explicitly â€” "many-to-many" and "inverse" â€” because SwiftData will not infer these for you. It asks the AI to think before coding, which triggers chain-of-thought reasoning and catches design issues before they become bugs.

It also specifies Swift 6 strict concurrency, which matters because SwiftData's `ModelContext` is not `Sendable`. If you forget this constraint, the AI will generate code that compiles under Swift 5 but crashes under Swift 6.

### The Anti-Pattern: What Not to Prompt

```
Make SwiftData models for a recovery app. I need check-ins, tags,
and insights. Also add CRUD.
```

This will produce code. It will also produce models with `String!` force-unwrapped optionals, missing inverse relationships, no delete rules, and a ViewModel that directly calls `ModelContext` from the view layer. You will spend more time fixing the output than you saved generating it. Vague input produces vague output â€” always.

## Execute Phase: Implementation

Now we send the planning prompt. Claude Code generates the full model layer. Let us review each file.

### CheckIn.swift

```swift
import Foundation
import SwiftData

@Model
final class CheckIn {
    @Attribute(.unique) var id: UUID
    var recoveryStatus: Int
    var emoji: String
    var note: String
    var createdAt: Date

    @Relationship(deleteRule: .nullify, inverse: \RecoveryTag.checkIns)
    var tags: [RecoveryTag]

    init(
        id: UUID = UUID(),
        recoveryStatus: Int,
        emoji: String,
        note: String = "",
        createdAt: Date = .now
    ) {
        self.id = id
        self.recoveryStatus = recoveryStatus
        self.emoji = emoji
        self.note = note
        self.createdAt = createdAt
        self.tags = []
    }
}
```

Let us verify the critical details:

- **`@Attribute(.unique)` on `id`.** This tells SwiftData to enforce uniqueness at the database level. Without it, you could accidentally insert duplicate check-ins.
- **`recoveryStatus` is a plain `Int`, not optional.** Every check-in must have a status. The prompt said 1-5, so we enforce that in the service layer, not the model. SwiftData does not support range constraints natively.
- **`note` defaults to an empty string** instead of being optional. This simplifies every view that displays notes â€” no nil checking, no `if let`. An empty string and a nil string mean the same thing semantically, so pick the simpler representation.
- **`deleteRule: .nullify`** on the tags relationship means deleting a check-in removes it from any tag's `checkIns` array without deleting the tags. This is correct â€” tags are shared across check-ins.
- **`inverse: \RecoveryTag.checkIns`** explicitly links the two sides of the relationship. If you omit this, SwiftData can silently fail to update the inverse side, leading to stale data.
- **`tags` is initialized to an empty array** in the init, not as `nil`. For a to-many relationship, an empty array is the correct "no tags" state.

### RecoveryTag.swift

```swift
import Foundation
import SwiftData

@Model
final class RecoveryTag {
    @Attribute(.unique) var id: UUID
    var name: String
    var color: String

    @Relationship(deleteRule: .nullify)
    var checkIns: [CheckIn]

    init(
        id: UUID = UUID(),
        name: String,
        color: String
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.checkIns = []
    }

    static let predefined: [(name: String, color: String)] = [
        ("Urge", "#E74C3C"),
        ("Therapy", "#4A90D9"),
        ("Exercise", "#2ECC71"),
        ("Social", "#F39C12"),
        ("Financial", "#1ABC9C"),
        ("Breathing", "#9B59B6"),
    ]
}
```

Review:

- **`color` is a `String` (hex), not a SwiftUI `Color`.** SwiftData cannot persist `Color` directly. We store the hex value and convert in the view layer. This is the right trade-off.
- **`deleteRule: .nullify`** on checkIns means deleting a tag removes it from all check-ins' `tags` arrays. Check-ins are never deleted when a tag is removed.
- **No `inverse:` parameter on `checkIns`.** We already declared the inverse on `CheckIn.tags`. Declaring it on both sides causes a compiler error. One side declares the inverse â€” the other is the target.
- **`predefined` is a tuple array, not `@Model` instances.** You cannot create SwiftData objects statically. We seed these into the database at first launch, just like we would with Core Data.

### RecoveryInsight.swift

```swift
import Foundation
import SwiftData

@Model
final class RecoveryInsight {
    @Attribute(.unique) var id: UUID
    var date: Date
    var summary: String
    var sentimentScore: Double
    var generatedAt: Date

    init(
        id: UUID = UUID(),
        date: Date,
        summary: String,
        sentimentScore: Double,
        generatedAt: Date = .now
    ) {
        self.id = id
        self.date = date
        self.summary = summary
        self.sentimentScore = sentimentScore
        self.generatedAt = generatedAt
    }
}
```

This is the simplest model. No relationships â€” insights are derived data, not relational. A few notes:

- **`date` is the calendar day the insight covers.** We will query by date range. In a production app you would normalize this to `startOfDay` before saving. We handle that in the service.
- **`sentimentScore` is a `Double` from 0.0 to 1.0.** Like `recoveryStatus`, the range is enforced in the service, not the model. SwiftData models are data containers, not validation layers.
- **`generatedAt` defaults to `.now`.** This tracks when the on-device ML generated the insight, useful for cache invalidation.

### AI Output Review

Here is how I evaluate what the AI generated:

- **Relationship declarations with explicit inverses** â€” the AI got this right, including the asymmetric pattern where only one side declares `inverse:`
- **Delete rules are `.nullify` across the board** â€” correct for a many-to-many where neither side owns the other
- **No force unwraps anywhere** â€” every property is either non-optional with a default or genuinely required in the init
- **`@Attribute(.unique)` on id fields** â€” good practice, though SwiftData generates its own `persistentModelID` internally. The unique constraint prevents accidental duplicates during sync or migration

One thing to watch: the AI might generate `var tags: [RecoveryTag]?` as an optional array. If it does, change it to a non-optional `[RecoveryTag]` initialized to `[]`. Optional arrays in SwiftData relationships create unnecessary nil-checking in every query and view.

## Iteration

The initial generation is solid, but we need the service and the container configuration. Here is the follow-up prompt:

```
Now create two things:

1. A RecoveryService protocol in Services/RecoveryService.swift
   with these methods:
   - addCheckIn(recoveryStatus:emoji:note:tags:) -> CheckIn
   - deleteCheckIn(_ checkIn: CheckIn)
   - fetchCheckIns(from:to:) -> [CheckIn] using #Predicate
   - fetchCheckIns(recoveryStatus:) -> [CheckIn] using #Predicate
   - fetchAllTags() -> [RecoveryTag]
   - addTag(name:color:) -> RecoveryTag
   - fetchInsight(for date: Date) -> RecoveryInsight?
   - saveInsight(date:summary:sentimentScore:) -> RecoveryInsight

2. A SwiftDataRecoveryService class that implements this
   protocol using a ModelContext. Mark it @MainActor since
   ModelContext is not Sendable.

3. Update BetAwayApp.swift to configure a ModelContainer
   with all three models and inject a SwiftDataRecoveryService
   into the environment.

Use #Predicate for all queries. Handle errors with
os.Logger, not print(). Use Swift 6 strict concurrency.
```

### RecoveryService Protocol and Implementation

```swift
import Foundation
import SwiftData
import os

protocol RecoveryService {
    func addCheckIn(recoveryStatus: Int, emoji: String, note: String, tags: [RecoveryTag]) -> CheckIn
    func deleteCheckIn(_ checkIn: CheckIn)
    func fetchCheckIns(from startDate: Date, to endDate: Date) -> [CheckIn]
    func fetchCheckIns(recoveryStatus: Int) -> [CheckIn]
    func fetchAllTags() -> [RecoveryTag]
    func addTag(name: String, color: String) -> RecoveryTag
    func fetchInsight(for date: Date) -> RecoveryInsight?
    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> RecoveryInsight
}

@MainActor
final class SwiftDataRecoveryService: RecoveryService {
    private let modelContext: ModelContext
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "RecoveryService")

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func addCheckIn(recoveryStatus: Int, emoji: String, note: String, tags: [RecoveryTag]) -> CheckIn {
        let checkIn = CheckIn(recoveryStatus: recoveryStatus, emoji: emoji, note: note)
        checkIn.tags = tags
        modelContext.insert(checkIn)
        save()
        return checkIn
    }

    func deleteCheckIn(_ checkIn: CheckIn) {
        modelContext.delete(checkIn)
        save()
    }

    func fetchCheckIns(from startDate: Date, to endDate: Date) -> [CheckIn] {
        let predicate = #Predicate<CheckIn> {
            $0.createdAt >= startDate && $0.createdAt <= endDate
        }
        let descriptor = FetchDescriptor<CheckIn>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch check-ins by date range: \(error.localizedDescription)")
            return []
        }
    }

    func fetchCheckIns(recoveryStatus: Int) -> [CheckIn] {
        let predicate = #Predicate<CheckIn> {
            $0.recoveryStatus == recoveryStatus
        }
        let descriptor = FetchDescriptor<CheckIn>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch check-ins by recovery status: \(error.localizedDescription)")
            return []
        }
    }

    func fetchAllTags() -> [RecoveryTag] {
        let descriptor = FetchDescriptor<RecoveryTag>(
            sortBy: [SortDescriptor(\.name)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch tags: \(error.localizedDescription)")
            return []
        }
    }

    func addTag(name: String, color: String) -> RecoveryTag {
        let tag = RecoveryTag(name: name, color: color)
        modelContext.insert(tag)
        save()
        return tag
    }

    func fetchInsight(for date: Date) -> RecoveryInsight? {
        let startOfDay = Calendar.current.startOfDay(for: date)
        let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: startOfDay)!

        let predicate = #Predicate<RecoveryInsight> {
            $0.date >= startOfDay && $0.date < endOfDay
        }
        let descriptor = FetchDescriptor<RecoveryInsight>(predicate: predicate)
        do {
            return try modelContext.fetch(descriptor).first
        } catch {
            logger.error("Failed to fetch insight: \(error.localizedDescription)")
            return nil
        }
    }

    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> RecoveryInsight {
        let normalizedDate = Calendar.current.startOfDay(for: date)
        let insight = RecoveryInsight(
            date: normalizedDate,
            summary: summary,
            sentimentScore: sentimentScore
        )
        modelContext.insert(insight)
        save()
        return insight
    }

    // MARK: - Private

    private func save() {
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save context: \(error.localizedDescription)")
        }
    }
}
```

This is the core of the lesson, so let us break down the decisions that matter.

**Why a protocol at all?** Because in Module 6, we write unit tests. Tests need a mock service that returns controlled data without touching a real database. If your views call `ModelContext` directly, you cannot test them without standing up a full SwiftData stack. The protocol gives us a seam to inject either the real implementation or a mock.

**`@MainActor` on the class.** `ModelContext` is bound to the actor that created it. In SwiftUI apps, the main context lives on `@MainActor`. If you try to use it from a background thread under Swift 6 strict concurrency, the compiler stops you. Marking the service `@MainActor` makes this explicit and safe.

**`#Predicate` for every query.** This is SwiftData's compile-time-checked query syntax. Unlike Core Data's `NSPredicate` (which is a runtime string), `#Predicate` catches type errors at compile time. If you rename `createdAt` to `timestamp`, every `#Predicate` that references it will show a compiler error â€” no silent runtime failures.

**`fetchInsight(for:)` normalizes to start-of-day.** We query for insights by calendar day, not exact timestamp. The predicate uses `>= startOfDay && < endOfDay` (note: strict less-than on the upper bound). This is the correct pattern for day-based queries â€” using `<=` on the end date would include the first instant of the next day.

**`saveInsight` normalizes the date before insertion.** This ensures that two insights for the same day always have the same `date` value, which prevents duplicates and makes queries reliable.

### ModelContainer Configuration

```swift
import SwiftUI
import SwiftData

@main
struct BetAwayApp: App {
    let modelContainer: ModelContainer

    init() {
        do {
            let schema = Schema([
                CheckIn.self,
                RecoveryTag.self,
                RecoveryInsight.self,
            ])
            let configuration = ModelConfiguration(isStoredInMemoryOnly: false)
            modelContainer = try ModelContainer(for: schema, configurations: [configuration])
            seedTagsIfNeeded()
        } catch {
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(
                    SwiftDataRecoveryService(modelContext: modelContainer.mainContext)
                )
        }
        .modelContainer(modelContainer)
    }

    private func seedTagsIfNeeded() {
        let hasSeeded = UserDefaults.standard.bool(forKey: "hasSeededTags")
        guard !hasSeeded else { return }

        let context = modelContainer.mainContext
        for item in RecoveryTag.predefined {
            let tag = RecoveryTag(name: item.name, color: item.color)
            context.insert(tag)
        }

        do {
            try context.save()
            UserDefaults.standard.set(true, forKey: "hasSeededTags")
        } catch {
            print("Failed to seed tags: \(error)")
        }
    }
}
```

**`fatalError` in the catch block is intentional.** If the database cannot be created, the app has no persistence. There is no graceful recovery â€” this is the standard Apple pattern.

**Service injection via `.environment()`.** We create the service once at the app level and inject it into the view hierarchy. Every view that needs data access reads it from the environment. This is dependency injection without any third-party framework.

**Tag seeding uses the same `UserDefaults` flag pattern** we used in the free course. Simple, reliable, one-time execution.

## Verify Phase

Before moving to the next lesson, verify these things manually:

1. **Build the project.** All four files should compile with zero warnings under Swift 6 strict concurrency. If you see `Sendable` warnings on the service, confirm that `@MainActor` is on the class declaration.

2. **Check the relationship inverse.** Open `CheckIn.swift` and confirm that `@Relationship(inverse: \RecoveryTag.checkIns)` points to the correct keypath. Open `RecoveryTag.swift` and confirm it does NOT also declare an `inverse:` parameter. Only one side declares the inverse.

3. **Check delete rules.** Both relationships should use `.nullify`. If the AI generated `.cascade` on either side, change it. Cascade on a many-to-many means deleting one check-in would delete all its tags â€” and those tags would then be removed from every other check-in that used them. Cascade is almost never correct for many-to-many.

4. **Check that no property is force-unwrapped.** Search for `!` in all model files. There should be exactly one â€” the `endOfDay` calculation in `fetchInsight`, which is safe because `Calendar.date(byAdding:)` only returns nil for absurd inputs.

5. **Test the service.** Create a temporary button in ContentView that calls `service.addCheckIn(recoveryStatus: 4, emoji: "ðŸ’ª", note: "Test", tags: [])`. Tap it, quit the app, relaunch. The check-in should persist.

## Final Code

Here is every file, complete and compilable.

**Models/CheckIn.swift**

```swift
import Foundation
import SwiftData

@Model
final class CheckIn {
    @Attribute(.unique) var id: UUID
    var recoveryStatus: Int
    var emoji: String
    var note: String
    var createdAt: Date

    @Relationship(deleteRule: .nullify, inverse: \RecoveryTag.checkIns)
    var tags: [RecoveryTag]

    init(
        id: UUID = UUID(),
        recoveryStatus: Int,
        emoji: String,
        note: String = "",
        createdAt: Date = .now
    ) {
        self.id = id
        self.recoveryStatus = recoveryStatus
        self.emoji = emoji
        self.note = note
        self.createdAt = createdAt
        self.tags = []
    }
}
```

**Models/RecoveryTag.swift**

```swift
import Foundation
import SwiftData

@Model
final class RecoveryTag {
    @Attribute(.unique) var id: UUID
    var name: String
    var color: String

    @Relationship(deleteRule: .nullify)
    var checkIns: [CheckIn]

    init(
        id: UUID = UUID(),
        name: String,
        color: String
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.checkIns = []
    }

    static let predefined: [(name: String, color: String)] = [
        ("Urge", "#E74C3C"),
        ("Therapy", "#4A90D9"),
        ("Exercise", "#2ECC71"),
        ("Social", "#F39C12"),
        ("Financial", "#1ABC9C"),
        ("Breathing", "#9B59B6"),
    ]
}
```

**Models/RecoveryInsight.swift**

```swift
import Foundation
import SwiftData

@Model
final class RecoveryInsight {
    @Attribute(.unique) var id: UUID
    var date: Date
    var summary: String
    var sentimentScore: Double
    var generatedAt: Date

    init(
        id: UUID = UUID(),
        date: Date,
        summary: String,
        sentimentScore: Double,
        generatedAt: Date = .now
    ) {
        self.id = id
        self.date = date
        self.summary = summary
        self.sentimentScore = sentimentScore
        self.generatedAt = generatedAt
    }
}
```

**Services/RecoveryService.swift**

```swift
import Foundation
import SwiftData
import os

protocol RecoveryService {
    func addCheckIn(recoveryStatus: Int, emoji: String, note: String, tags: [RecoveryTag]) -> CheckIn
    func deleteCheckIn(_ checkIn: CheckIn)
    func fetchCheckIns(from startDate: Date, to endDate: Date) -> [CheckIn]
    func fetchCheckIns(recoveryStatus: Int) -> [CheckIn]
    func fetchAllTags() -> [RecoveryTag]
    func addTag(name: String, color: String) -> RecoveryTag
    func fetchInsight(for date: Date) -> RecoveryInsight?
    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> RecoveryInsight
}

@MainActor
final class SwiftDataRecoveryService: RecoveryService {
    private let modelContext: ModelContext
    private let logger = Logger(subsystem: "com.nativefirst.betaway", category: "RecoveryService")

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func addCheckIn(recoveryStatus: Int, emoji: String, note: String, tags: [RecoveryTag]) -> CheckIn {
        let checkIn = CheckIn(recoveryStatus: recoveryStatus, emoji: emoji, note: note)
        checkIn.tags = tags
        modelContext.insert(checkIn)
        save()
        return checkIn
    }

    func deleteCheckIn(_ checkIn: CheckIn) {
        modelContext.delete(checkIn)
        save()
    }

    func fetchCheckIns(from startDate: Date, to endDate: Date) -> [CheckIn] {
        let predicate = #Predicate<CheckIn> {
            $0.createdAt >= startDate && $0.createdAt <= endDate
        }
        let descriptor = FetchDescriptor<CheckIn>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch check-ins by date: \(error.localizedDescription)")
            return []
        }
    }

    func fetchCheckIns(recoveryStatus: Int) -> [CheckIn] {
        let predicate = #Predicate<CheckIn> {
            $0.recoveryStatus == recoveryStatus
        }
        let descriptor = FetchDescriptor<CheckIn>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch check-ins by status: \(error.localizedDescription)")
            return []
        }
    }

    func fetchAllTags() -> [RecoveryTag] {
        let descriptor = FetchDescriptor<RecoveryTag>(
            sortBy: [SortDescriptor(\.name)]
        )
        do {
            return try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch tags: \(error.localizedDescription)")
            return []
        }
    }

    func addTag(name: String, color: String) -> RecoveryTag {
        let tag = RecoveryTag(name: name, color: color)
        modelContext.insert(tag)
        save()
        return tag
    }

    func fetchInsight(for date: Date) -> RecoveryInsight? {
        let startOfDay = Calendar.current.startOfDay(for: date)
        let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: startOfDay)!

        let predicate = #Predicate<RecoveryInsight> {
            $0.date >= startOfDay && $0.date < endOfDay
        }
        let descriptor = FetchDescriptor<RecoveryInsight>(predicate: predicate)
        do {
            return try modelContext.fetch(descriptor).first
        } catch {
            logger.error("Failed to fetch insight: \(error.localizedDescription)")
            return nil
        }
    }

    func saveInsight(date: Date, summary: String, sentimentScore: Double) -> RecoveryInsight {
        let normalizedDate = Calendar.current.startOfDay(for: date)
        let insight = RecoveryInsight(
            date: normalizedDate,
            summary: summary,
            sentimentScore: sentimentScore
        )
        modelContext.insert(insight)
        save()
        return insight
    }

    private func save() {
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save context: \(error.localizedDescription)")
        }
    }
}
```

## Checkpoint

Before moving to Lesson 1.3, confirm all of these:

- [ ] `CheckIn`, `RecoveryTag`, and `RecoveryInsight` compile with zero warnings under Swift 6
- [ ] The `CheckIn.tags` relationship declares `inverse: \RecoveryTag.checkIns`
- [ ] `RecoveryTag.checkIns` does NOT also declare an inverse (only one side does)
- [ ] All delete rules are `.nullify`, not `.cascade`
- [ ] `RecoveryService` protocol exists with eight methods
- [ ] `SwiftDataRecoveryService` is marked `@MainActor`
- [ ] All queries use `#Predicate`, not string-based predicates
- [ ] `ModelContainer` is configured in `BetAwayApp.init()` with all three model types
- [ ] Predefined tags are seeded on first launch
- [ ] You can add a check-in, quit, relaunch, and the check-in persists

## Challenge

**Add a `fetchRecentCheckIns(limit:)` method** to both the protocol and the implementation. It should return the most recent N check-ins, sorted by `createdAt` descending.

Hint: `FetchDescriptor` has a `fetchLimit` property. Set it after creating the descriptor:

```swift
var descriptor = FetchDescriptor<CheckIn>(
    sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
)
descriptor.fetchLimit = limit
```

Try prompting Claude Code for this. Then compare the output with the hint. If the AI generates a `#Predicate` that tries to do the limiting â€” that is wrong. Limiting is a fetch descriptor concern, not a predicate concern. The predicate filters *which* records match. The fetch limit controls *how many* come back. These are different operations.
