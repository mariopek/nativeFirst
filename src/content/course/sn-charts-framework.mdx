---
title: "Charts Framework"
description: "Visualize recovery progress with Swift Charts — line charts for streaks over time, bar charts for check-in distribution, and weekly comparisons with custom styling that matches your design system."
courseSlug: "ship-native"
module: 5
moduleTitle: "System Frameworks"
lesson: 1
duration: "22 min read"
difficulty: "intermediate"
topics: ["Swift Charts", "Data Visualization", "Line Chart", "Bar Chart", "Custom Styling", "Recovery Progress", "BetAway"]
author: "Mario"
draft: false
pubDate: 2026-02-22
---

Your users have been logging recovery check-ins for weeks. The data is sitting in SwiftData. But raw data is not insight — a list of check-ins is useless unless you can see the patterns. Did the user's recovery streak improve this week compared to last? Are mornings consistently harder than evenings? What is the overall distribution of recovery statuses?

This is what Swift Charts is for. Apple shipped it in iOS 16, and it is the right way to build data visualizations in SwiftUI. No third-party libraries, no UIKit wrapping, no Core Graphics paths. Declarative chart building that fits naturally into your existing views.

## What You'll Learn

- Build a `LineMark` chart that shows recovery streaks over time with smooth interpolation
- Build a `BarMark` chart that shows check-in distribution across recovery status categories
- Create a `ChartDataProvider` that aggregates raw check-ins into chart-ready data outside the view
- Apply custom styling — brand colors, axis formatting, animations on data load — so your charts look intentional, not default

## Why This Matters

Every health, recovery, and wellness app ships with charts. Users expect them. But most AI-generated charts look like developer demos — default colors, no labels, no loading states, raw data dumped into a `Chart{}` block. That is not a feature; that is a prototype.

Production charts need three things AI tends to skip: data aggregation before rendering, custom styling that matches your design system, and graceful handling of edge cases like empty data or single-day ranges. We are going to build all three.

## Plan Phase: Defining What We Build

We need three chart components: a line chart for recovery streaks over time, a bar chart for check-in distribution, and a weekly comparison view. But before any chart renders, we need a data provider that transforms raw `CheckIn` records into chart-friendly structures.

Here is the prompt for the planning phase:

```
I'm building a gambling recovery app called BetAway using
SwiftUI and SwiftData. I need to add data visualization for
recovery progress.

Here's the context:
- CheckIn model has: id, status (1-5 scale), date, note
- Users log 1-3 check-ins per day
- Target iOS 17+, Swift 6, @Observable pattern

I need:
1. A ChartDataProvider that aggregates CheckIn data into
   chart-ready structures (daily averages, status distribution,
   weekly summaries)
2. A RecoveryTrendChart (LineMark) showing daily average
   recovery status over the last 30 days
3. A StatusDistributionChart (BarMark) showing count of each
   recovery status (1-5)
4. A WeeklyComparisonChart showing this week vs last week
5. A RecoveryChartView that composes all three with a picker

Requirements:
- Charts should animate on data load
- Use brand colors (I'll define them), not defaults
- Handle empty states — no data yet, single day only
- Do NOT compute aggregations inside the view body
- Use Swift Charts framework (import Charts)

What's your implementation plan? List the types you'll create
and their responsibilities before writing code.
```

**What to look for in the plan.** The AI should propose separate data types for chart data (not reusing CheckIn directly), a provider class that does the aggregation, and individual chart views that receive pre-computed data. If the AI proposes doing `.filter()` and `.reduce()` inside the `Chart{}` body, that is wrong — push back immediately.

**Anti-pattern: computing chart data in the view.** This is the most common mistake. AI will generate something like `Chart { ForEach(entries.filter { Calendar.current.isDate($0.date, equalTo: ...) }) }` directly in the view body. Every redraw re-filters and re-aggregates. The data provider pattern keeps computation out of the render path.

## Execute Phase: Implementation

Now we generate the actual code. Send this prompt:

```
Generate the ChartDataProvider and all chart views based on
the plan. Use these specifics:

- ChartDataProvider is @Observable, takes [CheckIn] in
  a refresh method
- DailyStatusAverage struct: date (Date), averageStatus (Double)
- StatusDistribution struct: level (Int), count (Int),
  label (String)
- WeeklySummary struct: dayOfWeek (String), thisWeek (Double?),
  lastWeek (Double?)
- Brand colors: status 1 = .red, 2 = .orange, 3 = .yellow,
  4 = .mint, 5 = .green
- LineMark with .interpolationMethod(.catmullRom) for smooth
  curves
- BarMark with cornerRadius and brand color per bar
- Animate chart appearance with .opacity transition
- Handle empty data with ContentUnavailableView

Put ChartDataProvider in Services/ChartDataProvider.swift
Put chart views in Views/Charts/
```

Review the AI output against this checklist:

- **Data types are value types (structs), not classes.** Chart data is immutable once computed. If the AI made them classes, change to structs.
- **ChartDataProvider.refresh() does the heavy lifting.** It should loop through check-ins once, compute all three aggregations, and store the results as published properties. Not three separate methods that each iterate the full dataset.
- **LineMark uses `.interpolationMethod(.catmullRom)`.** If the AI used `.linear` or omitted interpolation, the line will look jagged. CatmullRom gives smooth curves through data points.
- **BarMark has `.cornerRadius()`.** Default bars look flat and dated. Even 4 points of corner radius makes a visible difference.
- **Empty state handling exists.** If `dailyAverages` is empty, the chart should show a `ContentUnavailableView`, not an empty axes frame.

## Iteration

The first pass usually gets the data flow right but misses styling details. Send this follow-up:

```
The charts work but need polish:

1. The Y axis should show recovery status labels instead of
   numbers: 1 = "Crisis", 2 = "Struggling", 3 = "Coping",
   4 = "Strong", 5 = "Thriving"
2. The X axis on the line chart should show abbreviated dates
   (e.g., "Feb 3") not full timestamps
3. Add a .chartYScale(domain: 1...5) so the axis doesn't auto-
   scale and jump around when data changes
4. Add an area gradient below the line chart (use
   .foregroundStyle with a linear gradient from brand color
   to clear)
5. The weekly comparison should use grouped bars with a legend
6. Add .animation(.easeInOut(duration: 0.4), value: data) to
   each chart so data transitions are smooth
```

This iteration takes the charts from "works" to "ships." The fixed Y-axis domain is especially important — without it, a day where all statuses are 4-5 will auto-scale to fill the chart, making it look like there is huge variation when there is not.

## Verify Phase

Build and run. Check these things manually:

1. **Line chart with 30 days of data** — does the curve look smooth? Are the X-axis labels readable and not overlapping?
2. **Line chart with 1 day of data** — does it show a single dot, not a broken line?
3. **Line chart with 0 data** — does it show the empty state, not a blank chart frame?
4. **Bar chart** — are the colors correct for each recovery status level? Does the count label show on or above each bar?
5. **Weekly comparison** — do "this week" and "last week" bars appear side by side? Is the legend visible?
6. **Animation** — navigate to the charts tab. Do the charts animate in, or do they pop?
7. **Performance** — with 90 days of data (roughly 180 check-ins), does the chart view load without lag? If you see a hitch, check that `ChartDataProvider.refresh()` is not being called on every frame.

## Final Code

### ChartDataProvider

```swift
import Foundation

struct DailyStatusAverage: Identifiable {
    let id = UUID()
    let date: Date
    let averageStatus: Double
}

struct StatusDistribution: Identifiable {
    let id = UUID()
    let level: Int
    let count: Int

    var label: String {
        switch level {
        case 1: "Crisis"
        case 2: "Struggling"
        case 3: "Coping"
        case 4: "Strong"
        case 5: "Thriving"
        default: "Unknown"
        }
    }
}

struct WeeklySummary: Identifiable {
    let id = UUID()
    let dayOfWeek: String
    let thisWeek: Double?
    let lastWeek: Double?
}

@Observable
final class ChartDataProvider {
    var dailyAverages: [DailyStatusAverage] = []
    var statusDistribution: [StatusDistribution] = []
    var weeklySummary: [WeeklySummary] = []
    var hasData: Bool { !dailyAverages.isEmpty }

    func refresh(from checkIns: [CheckIn]) {
        computeDailyAverages(checkIns)
        computeStatusDistribution(checkIns)
        computeWeeklySummary(checkIns)
    }

    private func computeDailyAverages(_ checkIns: [CheckIn]) {
        let calendar = Calendar.current
        let cutoff = calendar.date(byAdding: .day, value: -30, to: .now) ?? .now

        let recent = checkIns.filter { $0.date >= cutoff }
        let grouped = Dictionary(grouping: recent) { checkIn in
            calendar.startOfDay(for: checkIn.date)
        }

        dailyAverages = grouped.map { date, dayCheckIns in
            let average = Double(dayCheckIns.reduce(0) { $0 + $1.status }) / Double(dayCheckIns.count)
            return DailyStatusAverage(date: date, averageStatus: average)
        }
        .sorted { $0.date < $1.date }
    }

    private func computeStatusDistribution(_ checkIns: [CheckIn]) {
        let counts = Dictionary(grouping: checkIns) { $0.status }
        statusDistribution = (1...5).map { level in
            StatusDistribution(level: level, count: counts[level]?.count ?? 0)
        }
    }

    private func computeWeeklySummary(_ checkIns: [CheckIn]) {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: .now)
        let weekday = calendar.component(.weekday, from: today)
        let startOfThisWeek = calendar.date(byAdding: .day, value: -(weekday - 1), to: today) ?? today
        let startOfLastWeek = calendar.date(byAdding: .day, value: -7, to: startOfThisWeek) ?? today

        let daySymbols = calendar.shortWeekdaySymbols

        weeklySummary = (0..<7).map { offset in
            let thisWeekDay = calendar.date(byAdding: .day, value: offset, to: startOfThisWeek)!
            let lastWeekDay = calendar.date(byAdding: .day, value: offset, to: startOfLastWeek)!

            let thisWeekCheckIns = checkIns.filter { calendar.isDate($0.date, inSameDayAs: thisWeekDay) }
            let lastWeekCheckIns = checkIns.filter { calendar.isDate($0.date, inSameDayAs: lastWeekDay) }

            let thisWeekAvg: Double? = thisWeekCheckIns.isEmpty ? nil :
                Double(thisWeekCheckIns.reduce(0) { $0 + $1.status }) / Double(thisWeekCheckIns.count)
            let lastWeekAvg: Double? = lastWeekCheckIns.isEmpty ? nil :
                Double(lastWeekCheckIns.reduce(0) { $0 + $1.status }) / Double(lastWeekCheckIns.count)

            return WeeklySummary(
                dayOfWeek: daySymbols[(offset + 1) % 7],
                thisWeek: thisWeekAvg,
                lastWeek: lastWeekAvg
            )
        }
    }
}
```

### RecoveryTrendChart

```swift
import SwiftUI
import Charts

struct RecoveryTrendChart: View {
    let data: [DailyStatusAverage]

    @State private var isVisible = false

    var body: some View {
        if data.isEmpty {
            ContentUnavailableView(
                "No Recovery Data Yet",
                systemImage: "chart.line.downtrend.xyaxis",
                description: Text("Log a few check-ins to see your recovery trends over time.")
            )
            .frame(height: 240)
        } else {
            Chart(data) { entry in
                LineMark(
                    x: .value("Date", entry.date, unit: .day),
                    y: .value("Status", entry.averageStatus)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(Color.green.gradient)
                .lineStyle(StrokeStyle(lineWidth: 2.5))

                AreaMark(
                    x: .value("Date", entry.date, unit: .day),
                    y: .value("Status", entry.averageStatus)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(
                    LinearGradient(
                        colors: [.green.opacity(0.3), .green.opacity(0.0)],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )

                PointMark(
                    x: .value("Date", entry.date, unit: .day),
                    y: .value("Status", entry.averageStatus)
                )
                .symbolSize(24)
                .foregroundStyle(.green)
            }
            .chartYScale(domain: 1...5)
            .chartYAxis {
                AxisMarks(values: [1, 2, 3, 4, 5]) { value in
                    AxisGridLine()
                    AxisValueLabel {
                        if let intValue = value.as(Int.self) {
                            Text(statusLabel(for: intValue))
                                .font(.caption2)
                        }
                    }
                }
            }
            .chartXAxis {
                AxisMarks(values: .stride(by: .day, count: 7)) { _ in
                    AxisGridLine()
                    AxisValueLabel(format: .dateTime.month(.abbreviated).day())
                }
            }
            .frame(height: 240)
            .opacity(isVisible ? 1 : 0)
            .animation(.easeInOut(duration: 0.5), value: isVisible)
            .onAppear { isVisible = true }
        }
    }

    private func statusLabel(for value: Int) -> String {
        switch value {
        case 1: "Crisis"
        case 2: "Struggling"
        case 3: "Coping"
        case 4: "Strong"
        case 5: "Thriving"
        default: ""
        }
    }
}
```

### StatusDistributionChart

```swift
import SwiftUI
import Charts

struct StatusDistributionChart: View {
    let data: [StatusDistribution]

    @State private var isVisible = false

    private func barColor(for level: Int) -> Color {
        switch level {
        case 1: .red
        case 2: .orange
        case 3: .yellow
        case 4: .mint
        case 5: .green
        default: .gray
        }
    }

    var body: some View {
        if data.allSatisfy({ $0.count == 0 }) {
            ContentUnavailableView(
                "No Recovery Data Yet",
                systemImage: "chart.bar",
                description: Text("Start logging check-ins to see your distribution.")
            )
            .frame(height: 240)
        } else {
            Chart(data) { item in
                BarMark(
                    x: .value("Status", item.label),
                    y: .value("Count", item.count)
                )
                .foregroundStyle(barColor(for: item.level))
                .cornerRadius(6)
                .annotation(position: .top) {
                    if item.count > 0 {
                        Text("\(item.count)")
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
            }
            .chartYAxis {
                AxisMarks(values: .automatic(desiredCount: 5))
            }
            .frame(height: 240)
            .opacity(isVisible ? 1 : 0)
            .animation(.easeInOut(duration: 0.5), value: isVisible)
            .onAppear { isVisible = true }
        }
    }
}
```

### WeeklyComparisonChart

```swift
import SwiftUI
import Charts

struct WeeklyComparisonChart: View {
    let data: [WeeklySummary]

    @State private var isVisible = false

    var body: some View {
        let hasAnyData = data.contains { $0.thisWeek != nil || $0.lastWeek != nil }

        if !hasAnyData {
            ContentUnavailableView(
                "Not Enough Data",
                systemImage: "calendar",
                description: Text("Log check-ins for two weeks to compare trends.")
            )
            .frame(height: 240)
        } else {
            Chart {
                ForEach(data) { summary in
                    if let thisWeek = summary.thisWeek {
                        BarMark(
                            x: .value("Day", summary.dayOfWeek),
                            y: .value("Status", thisWeek)
                        )
                        .foregroundStyle(by: .value("Week", "This Week"))
                        .cornerRadius(4)
                        .position(by: .value("Week", "This Week"))
                    }

                    if let lastWeek = summary.lastWeek {
                        BarMark(
                            x: .value("Day", summary.dayOfWeek),
                            y: .value("Status", lastWeek)
                        )
                        .foregroundStyle(by: .value("Week", "Last Week"))
                        .cornerRadius(4)
                        .position(by: .value("Week", "Last Week"))
                    }
                }
            }
            .chartYScale(domain: 1...5)
            .chartForegroundStyleScale([
                "This Week": Color.green,
                "Last Week": Color.green.opacity(0.4)
            ])
            .chartLegend(position: .top, alignment: .leading)
            .chartYAxis {
                AxisMarks(values: [1, 2, 3, 4, 5]) { value in
                    AxisGridLine()
                    AxisValueLabel {
                        if let intValue = value.as(Int.self) {
                            Text(statusLabel(for: intValue))
                                .font(.caption2)
                        }
                    }
                }
            }
            .frame(height: 240)
            .opacity(isVisible ? 1 : 0)
            .animation(.easeInOut(duration: 0.5), value: isVisible)
            .onAppear { isVisible = true }
        }
    }

    private func statusLabel(for value: Int) -> String {
        switch value {
        case 1: "Crisis"
        case 2: "Struggling"
        case 3: "Coping"
        case 4: "Strong"
        case 5: "Thriving"
        default: ""
        }
    }
}
```

### RecoveryChartView (Composed Container)

```swift
import SwiftUI

struct RecoveryChartView: View {
    @State private var chartProvider = ChartDataProvider()
    @State private var selectedChart: ChartType = .trend

    let checkIns: [CheckIn]

    enum ChartType: String, CaseIterable {
        case trend = "Trend"
        case distribution = "Distribution"
        case weekly = "Weekly"
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                Picker("Chart", selection: $selectedChart) {
                    ForEach(ChartType.allCases, id: \.self) { type in
                        Text(type.rawValue).tag(type)
                    }
                }
                .pickerStyle(.segmented)
                .padding(.horizontal)

                Group {
                    switch selectedChart {
                    case .trend:
                        RecoveryTrendChart(data: chartProvider.dailyAverages)
                    case .distribution:
                        StatusDistributionChart(data: chartProvider.statusDistribution)
                    case .weekly:
                        WeeklyComparisonChart(data: chartProvider.weeklySummary)
                    }
                }
                .padding(.horizontal)

                Spacer()
            }
            .navigationTitle("Insights")
            .onAppear {
                chartProvider.refresh(from: checkIns)
            }
            .onChange(of: checkIns.count) {
                chartProvider.refresh(from: checkIns)
            }
        }
    }
}

#Preview {
    RecoveryChartView(checkIns: [])
}
```

## Checkpoint

Before moving on, verify each of these:

- [ ] `ChartDataProvider` computes daily averages, distribution, and weekly summaries in its `refresh()` method — not inside any view body
- [ ] The line chart uses `.chartYScale(domain: 1...5)` so the Y axis does not jump around
- [ ] Y-axis labels show recovery status words ("Crisis" through "Thriving"), not just numbers
- [ ] Each chart handles the empty data case with `ContentUnavailableView`
- [ ] Bar chart colors match the recovery status level: red for 1, orange for 2, yellow for 3, mint for 4, green for 5
- [ ] Weekly comparison chart shows grouped bars with a visible legend
- [ ] All three charts animate in with an opacity transition on appear
- [ ] The `RecoveryChartView` uses a segmented picker to switch between charts
- [ ] No filtering, grouping, or averaging happens inside a `Chart{}` block or view body

## Challenge

**Add an interactive selection to the line chart.**

When the user taps or drags on the line chart, show an overlay that highlights the selected day and displays the exact average recovery status value in a floating label above the data point. Use the `.chartOverlay` modifier with a `DragGesture` to detect the X position, then convert it to a date using `ChartProxy.value(atX:)`.

**Hint:** The `chartOverlay` modifier gives you a `ChartProxy` in its closure. Call `proxy.value(atX: location.x, as: Date.self)` to convert the gesture's X coordinate to a date value. Then find the closest `DailyStatusAverage` entry to that date and render a `RuleMark` at that position with an annotation showing the value. Store the selected date in a `@State` property and clear it when the gesture ends.
