---
title: "Notifications & App Intents"
description: "Schedule morning pledge and evening check-in reminders with UNUserNotificationCenter, handle notification authorization in SettingsViewModel, and integrate localized notification content through LanguageManager."
courseSlug: "ship-native"
module: 5
moduleTitle: "System Frameworks"
lesson: 3
duration: "20 min read"
difficulty: "intermediate"
topics: ["Notifications", "App Intents", "UNUserNotificationCenter", "Reminders", "Automation", "BetAway"]
author: "Mario"
draft: true
pubDate: 2026-02-22
---

A recovery app that relies on users remembering to open it is a recovery app that gets abandoned in two weeks. BetAway's data is only valuable if pledges and check-ins are consistent, and consistency requires a nudge. That nudge is a local notification — a gentle morning reminder that says "Start your day with a pledge to stay bet-free" and an evening prompt that says "How was your day? Take a moment to reflect."

BetAway does not use a single generic daily reminder. It uses two separate notifications — a morning pledge reminder and an evening check-in reminder — each with configurable times stored on the `UserProfile` SwiftData model. The `NotificationManager` handles scheduling, and the `SettingsViewModel` handles the critical permission-request flow when the user toggles notifications on.

## What You'll Learn

- Build a `NotificationManager` that schedules two daily reminders — morning pledge and evening check-in — at user-chosen times using `UNUserNotificationCenter`
- Request notification permission at the right moment — not at launch, but when the user explicitly enables notifications in Settings or during onboarding
- Store reminder times as hour/minute integers on the `UserProfile` SwiftData model with sensible defaults from `AppConfig`
- Localize notification content through `LanguageManager` so reminders arrive in the user's chosen language
- Handle the toggle-to-permission flow in `SettingsViewModel` where a denied permission flips the toggle back off

## Why This Matters

Notification permission is a one-shot deal on iOS. If you ask at the wrong moment — like the first time the app launches, before the user understands why you need it — and they tap "Don't Allow," you cannot ask again. Ever. The system remembers. You are locked out of notifications for that user unless they manually go to Settings. This is why timing the permission request correctly is not a UX nicety; it is a business requirement.

BetAway solves this by requesting permission only when the user takes an explicit action: toggling the notification switch ON in Settings, or enabling notifications during onboarding. By that point, the user has already set their quit date, chosen their gambling types, and understands what the app does. The context is clear. They know why you want permission.

## Plan Phase: Defining What We Build

We need a notification system that schedules two daily repeating reminders — morning pledge and evening check-in — with localized content, configurable times, and a clean permission flow. Here is the planning prompt:

```
I'm adding daily reminder notifications to BetAway, my SwiftUI
gambling recovery app. The app uses SwiftData with a UserProfile
model and LanguageManager for 12-language localization.

Feature — Morning Pledge & Evening Check-in Reminders:
- A NotificationManager (@Observable) that schedules two daily
  local notifications: a morning pledge reminder and an evening
  check-in reminder
- Each has separate hour/minute stored on UserProfile with
  defaults from AppConfig (morning 8:00 AM, evening 9:00 PM)
- Permission is requested ONLY when the user toggles notifications
  ON in Settings or during onboarding — NOT at app launch
- If permission is denied, flip the toggle back to OFF on the
  UserProfile model
- Notification content must be localized through LanguageManager
- An updateSchedule() method that takes morning/evening times
  and an enabled flag — schedules both if enabled, cancels all
  if disabled
- A milestone notification that fires immediately when the user
  hits a streak milestone

Technical:
- Target iOS 17+, Swift 6
- Use UNUserNotificationCenter
- UNCalendarNotificationTrigger with repeats: true for daily
- Cancel existing notification by ID before scheduling new one
  to prevent duplicates
- Use LanguageManager.shared.localized() for notification strings

What is the implementation plan?
```

**What to look for in the plan.** The AI should separate notification logic from the view layer. It should propose storing reminder times as integer hour/minute on the `UserProfile` SwiftData model (not as `Date` in `UserDefaults` — these are user profile settings that belong with the profile). For the permission flow, it should place `requestAuthorization()` inside `SettingsViewModel.toggleNotifications()`, not in `NotificationManager.init()`. If the AI proposes requesting permission at app launch, stop it.

**Anti-pattern: requesting notification permission at app launch.** I cannot stress this enough. The worst thing you can do is call `requestAuthorization()` in your `App.init()` or in `ContentView.onAppear`. The user has no context for why you want permission. They will deny it reflexively. Request permission only when the user takes an explicit action that requires notifications — in BetAway, when they toggle the notification switch in Settings or enable notifications during onboarding.

## Execute Phase: Implementation

```
Generate the NotificationManager and the SettingsViewModel
notification toggle logic. Specifics:

NotificationManager:
- @Observable class in Core/Services/NotificationManager.swift
- Properties: isAuthorized (Bool)
- Private: center (UNUserNotificationCenter.current())
- Methods:
  - requestAuthorization() async -> Bool
  - checkAuthorizationStatus() async
  - scheduleMorningPledge(hour:minute:) — cancels existing
    "morning_pledge_reminder" then schedules new one
  - scheduleEveningCheckin(hour:minute:) — cancels existing
    "evening_checkin_reminder" then schedules new one
  - scheduleMilestoneReminder(dayCount:title:) — immediate one-shot
  - updateSchedule(morningHour:morningMinute:eveningHour:eveningMinute:enabled:)
    — calls both schedule methods if enabled, cancelAll if not
  - cancelAll() — removes all pending notifications
  - cancelReminder(id:) — removes one specific notification
- All notification content uses LanguageManager.shared.localized()
- Notification IDs: "morning_pledge_reminder", "evening_checkin_reminder",
  "milestone_{dayCount}"

SettingsViewModel:
- Contains a NotificationManager instance
- toggleNotifications(enabled:profile:) method that:
  - If enabling: requests authorization, if granted calls
    updateSchedule with profile's times, if denied sets
    profile.notificationsEnabled = false
  - If disabling: calls cancelAll()

UserProfile (relevant properties):
- notificationsEnabled: Bool (default true)
- morningReminderHour: Int (default from AppConfig.defaultMorningHour)
- morningReminderMinute: Int (default from AppConfig.defaultMorningMinute)
- eveningReminderHour: Int (default from AppConfig.defaultEveningHour)
- eveningReminderMinute: Int (default from AppConfig.defaultEveningMinute)

AppConfig (relevant constants):
- defaultMorningHour = 8, defaultMorningMinute = 0
- defaultEveningHour = 21, defaultEveningMinute = 0
- morningPledgeWindowStart = 5, morningPledgeWindowEnd = 12
- eveningCheckinWindowStart = 18, eveningCheckinWindowEnd = 23
```

Review the AI output for these specific issues:

- **Permission request is inside `SettingsViewModel.toggleNotifications()`, not in `init()`.** The method should be called only from user interaction, not automatically.
- **Each schedule method cancels its own ID before scheduling.** Without canceling first, you get duplicate notifications. `scheduleMorningPledge` cancels `"morning_pledge_reminder"` before creating a new one. Same for evening.
- **`updateSchedule()` orchestrates both reminders.** A single method that takes all four time components and an enabled flag. If enabled, schedule both. If disabled, cancel all.
- **`UserProfile` stores times as integer hour/minute, not `Date`.** This avoids timezone and serialization issues with SwiftData. The defaults come from `AppConfig`.
- **Notification content is localized through `LanguageManager`.** The title and body strings use `LanguageManager.shared.localized()` so the notification arrives in the user's chosen language, not the system language.

## Iteration

The first pass typically gets the functionality right but misses the integration points. Send this:

```
Two improvements needed:

1. For the Settings UI: Show the morning and evening reminder
   times below the notification toggle when notifications are
   enabled. Use a formatTime(hour:minute:) helper to display
   them as "8:00 AM" / "9:00 PM". The times are stored as
   integer hour/minute on the UserProfile.

2. For the permission denial flow: In toggleNotifications(),
   when requestAuthorization() returns false (denied), set
   profile.notificationsEnabled = false on the MainActor so
   the toggle flips back. This must happen on MainActor because
   it modifies a SwiftData model which is main-actor-isolated.
```

This iteration handles the critical denial flow. Without it, the toggle can be ON while notifications are actually denied, which is confusing. The toggle state must always reflect the real authorization status.

## Verify Phase

These features need specific testing scenarios:

**Notifications:**

1. **First toggle ON** — Does the system permission dialog appear? If you tap "Allow," do both reminders schedule? Check in Settings > Notifications > BetAway that the permission is granted.
2. **Deny permission** — Reset notification permissions in the simulator (delete and reinstall the app). Toggle the reminder ON, then deny. Does the toggle flip back to OFF? Does `profile.notificationsEnabled` get set to `false`?
3. **Change the time during onboarding** — Set the morning reminder to 7:00 AM and evening to 10:00 PM. Complete onboarding. Check the scheduled notifications match those times.
4. **Kill and relaunch the app** — Are the times still correct? They are stored on the `UserProfile` SwiftData model, so they should persist.
5. **Localized content** — Switch the app language to Spanish in Settings. Toggle notifications off and back on. The notification content should now say "Buenos dias" and the evening version in Spanish, not English.

## Final Code

### AppConfig — Timing Constants

The default reminder times and pledge/check-in time windows are defined in `AppConfig`:

```swift
enum AppConfig {
    // MARK: - App Identity
    static let appName = "BetAway"
    static var appTagline: String { LanguageManager.shared.localized("Your path to freedom") }

    // MARK: - Timing
    static let morningPledgeWindowStart = 5
    static let morningPledgeWindowEnd = 12
    static let eveningCheckinWindowStart = 18
    static let eveningCheckinWindowEnd = 23
    static let defaultMorningHour = 8
    static let defaultMorningMinute = 0
    static let defaultEveningHour = 21
    static let defaultEveningMinute = 0

    // MARK: - Storage Keys
    enum StorageKeys {
        static let hasCompletedOnboarding = "hasCompletedOnboarding"
        static let biometricLockEnabled = "biometricLockEnabled"
        static let lastPledgeDate = "lastPledgeDate"
        static let lastCheckinDate = "lastCheckinDate"
        static let morningReminderHour = "morningReminderHour"
        static let morningReminderMinute = "morningReminderMinute"
        static let eveningReminderHour = "eveningReminderHour"
        static let eveningReminderMinute = "eveningReminderMinute"
        static let hapticFeedbackEnabled = "hapticFeedbackEnabled"
    }

    // MARK: - SF Symbol Names
    enum Icons {
        static let streak = "flame.fill"
        static let savings = "dollarsign.circle.fill"
        static let pledge = "hand.raised.fill"
        static let settings = "gearshape.fill"
        static let bell = "bell.fill"
        static let bellSlash = "bell.slash.fill"
        static let sun = "sun.max.fill"
        static let moon = "moon.fill"
        static let clock = "clock.fill"
        static let checkmark = "checkmark.circle.fill"
        static let close = "xmark"
        static let chevronRight = "chevron.right"
        static let heart = "heart.fill"
        static let info = "info.circle.fill"
    }
}
```

The `morningPledgeWindowStart`/`End` and `eveningCheckinWindowStart`/`End` constants define the hours during which BetAway shows the morning pledge or evening check-in UI. The `PledgeViewModel` uses these to determine the current `TimeOfDay`:

```swift
@Observable
final class PledgeViewModel {
    enum TimeOfDay {
        case morning
        case evening
        case outsideWindow
    }

    var timeOfDay: TimeOfDay {
        let hour = Calendar.current.component(.hour, from: Date())
        if (AppConfig.morningPledgeWindowStart..<AppConfig.morningPledgeWindowEnd).contains(hour) {
            return .morning
        } else if (AppConfig.eveningCheckinWindowStart..<AppConfig.eveningCheckinWindowEnd).contains(hour) {
            return .evening
        }
        return .outsideWindow
    }
}
```

### UserProfile — Notification Settings Properties

The `UserProfile` SwiftData model stores notification preferences directly on the profile, not in `UserDefaults`. This means notification settings are part of the user's data and get deleted when the user resets:

```swift
@Model
final class UserProfile {
    var id: UUID = UUID()
    var createdAt: Date = Date()
    var quitDate: Date = Date()
    var displayName: String = ""

    // Gambling profile
    var gamblingTypesRaw: [String] = []
    var frequencyRaw: String = GamblingFrequency.weekly.rawValue
    var averageWeeklySpend: Double = 0

    // Settings
    var biometricLockEnabled: Bool = false
    var notificationsEnabled: Bool = true
    var morningReminderHour: Int = AppConfig.defaultMorningHour
    var morningReminderMinute: Int = AppConfig.defaultMorningMinute
    var eveningReminderHour: Int = AppConfig.defaultEveningHour
    var eveningReminderMinute: Int = AppConfig.defaultEveningMinute
    var hapticFeedbackEnabled: Bool = true
    var emergencyContactsData: Data?

    // Relationships
    @Relationship(deleteRule: .cascade) var checkins: [DailyCheckin] = []
    @Relationship(deleteRule: .cascade) var urgeLogs: [UrgeLog] = []
    @Relationship(deleteRule: .cascade) var journalEntries: [JournalEntry] = []
}
```

Notice the defaults: `morningReminderHour` defaults to `AppConfig.defaultMorningHour` (8) and `eveningReminderHour` defaults to `AppConfig.defaultEveningHour` (21). These are integers, not `Date` objects. Storing hour and minute as separate integers avoids timezone serialization issues and makes it trivial to pass them to `UNCalendarNotificationTrigger`.

### NotificationManager

This is the core service. It handles authorization, scheduling, and cancellation. Every notification content string goes through `LanguageManager.shared.localized()` so reminders arrive in the user's chosen app language:

```swift
import Foundation
import UserNotifications

@Observable
final class NotificationManager {
    var isAuthorized = false

    private let center = UNUserNotificationCenter.current()

    // MARK: - Authorization

    func requestAuthorization() async -> Bool {
        do {
            let granted = try await center.requestAuthorization(options: [.alert, .badge, .sound])
            await MainActor.run { isAuthorized = granted }
            return granted
        } catch {
            return false
        }
    }

    func checkAuthorizationStatus() async {
        let settings = await center.notificationSettings()
        await MainActor.run {
            isAuthorized = settings.authorizationStatus == .authorized
        }
    }

    // MARK: - Schedule Reminders

    func scheduleMorningPledge(hour: Int, minute: Int) {
        let id = "morning_pledge_reminder"
        center.removePendingNotificationRequests(withIdentifiers: [id])

        let content = UNMutableNotificationContent()
        content.title = LanguageManager.shared.localized( "Good Morning")
        content.body = LanguageManager.shared.localized( "Start your day with a pledge to stay bet-free.")
        content.sound = .default

        var dateComponents = DateComponents()
        dateComponents.hour = hour
        dateComponents.minute = minute

        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)

        center.add(request)
    }

    func scheduleEveningCheckin(hour: Int, minute: Int) {
        let id = "evening_checkin_reminder"
        center.removePendingNotificationRequests(withIdentifiers: [id])

        let content = UNMutableNotificationContent()
        content.title = LanguageManager.shared.localized( "Evening Check-in")
        content.body = LanguageManager.shared.localized( "How was your day? Take a moment to reflect.")
        content.sound = .default

        var dateComponents = DateComponents()
        dateComponents.hour = hour
        dateComponents.minute = minute

        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)

        center.add(request)
    }

    func scheduleMilestoneReminder(dayCount: Int, title: String) {
        let id = "milestone_\(dayCount)"
        center.removePendingNotificationRequests(withIdentifiers: [id])

        let content = UNMutableNotificationContent()
        content.title = LanguageManager.shared.localized( "Milestone Reached!")
        content.body = title
        content.sound = .default

        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)

        center.add(request)
    }

    // MARK: - Update Schedule

    func updateSchedule(
        morningHour: Int,
        morningMinute: Int,
        eveningHour: Int,
        eveningMinute: Int,
        enabled: Bool
    ) {
        if enabled {
            scheduleMorningPledge(hour: morningHour, minute: morningMinute)
            scheduleEveningCheckin(hour: eveningHour, minute: eveningMinute)
        } else {
            cancelAll()
        }
    }

    // MARK: - Cancel

    func cancelAll() {
        center.removeAllPendingNotificationRequests()
    }

    func cancelReminder(id: String) {
        center.removePendingNotificationRequests(withIdentifiers: [id])
    }
}
```

Key design decisions in this code:

1. **Each schedule method cancels its own ID first.** `scheduleMorningPledge` removes `"morning_pledge_reminder"` before creating the new request. This prevents duplicate notifications if the user changes the time multiple times.

2. **`UNCalendarNotificationTrigger` with `repeats: true`.** Only `hour` and `minute` are set in the `DateComponents` — no day, month, or year. This means the trigger fires every day at that time.

3. **`updateSchedule()` is the single orchestration point.** The `SettingsViewModel` calls this one method with all four time components and the enabled flag. If enabled, it schedules both. If disabled, it cancels everything.

4. **Milestone notifications use `UNTimeIntervalNotificationTrigger` with 1 second.** These fire immediately (well, after 1 second — the minimum). They are one-shot (`repeats: false`) and used when the user hits a streak milestone.

5. **All content strings use `LanguageManager.shared.localized()`.** If the user has set their app language to German, the morning notification says "Guten Morgen" instead of "Good Morning." This is runtime localization, not the system locale.

### SettingsViewModel — Notification Toggle Logic

The `SettingsViewModel` owns the permission-request flow. When the user toggles notifications ON, it requests authorization first. If denied, it flips the toggle back off by setting `profile.notificationsEnabled = false` on `MainActor`:

```swift
import SwiftUI
import SwiftData

@Observable
final class SettingsViewModel {
    var showResetConfirmation = false
    var showQuitDatePicker = false
    var showTipJar = false
    var showFeedback = false
    var showDataExport = false
    let notificationManager = NotificationManager()

    func toggleNotifications(enabled: Bool, profile: UserProfile) {
        if enabled {
            Task {
                let granted = await notificationManager.requestAuthorization()
                if granted {
                    notificationManager.updateSchedule(
                        morningHour: profile.morningReminderHour,
                        morningMinute: profile.morningReminderMinute,
                        eveningHour: profile.eveningReminderHour,
                        eveningMinute: profile.eveningReminderMinute,
                        enabled: true
                    )
                } else {
                    await MainActor.run {
                        profile.notificationsEnabled = false
                    }
                }
            }
        } else {
            notificationManager.cancelAll()
        }
    }

    func resetAllData(context: ModelContext, router: AppRouter) {
        do {
            try context.delete(model: UserProfile.self)
            try context.delete(model: DailyCheckin.self)
            try context.delete(model: UrgeLog.self)
            try context.delete(model: JournalEntry.self)
        } catch {
            // SwiftData delete errors are non-fatal for MVP
        }

        notificationManager.cancelAll()
        router.resetForNewUser()
    }
}
```

The critical flow here is the denial case. When `requestAuthorization()` returns `false`, the code sets `profile.notificationsEnabled = false` on `MainActor`. This is necessary because `UserProfile` is a SwiftData `@Model`, which is main-actor-isolated. Without `await MainActor.run`, you get a concurrency error. And without flipping the toggle back, the UI shows notifications as "ON" while they are actually denied — a confusing state.

Also notice that `resetAllData()` calls `notificationManager.cancelAll()`. When the user resets all data, you must also cancel all pending notifications. Otherwise, ghost reminders fire for an app that has been reset.

### SettingsView — Notification Section

The `SettingsView` wires the toggle to `SettingsViewModel.toggleNotifications()` and conditionally shows the morning/evening times when notifications are enabled:

```swift
// Inside SettingsView body — Notifications Section
Section {
    Toggle(isOn: Binding(
        get: { profile.notificationsEnabled },
        set: { newValue in
            profile.notificationsEnabled = newValue
            viewModel.toggleNotifications(enabled: newValue, profile: profile)
        }
    )) {
        Label("Notifications", systemImage: AppConfig.Icons.bell)
    }
    .tint(ColorPalette.accent)

    if profile.notificationsEnabled {
        HStack {
            Label("Morning Pledge", systemImage: AppConfig.Icons.sun)
            Spacer()
            Text(formatTime(hour: profile.morningReminderHour, minute: profile.morningReminderMinute))
                .foregroundStyle(ColorPalette.textSecondary)
        }

        HStack {
            Label("Evening Check-in", systemImage: AppConfig.Icons.moon)
            Spacer()
            Text(formatTime(hour: profile.eveningReminderHour, minute: profile.eveningReminderMinute))
                .foregroundStyle(ColorPalette.textSecondary)
        }
    }
} header: {
    Text("Reminders")
}
```

The `Toggle` uses a custom `Binding` — not a simple `$profile.notificationsEnabled` — because flipping the toggle needs to trigger the permission flow in addition to updating the model. The `set` closure does both: updates the model property and calls `toggleNotifications()`.

The `formatTime` helper converts integer hour/minute into a readable string:

```swift
private func formatTime(hour: Int, minute: Int) -> String {
    let formatter = DateFormatter()
    formatter.dateFormat = "h:mm a"
    var components = DateComponents()
    components.hour = hour
    components.minute = minute
    let date = Calendar.current.date(from: components) ?? Date()
    return formatter.string(from: date)
}
```

### NotificationPreferencesView — Onboarding

During onboarding, users configure their notification preferences before they have a `UserProfile`. The `OnboardingViewModel` stores temporary `morningReminderTime` and `eveningReminderTime` as `Date` objects (for the `DatePicker`), then converts them to integer hour/minute when creating the profile:

```swift
import SwiftUI

struct NotificationPreferencesView: View {
    @Bindable var viewModel: OnboardingViewModel
    @State private var isVisible = false

    var body: some View {
        VStack(spacing: Spacing.xxl) {
            Spacer()

            // Header
            VStack(spacing: Spacing.xs) {
                Image(systemName: AppConfig.Icons.bell)
                    .font(.system(size: 50))
                    .foregroundStyle(ColorPalette.primaryGradient)
                    .staggeredAppear(index: 0, isVisible: isVisible)

                Text("Stay on track")
                    .font(Typography.title1())
                    .foregroundStyle(ColorPalette.textPrimary)
                    .staggeredAppear(index: 1, isVisible: isVisible)

                Text("Gentle reminders to keep you accountable")
                    .font(Typography.callout())
                    .foregroundStyle(ColorPalette.textSecondary)
                    .multilineTextAlignment(.center)
                    .staggeredAppear(index: 2, isVisible: isVisible)
            }

            // Notification toggle
            VStack(spacing: Spacing.md) {
                BFCard {
                    Toggle(isOn: $viewModel.notificationsEnabled) {
                        HStack(spacing: Spacing.sm) {
                            Image(systemName: viewModel.notificationsEnabled
                                  ? AppConfig.Icons.bell
                                  : AppConfig.Icons.bellSlash)
                                .foregroundStyle(ColorPalette.accent)

                            Text("Enable Notifications")
                                .font(Typography.headline())
                                .foregroundStyle(ColorPalette.textPrimary)
                        }
                    }
                    .tint(ColorPalette.accent)
                }
                .padding(.horizontal, Spacing.xl)
                .staggeredAppear(index: 3, isVisible: isVisible)

                if viewModel.notificationsEnabled {
                    VStack(spacing: Spacing.sm) {
                        // Morning reminder
                        BFCard {
                            HStack {
                                VStack(alignment: .leading, spacing: Spacing.xxs) {
                                    Text("Morning Pledge")
                                        .font(Typography.headline())
                                        .foregroundStyle(ColorPalette.textPrimary)

                                    Text("Start your day with intention")
                                        .font(Typography.caption())
                                        .foregroundStyle(ColorPalette.textTertiary)
                                }

                                Spacer()

                                DatePicker(
                                    "",
                                    selection: $viewModel.morningReminderTime,
                                    displayedComponents: .hourAndMinute
                                )
                                .labelsHidden()
                                .tint(ColorPalette.accent)
                            }
                        }

                        // Evening reminder
                        BFCard {
                            HStack {
                                VStack(alignment: .leading, spacing: Spacing.xxs) {
                                    Text("Evening Check-in")
                                        .font(Typography.headline())
                                        .foregroundStyle(ColorPalette.textPrimary)

                                    Text("Reflect on your day")
                                        .font(Typography.caption())
                                        .foregroundStyle(ColorPalette.textTertiary)
                                }

                                Spacer()

                                DatePicker(
                                    "",
                                    selection: $viewModel.eveningReminderTime,
                                    displayedComponents: .hourAndMinute
                                )
                                .labelsHidden()
                                .tint(ColorPalette.accent)
                            }
                        }
                    }
                    .padding(.horizontal, Spacing.xl)
                    .transition(.opacity.combined(with: .move(edge: .top)))
                    .staggeredAppear(index: 4, isVisible: isVisible)
                }
            }
            .animation(AnimationPresets.smooth, value: viewModel.notificationsEnabled)

            Spacer()
            Spacer()
        }
        .onAppear { isVisible = true }
    }
}
```

When the user finishes onboarding, `OnboardingViewModel.createProfile()` extracts the hour and minute from the `Date` pickers and stores them on the new `UserProfile`:

```swift
func createProfile(in context: ModelContext, router: AppRouter) {
    let profile = UserProfile(
        quitDate: quitDate,
        gamblingTypes: Array(selectedGamblingTypes),
        frequency: selectedFrequency,
        averageWeeklySpend: averageWeeklySpend
    )
    profile.notificationsEnabled = notificationsEnabled

    let morningComponents = Calendar.current.dateComponents([.hour, .minute], from: morningReminderTime)
    profile.morningReminderHour = morningComponents.hour ?? AppConfig.defaultMorningHour
    profile.morningReminderMinute = morningComponents.minute ?? AppConfig.defaultMorningMinute

    let eveningComponents = Calendar.current.dateComponents([.hour, .minute], from: eveningReminderTime)
    profile.eveningReminderHour = eveningComponents.hour ?? AppConfig.defaultEveningHour
    profile.eveningReminderMinute = eveningComponents.minute ?? AppConfig.defaultEveningMinute

    context.insert(profile)
    router.completeOnboarding()
}
```

This is the bridge between the `DatePicker` (which needs a `Date`) and the `UserProfile` model (which stores integer hour/minute). The `?? AppConfig.defaultMorningHour` fallback ensures we always have a valid time even if the `DateComponents` extraction somehow fails.

## Checkpoint

Verify each of these:

- [ ] Notification permission is requested only when the user toggles notifications ON in Settings or enables them during onboarding — never at app launch, never automatically
- [ ] If the user denies permission, `profile.notificationsEnabled` is set to `false` on `MainActor`, flipping the toggle back to OFF
- [ ] `scheduleMorningPledge()` cancels `"morning_pledge_reminder"` before scheduling a new one — no duplicate morning notifications
- [ ] `scheduleEveningCheckin()` cancels `"evening_checkin_reminder"` before scheduling a new one — no duplicate evening notifications
- [ ] `updateSchedule(enabled: false)` calls `cancelAll()` to remove all pending notifications
- [ ] Reminder times default to 8:00 AM morning / 9:00 PM evening from `AppConfig`
- [ ] Times are stored as integer hour/minute on `UserProfile`, not as `Date` in `UserDefaults`
- [ ] Notification content is localized through `LanguageManager.shared.localized()` — switching app language changes the notification text
- [ ] Milestone notifications fire immediately (1-second `UNTimeIntervalNotificationTrigger`) and do not repeat
- [ ] `resetAllData()` in `SettingsViewModel` calls `notificationManager.cancelAll()` — no ghost notifications after reset

## What About Push Notifications?

This entire lesson uses **local notifications** — everything is scheduled on-device with `UNCalendarNotificationTrigger`. There is no server involved. This is a deliberate design choice for BetAway:

- **Privacy-first.** Recovery data never leaves the device. A push notification system requires a server that knows the user's device token and notification schedule — that is data we do not want to collect.
- **Offline-first.** Local notifications work without an internet connection. If a user is in airplane mode or has poor connectivity, their morning pledge reminder still fires.
- **Zero infrastructure cost.** No APNs certificates to manage, no backend to maintain, no Firebase Cloud Messaging dependency.

If your app *does* need push notifications — for example, a social app with real-time messages or a commerce app with order updates — the pattern is different. You would:

1. Register for remote notifications with `UIApplication.shared.registerForRemoteNotifications()`
2. Implement `application(_:didRegisterForRemoteNotificationsWithDeviceToken:)` in your `AppDelegate` to capture the device token
3. Send the token to your backend, which uses APNs (Apple Push Notification service) to deliver notifications
4. Handle incoming notifications with `UNUserNotificationCenterDelegate` methods — which you already know from this lesson

The permission request flow (`UNUserNotificationCenter.requestAuthorization`) and the `UNUserNotificationCenterDelegate` handling are identical for local and remote notifications. So everything you learned here transfers directly — the only difference is *who schedules the notification* (your app locally vs. your server remotely).

## Challenge

**Add configurable notification sounds and a "test notification" button.**

Extend the notification system so users can choose from three notification sounds (default, gentle chime, silent) in Settings. Store the selection on `UserProfile` and use it when building the `UNMutableNotificationContent`. Add a "Send Test Notification" button in Settings that schedules a notification 5 seconds in the future so the user can preview what their reminder will look and sound like.

**Hint:** For custom sounds, add `.caf` audio files to the bundle and use `UNNotificationSound(named: UNNotificationSoundName("gentle_chime.caf"))`. For the test notification, use `UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)` with a unique identifier like `"test_notification"` so it does not interfere with the daily reminders.
