---
title: "SwiftData Model Layer"
description: "Design and implement the UserProfile, DailyCheckin, UrgeLog, and JournalEntry SwiftData models with relationships and cascade delete rules, build domain enums, and configure the ModelContainer."
courseSlug: "ship-native"
module: 1
moduleTitle: "Project Foundation"
lesson: 2
duration: "25 min read"
difficulty: "intermediate"
topics: ["SwiftData", "@Model", "Data Modeling", "Relationships", "Enums", "Computed Properties", "BetAway"]
author: "Mario"
draft: true
pubDate: 2026-02-22
---

Your architecture is set. Your CLAUDE.md is written. Now we build the thing that every feature in BetAway depends on: the data layer.

If you get the models wrong, every view, every query, every insight engine built on top of them will be wrong. If you get them right, everything else falls into place. This is why we build models first, views second, and AI features last.

In this lesson, we design four SwiftData models, a rich set of domain enums, wire relationships with cascade delete rules, and learn the raw-value storage pattern that makes SwiftData and Swift enums play nicely together. We do it using the Plan-Execute-Verify workflow â€” the same workflow you will use for every feature in this course.

## What You'll Learn

- How to design `@Model` classes with one-to-many relationships and cascade delete rules
- The raw-value storage pattern: store a `String`, expose a computed enum property
- How to build domain enums (`MoodRating`, `GamblingType`, `CopingStrategy`) that drive the entire UI
- How to store non-model data (like `EmergencyContact`) as JSON `Data` inside a SwiftData model
- How to add rich computed properties (`currentStreak`, `totalSaved`) directly on models

## Why This Matters

Every production iOS app needs a persistence layer, and SwiftData is Apple's answer for Swift-native apps. But SwiftData is opinionated â€” get the relationships, delete rules, or enum storage wrong and you hit runtime crashes that the compiler will not catch. The domain model layer we build here is the heart of BetAway. Every view, every chart, every notification depends on these types being correct.

## Plan Phase: Defining What We Build

Before we prompt for code, we tell the AI what we want and ask it to think. Here is the planning prompt:

```
I am building BetAway, a free gambling recovery app for iOS.
I need the SwiftData model layer. Before writing code, plan
the following:

1. UserProfile â€” the central model. Properties: id (UUID),
   createdAt, quitDate, displayName, gambling types (stored as
   raw string array), frequency, averageWeeklySpend,
   notification settings, biometric lock, emergency contacts
   (stored as JSON Data). One-to-many relationships with
   DailyCheckin, UrgeLog, JournalEntry â€” all with cascade
   delete rules.

2. DailyCheckin â€” daily mood check-in. Properties: id, date,
   checkin type (morning pledge or evening), mood (1-5),
   gamblingFree bool, pledgeReason, notes, triggers (raw
   string array), risk level. Inverse relationship to
   UserProfile.

3. UrgeLog â€” gambling urge log. Properties: id, timestamp,
   intensity (1-10), duration, trigger, coping strategy,
   didResist bool, notes. Inverse relationship to UserProfile.

4. JournalEntry â€” journal entries. Properties: id, createdAt,
   title, content, mood (1-5), promptUsed. Inverse relationship
   to UserProfile.

5. Domain enums â€” GamblingType, GamblingFrequency, RiskLevel,
   MoodRating (1-5 with emoji + label), CheckinType, CopingStrategy,
   PredefinedTrigger. All Codable + CaseIterable.

6. EmergencyContact â€” a Codable struct (not @Model) stored as
   JSON Data inside UserProfile.

Think through: the raw-value storage pattern for enums in
SwiftData, cascade vs nullify delete rules, computed
properties on models (currentStreak, totalSaved), and how
to store non-model types as JSON Data. Then implement
everything in Swift 6.
```

### Why This Prompt Works

This prompt is specific about the data architecture. It names every model with exact property types. It specifies relationship directions ("one-to-many from UserProfile") and delete rules ("cascade"). It explicitly asks for the raw-value storage pattern â€” because SwiftData cannot persist custom enums directly, you must store the `rawValue` String and expose a computed property. If you do not mention this, the AI will try to store enums directly and you will get runtime crashes.

It also calls out the JSON Data pattern for `EmergencyContact`. This is a real production technique â€” when you have a small, structured type that does not need its own table, encode it as JSON and store it as `Data` on the parent model. Simpler schema, fewer migrations.

### The Anti-Pattern: What Not to Prompt

```
Make SwiftData models for a recovery app. I need user profiles,
check-ins, urges, and journals. Also add enums.
```

This will produce code. It will also produce models that try to store Swift enums directly in SwiftData (crash), missing inverse relationships, `@Relationship` without delete rules (defaults to `.nullify` when you wanted `.cascade`), and no computed properties. Vague input produces vague output â€” always.

## Execute Phase: Implementation

Now we send the planning prompt. Claude Code generates the full model layer. Let us review each file, starting with the domain enums that everything else depends on.

### Enums.swift â€” Domain Types

Before building any `@Model` classes, we define the enums. These drive the entire app â€” from the onboarding flow (picking gambling types) to the dashboard (displaying mood emoji) to the urge flow (selecting triggers and coping strategies).

```swift
import Foundation

// MARK: - Gambling Type

enum GamblingType: String, Codable, CaseIterable, Identifiable {
    case sportsBetting = "Sports Betting"
    case onlineCasino = "Online Casino"
    case poker = "Poker"
    case slots = "Slots/Machines"
    case lottery = "Lottery/Scratch Cards"
    case inPersonCasino = "In-Person Casino"
    case esportsBetting = "eSports Betting"
    case cryptoGambling = "Crypto Gambling"
    case other = "Other"

    var id: String { rawValue }

    var icon: String {
        switch self {
        case .sportsBetting: return "sportscourt.fill"
        case .onlineCasino: return "desktopcomputer"
        case .poker: return "suit.spade.fill"
        case .slots: return "die.face.5.fill"
        case .lottery: return "ticket.fill"
        case .inPersonCasino: return "building.columns.fill"
        case .esportsBetting: return "gamecontroller.fill"
        case .cryptoGambling: return "bitcoinsign.circle.fill"
        case .other: return "questionmark.circle.fill"
        }
    }
}

// MARK: - Mood Rating

enum MoodRating: Int, Codable, CaseIterable, Identifiable {
    case veryBad = 1
    case bad = 2
    case neutral = 3
    case good = 4
    case veryGood = 5

    var id: Int { rawValue }

    var emoji: String {
        switch self {
        case .veryBad: return "ðŸ˜£"
        case .bad: return "ðŸ˜”"
        case .neutral: return "ðŸ˜"
        case .good: return "ðŸ™‚"
        case .veryGood: return "ðŸ˜Š"
        }
    }

    var label: String {
        switch self {
        case .veryBad: return "Very Bad"
        case .bad: return "Bad"
        case .neutral: return "Okay"
        case .good: return "Good"
        case .veryGood: return "Great"
        }
    }
}

// MARK: - Check-in Type

enum CheckinType: String, Codable {
    case morningPledge = "Morning Pledge"
    case eveningCheckin = "Evening Check-in"
}

// MARK: - Coping Strategy

enum CopingStrategy: String, Codable, CaseIterable, Identifiable {
    case breathingExercise = "Breathing Exercise"
    case groundingExercise = "Grounding Exercise"
    case calledSomeone = "Called Someone"
    case physicalActivity = "Physical Activity"
    case journaled = "Journaled"
    case distraction = "Distraction Activity"
    case other = "Other"

    var id: String { rawValue }

    var icon: String {
        switch self {
        case .breathingExercise: return "wind"
        case .groundingExercise: return "leaf.fill"
        case .calledSomeone: return "phone.fill"
        case .physicalActivity: return "figure.walk"
        case .journaled: return "book.fill"
        case .distraction: return "gamecontroller.fill"
        case .other: return "ellipsis.circle.fill"
        }
    }
}

// MARK: - Predefined Triggers

enum PredefinedTrigger: String, Codable, CaseIterable, Identifiable {
    case liveSports = "Watching live sports"
    case bettingPromo = "Betting app promotion"
    case stressed = "Feeling stressed"
    case bored = "Feeling bored"
    case gamblingAds = "Seeing gambling ads"
    case friendsTalking = "Friends talking about bets"
    case payday = "Payday / received money"
    case argument = "Argument with someone"
    case alcohol = "Drinking alcohol"
    case lateNight = "Late night / can't sleep"
    case winningMemory = "Remembering a win"
    case chasingLosses = "Wanting to chase losses"

    var id: String { rawValue }

    var icon: String {
        switch self {
        case .liveSports: return "sportscourt.fill"
        case .bettingPromo: return "bell.badge.fill"
        case .stressed: return "brain.head.profile"
        case .bored: return "clock.fill"
        case .gamblingAds: return "rectangle.on.rectangle.angled"
        case .friendsTalking: return "person.2.fill"
        case .payday: return "banknote.fill"
        case .argument: return "exclamationmark.bubble.fill"
        case .alcohol: return "wineglass.fill"
        case .lateNight: return "moon.fill"
        case .winningMemory: return "star.fill"
        case .chasingLosses: return "arrow.uturn.backward.circle.fill"
        }
    }
}
```

Let us talk about the design decisions:

- **Every enum uses `String` raw values.** This is critical. SwiftData cannot persist custom Swift enums. We will store the `rawValue` in the database and convert back via computed properties. The raw values are human-readable strings, which makes the database debuggable â€” you can open the SQLite file and see "Sports Betting" instead of an opaque integer.
- **`CaseIterable` everywhere.** This lets us `ForEach(GamblingType.allCases)` in the UI. No manual arrays.
- **`Identifiable` everywhere.** Required for `ForEach` and `List` in SwiftUI. The `id` is the raw value.
- **Each enum owns its SF Symbol icon.** Instead of a mapping dictionary somewhere, the icon lives on the type. When you add a new gambling type, you are forced to add its icon â€” the compiler enforces it via the `switch` statement.
- **`MoodRating` uses `Int` raw values (1-5).** This is stored as an `Int` in the database for efficient sorting and aggregation. The `emoji` and `label` are computed.

### UserProfile.swift â€” The Central Model

```swift
import Foundation
import SwiftData

@Model
final class UserProfile {
    var id: UUID = UUID()
    var createdAt: Date = Date()
    var quitDate: Date = Date()
    var displayName: String = ""

    // Gambling profile
    var gamblingTypesRaw: [String] = []
    var frequencyRaw: String = GamblingFrequency.weekly.rawValue
    var averageWeeklySpend: Double = 0
    var estimatedTotalLosses: Double?
    var estimatedDebt: Double?

    // Settings
    var biometricLockEnabled: Bool = false
    var notificationsEnabled: Bool = true
    var morningReminderHour: Int = AppConfig.defaultMorningHour
    var morningReminderMinute: Int = AppConfig.defaultMorningMinute
    var eveningReminderHour: Int = AppConfig.defaultEveningHour
    var eveningReminderMinute: Int = AppConfig.defaultEveningMinute
    var hapticFeedbackEnabled: Bool = true
    var emergencyContactsData: Data?

    // Relationships
    @Relationship(deleteRule: .cascade) var checkins: [DailyCheckin] = []
    @Relationship(deleteRule: .cascade) var urgeLogs: [UrgeLog] = []
    @Relationship(deleteRule: .cascade) var journalEntries: [JournalEntry] = []

    // MARK: - Computed Properties

    var gamblingTypes: [GamblingType] {
        get { gamblingTypesRaw.compactMap { GamblingType(rawValue: $0) } }
        set { gamblingTypesRaw = newValue.map(\.rawValue) }
    }

    var emergencyContacts: [EmergencyContact] {
        get {
            guard let data = emergencyContactsData else { return [] }
            return (try? JSONDecoder().decode([EmergencyContact].self, from: data)) ?? []
        }
        set {
            emergencyContactsData = try? JSONEncoder().encode(newValue)
        }
    }

    var daysSinceQuit: Int {
        max(0, Calendar.current.dateComponents([.day], from: Calendar.current.startOfDay(for: quitDate), to: Calendar.current.startOfDay(for: Date())).day ?? 0)
    }

    var totalSaved: Double {
        let weeks = Double(daysSinceQuit) / 7.0
        return weeks * averageWeeklySpend
    }

    var currentStreak: Int {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        let quitStart = calendar.startOfDay(for: quitDate)

        if quitStart > today { return 0 }

        let relapses = checkins
            .filter { !$0.gamblingFree && $0.checkinTypeRaw == CheckinType.eveningCheckin.rawValue }
            .sorted { $0.date > $1.date }

        if let lastRelapse = relapses.first {
            let relapsDay = calendar.startOfDay(for: lastRelapse.date)
            let daysSinceRelapse = calendar.dateComponents([.day], from: relapsDay, to: today).day ?? 0
            return max(0, daysSinceRelapse)
        }

        return daysSinceQuit
    }

    // MARK: - Init

    init(
        quitDate: Date = Date(),
        displayName: String = "",
        gamblingTypes: [GamblingType] = [],
        frequency: GamblingFrequency = .weekly,
        averageWeeklySpend: Double = 0
    ) {
        self.id = UUID()
        self.createdAt = Date()
        self.quitDate = quitDate
        self.displayName = displayName
        self.gamblingTypesRaw = gamblingTypes.map(\.rawValue)
        self.frequencyRaw = frequency.rawValue
        self.averageWeeklySpend = averageWeeklySpend
    }

    // MARK: - Helpers

    func hasPledgedToday() -> Bool {
        let calendar = Calendar.current
        return checkins.contains { checkin in
            checkin.checkinTypeRaw == CheckinType.morningPledge.rawValue &&
            calendar.isDateInToday(checkin.date)
        }
    }

    func hasCheckedInToday() -> Bool {
        let calendar = Calendar.current
        return checkins.contains { checkin in
            checkin.checkinTypeRaw == CheckinType.eveningCheckin.rawValue &&
            calendar.isDateInToday(checkin.date)
        }
    }
}
```

This is the most complex model in the app. Let us break down the critical patterns:

- **Raw-value storage pattern.** `gamblingTypesRaw: [String]` stores the database value. `gamblingTypes: [GamblingType]` is a computed property that converts. SwiftData persists `[String]` natively. It cannot persist `[GamblingType]`. This pattern appears everywhere in the codebase.
- **JSON Data for `EmergencyContact`.** This is a `Codable` struct, not an `@Model`. We encode it as JSON and store the `Data` blob. The getter decodes, the setter encodes. This avoids creating a separate database table for a small, simple type.
- **`@Relationship(deleteRule: .cascade)`** on all three arrays. When a `UserProfile` is deleted, all its checkins, urge logs, and journal entries are deleted too. This is correct â€” those records have no meaning without their parent profile.
- **`currentStreak` is a computed property**, not a stored value. It checks for the most recent relapse (an evening check-in where `gamblingFree == false`) and counts days from there. If there are no relapses, it counts from `quitDate`. This logic runs on every access, which is fine â€” the data set is small (one check-in per day).
- **`hasPledgedToday()` and `hasCheckedInToday()`** filter the `checkins` array in memory. For a typical user (one morning pledge + one evening check-in per day), this is dozens of records at most. No need for a database query.

### DailyCheckin.swift

```swift
import Foundation
import SwiftData

@Model
final class DailyCheckin {
    var id: UUID = UUID()
    var date: Date = Date()
    var checkinTypeRaw: String = CheckinType.morningPledge.rawValue
    var mood: Int = MoodRating.neutral.rawValue
    var gamblingFree: Bool = true
    var amountGambled: Double?
    var pledgeReason: String = ""
    var notes: String = ""
    var triggersRaw: [String] = []
    var riskLevelRaw: String = RiskLevel.low.rawValue
    var createdAt: Date = Date()

    @Relationship(inverse: \UserProfile.checkins) var userProfile: UserProfile?

    // MARK: - Computed Properties

    var checkinType: CheckinType {
        get { CheckinType(rawValue: checkinTypeRaw) ?? .morningPledge }
        set { checkinTypeRaw = newValue.rawValue }
    }

    var moodRating: MoodRating {
        get { MoodRating(rawValue: mood) ?? .neutral }
        set { mood = newValue.rawValue }
    }

    var triggers: [PredefinedTrigger] {
        get { triggersRaw.compactMap { PredefinedTrigger(rawValue: $0) } }
        set { triggersRaw = newValue.map(\.rawValue) }
    }

    // MARK: - Init

    init(
        checkinType: CheckinType,
        mood: MoodRating = .neutral,
        gamblingFree: Bool = true,
        pledgeReason: String = "",
        notes: String = ""
    ) {
        self.id = UUID()
        self.date = Date()
        self.checkinTypeRaw = checkinType.rawValue
        self.mood = mood.rawValue
        self.gamblingFree = gamblingFree
        self.pledgeReason = pledgeReason
        self.notes = notes
        self.createdAt = Date()
    }
}
```

Key details:

- **`checkinTypeRaw` stores the raw string, `checkinType` exposes the enum.** Same pattern as `gamblingTypesRaw` on `UserProfile`. The init takes the enum, the stored property is the raw value.
- **`triggersRaw: [String]`** stores multiple triggers as a string array. The computed `triggers` property converts to `[PredefinedTrigger]` using `compactMap`. If a trigger is renamed in a future version, `compactMap` silently drops the unrecognized value instead of crashing.
- **`@Relationship(inverse: \UserProfile.checkins)`** declares the inverse side. Only one side declares the inverse â€” the other side (`UserProfile.checkins`) uses `@Relationship(deleteRule: .cascade)` without `inverse:`.
- **`gamblingFree: Bool`** â€” this is the critical field. A `false` value in an evening check-in resets the streak counter.

### UrgeLog.swift

```swift
import Foundation
import SwiftData

@Model
final class UrgeLog {
    var id: UUID = UUID()
    var timestamp: Date = Date()
    var intensity: Int = 5
    var durationSeconds: TimeInterval = 0
    var triggerRaw: String = ""
    var copingStrategyRaw: String = ""
    var didResist: Bool = true
    var notes: String = ""

    @Relationship(inverse: \UserProfile.urgeLogs) var userProfile: UserProfile?

    var trigger: PredefinedTrigger? {
        get { PredefinedTrigger(rawValue: triggerRaw) }
        set { triggerRaw = newValue?.rawValue ?? "" }
    }

    var copingStrategy: CopingStrategy? {
        get { CopingStrategy(rawValue: copingStrategyRaw) }
        set { copingStrategyRaw = newValue?.rawValue ?? "" }
    }

    init(
        intensity: Int = 5,
        trigger: PredefinedTrigger? = nil,
        copingStrategy: CopingStrategy? = nil,
        didResist: Bool = true,
        notes: String = ""
    ) {
        self.id = UUID()
        self.timestamp = Date()
        self.intensity = intensity
        self.triggerRaw = trigger?.rawValue ?? ""
        self.copingStrategyRaw = copingStrategy?.rawValue ?? ""
        self.didResist = didResist
        self.notes = notes
    }
}
```

- **`trigger` and `copingStrategy` are optional** â€” the user might log an urge without identifying the trigger. The computed property returns `nil` when the raw string is empty or unrecognized.
- **`durationSeconds`** is set externally after the urge timer runs. The init defaults to `0`.

### JournalEntry.swift

```swift
import Foundation
import SwiftData

@Model
final class JournalEntry {
    var id: UUID = UUID()
    var createdAt: Date = Date()
    var title: String = ""
    var content: String = ""
    var mood: Int = 3
    var promptUsed: String = ""

    @Relationship(inverse: \UserProfile.journalEntries) var userProfile: UserProfile?

    var moodRating: MoodRating? {
        get { MoodRating(rawValue: mood) }
        set { mood = newValue?.rawValue ?? 3 }
    }

    init(
        title: String = "",
        content: String = "",
        mood: MoodRating = .neutral,
        promptUsed: String = ""
    ) {
        self.id = UUID()
        self.createdAt = Date()
        self.title = title
        self.content = content
        self.mood = mood.rawValue
        self.promptUsed = promptUsed
    }
}
```

The simplest model. `promptUsed` tracks which journal prompt the user was responding to â€” useful for analytics later.

### EmergencyContact.swift

```swift
import Foundation

struct EmergencyContact: Codable, Identifiable, Equatable {
    var id: UUID = UUID()
    var name: String
    var phoneNumber: String

    var isValid: Bool {
        !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !phoneNumber.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    var callURL: URL? {
        let cleaned = phoneNumber.replacingOccurrences(of: "[^0-9+]", with: "", options: .regularExpression)
        guard !cleaned.isEmpty else { return nil }
        return URL(string: "tel://\(cleaned)")
    }
}
```

This is **not** an `@Model` â€” it is a plain `Codable` struct stored as JSON `Data` inside `UserProfile`. Notice `callURL` strips non-numeric characters from the phone number and builds a `tel://` URL. This handles messy user input like "(555) 123-4567" gracefully.

### AI Output Review

Here is how I evaluate what the AI generated:

- **Raw-value storage pattern used consistently** â€” every enum property stores the raw value and exposes a computed getter/setter. This is the only safe way to use custom enums with SwiftData
- **Cascade delete rules on the parent side** â€” correct. Deleting a UserProfile cascades to all child records
- **Inverse declarations only on the child side** â€” correct. `DailyCheckin`, `UrgeLog`, and `JournalEntry` each declare `inverse:`, while `UserProfile` does not
- **No force unwraps** â€” every property has a default value or is genuinely optional
- **Computed properties for business logic** â€” `currentStreak` and `totalSaved` derive from the data, not stored redundantly

One thing to watch: the AI might try to store `[GamblingType]` directly instead of `[String]`. SwiftData will compile this but crash at runtime. Always store raw values and convert via computed properties.

## Iteration

The initial generation covers the models. Now we need the Milestone struct that drives the dashboard progress UI:

```
Add a Milestone struct (not @Model â€” it is static data) with
these properties: id (Int), days (Int), titleKey (String),
descriptionKey (String), icon (String â€” SF Symbol).

Include a static `all` array with milestones at: 1, 3, 7, 14,
30, 60, 90, 180, 365 days.

Add two static methods:
- current(for days: Int) -> Milestone? â€” returns the most
  recent milestone the user has passed
- next(for days: Int) -> Milestone? â€” returns the next
  upcoming milestone

Do not make this an @Model. It is a fixed data set â€” no
database storage needed.
```

### Milestone Struct

```swift
struct Milestone: Identifiable {
    let id: Int
    let days: Int
    let titleKey: String
    let descriptionKey: String
    let icon: String

    var title: String {
        LanguageManager.shared.bundle.localizedString(forKey: titleKey, value: nil, table: nil)
    }

    var description: String {
        LanguageManager.shared.bundle.localizedString(forKey: descriptionKey, value: nil, table: nil)
    }

    static let all: [Milestone] = [
        Milestone(id: 1, days: 1, titleKey: "Day 1", descriptionKey: "The hardest step is the first one", icon: "leaf.fill"),
        Milestone(id: 2, days: 3, titleKey: "3 Days", descriptionKey: "72 hours. Your brain is already adjusting", icon: "seedling"),
        Milestone(id: 3, days: 7, titleKey: "1 Week", descriptionKey: "One full week! This is real progress", icon: "star.fill"),
        Milestone(id: 4, days: 14, titleKey: "2 Weeks", descriptionKey: "Dopamine receptors are recovering", icon: "star.circle.fill"),
        Milestone(id: 5, days: 30, titleKey: "1 Month", descriptionKey: "You're building a new identity", icon: "trophy.fill"),
        Milestone(id: 6, days: 60, titleKey: "2 Months", descriptionKey: "New habits are forming", icon: "diamond.fill"),
        Milestone(id: 7, days: 90, titleKey: "90 Days", descriptionKey: "Clinical recovery benchmark", icon: "crown.fill"),
        Milestone(id: 8, days: 180, titleKey: "6 Months", descriptionKey: "Half a year. Incredible strength", icon: "medal.fill"),
        Milestone(id: 9, days: 365, titleKey: "1 Year", descriptionKey: "ONE YEAR BET-FREE", icon: "rosette"),
    ]

    static func current(for days: Int) -> Milestone? {
        all.last { $0.days <= days }
    }

    static func next(for days: Int) -> Milestone? {
        all.first { $0.days > days }
    }
}
```

This is a good example of knowing when **not** to use SwiftData. Milestones are fixed data â€” they never change at runtime. Making them an `@Model` would add database overhead for no benefit. A static array is the simplest, fastest solution.

The `title` and `description` properties go through `LanguageManager` for localization. The `titleKey` and `descriptionKey` are the English strings that also serve as localization keys.

## Verify Phase

Before moving to the next lesson, verify these things manually:

1. **Build the project.** All model files and enums should compile with zero warnings under Swift 6 strict concurrency.

2. **Check the relationship inverses.** Open `DailyCheckin.swift` and confirm `@Relationship(inverse: \UserProfile.checkins)`. Do the same for `UrgeLog` and `JournalEntry`. Confirm `UserProfile` does NOT also declare `inverse:` on its relationship arrays â€” only one side declares the inverse.

3. **Check delete rules.** `UserProfile` should use `.cascade` on all three relationship arrays. This is correct for one-to-many where the parent owns the children. If the AI generated `.nullify`, change it â€” orphaned check-ins with no parent profile are useless data.

4. **Test the raw-value pattern.** Create a `DailyCheckin` with `checkinType: .morningPledge`. Print `checkinTypeRaw` â€” it should be `"Morning Pledge"`. Set `checkinType = .eveningCheckin`. Print `checkinTypeRaw` again â€” it should be `"Evening Check-in"`.

5. **Test computed properties.** Create a `UserProfile` with a `quitDate` of 7 days ago. Check that `daysSinceQuit == 7` and `currentStreak == 7` (with no relapses). Add an evening check-in with `gamblingFree = false` dated 2 days ago. Check that `currentStreak == 2`.

6. **Test persistence.** Insert a `UserProfile` and a `DailyCheckin`, quit the app, relaunch. Both should persist. Delete the profile â€” confirm the check-in is also deleted (cascade).

## Checkpoint

Before moving to Lesson 2.1, confirm all of these:

- [ ] `UserProfile`, `DailyCheckin`, `UrgeLog`, `JournalEntry` compile with zero warnings under Swift 6
- [ ] All enums (`GamblingType`, `MoodRating`, `CheckinType`, `CopingStrategy`, `PredefinedTrigger`) are `Codable` and `CaseIterable`
- [ ] Every enum property uses the raw-value storage pattern (stored as String/Int, computed getter/setter for the enum)
- [ ] `UserProfile` has `.cascade` delete rules on all three relationship arrays
- [ ] Child models declare `inverse:` â€” parent model does not
- [ ] `EmergencyContact` is a `Codable` struct stored as JSON `Data`
- [ ] `currentStreak` correctly resets when there is a relapse
- [ ] `totalSaved` calculates based on `daysSinceQuit` and `averageWeeklySpend`
- [ ] `Milestone.current(for:)` and `Milestone.next(for:)` return correct values
- [ ] `ModelContainer` schema includes all four model types

## Challenge

**Add `todaysMood()` and emergency contact management methods to `UserProfile`.**

The profile needs three methods for emergency contacts (max 3):

```swift
func addEmergencyContact(_ contact: EmergencyContact) {
    var contacts = emergencyContacts
    guard contacts.count < 3 else { return }
    contacts.append(contact)
    emergencyContacts = contacts
}

func removeEmergencyContact(_ contact: EmergencyContact) {
    var contacts = emergencyContacts
    contacts.removeAll { $0.id == contact.id }
    emergencyContacts = contacts
}
```

And a mood helper:

```swift
func todaysMood() -> MoodRating? {
    let calendar = Calendar.current
    let todayCheckin = checkins
        .filter { calendar.isDateInToday($0.date) }
        .sorted { $0.date > $1.date }
        .first
    return todayCheckin.flatMap { MoodRating(rawValue: $0.mood) }
}
```

Notice how `todaysMood()` uses `flatMap` on the optional to chain the `MoodRating` init. If there is no check-in today, `first` is `nil`, so `flatMap` returns `nil`. If there is a check-in but the mood value is invalid, `MoodRating(rawValue:)` returns `nil`. Two potential failures handled in one expression.

---

Next up: **Lesson 2.1 â€” Design System & Theme**, where we build the `ColorPalette`, `Typography`, `Spacing`, and `AnimationPresets` that give BetAway its visual identity.
